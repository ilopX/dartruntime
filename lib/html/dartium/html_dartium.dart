#library('html');

#import('dart:isolate');
#import('dart:nativewrappers');
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated dart:html library.







_WindowImpl __window;
_DocumentImpl __document;

void _initialize() {
  __window = _wrap(_Utils.window());
  __document = _wrap(_Utils.window().document);
}

Window get window() {
  if (__window == null) {
    _initialize();
  }
  return __window;
}

Document get document() {
  if (__document == null) {
    _initialize();
  }
  return __document;
}

_WindowImpl get _window() {
  if (__window == null) {
    _initialize();
  }
  return __window;
}

_DocumentImpl get _document() {
  if (__document == null) {
    _initialize();
  }
  return __document;
}

_unwrap(raw) {
  return raw is _DOMTypeBase ? raw._ptr : raw;
}

// Warning: does not attempt wrap event listeners.
_wrap(raw) {
  if (raw is! _DOMWrapperBase) return raw;
  _DOMWrapperBase domObject = raw;
  if (domObject.dartObjectLocalStorage != null)
    return domObject.dartObjectLocalStorage;
  switch(domObject.typeName) {
    case 'HTMLElement':
      return new _UnknownElementImpl._wrap(domObject);
    case 'EventTarget': return new _EventTargetImpl._wrap(domObject);
    case 'AbstractWorker': return new _AbstractWorkerImpl._wrap(domObject);
    case 'Node': return new _NodeImpl._wrap(domObject);
    case 'NodeSelector': return new _NodeSelectorImpl._wrap(domObject);
    case 'ElementTraversal': return new _ElementTraversalImpl._wrap(domObject);
    case 'Element': return new _ElementImpl._wrap(domObject);
    case 'HTMLAnchorElement': return new _AnchorElementImpl._wrap(domObject);
    case 'WebKitAnimation': return new _AnimationImpl._wrap(domObject);
    case 'Event': return new _EventImpl._wrap(domObject);
    case 'WebKitAnimationEvent': return new _AnimationEventImpl._wrap(domObject);
    case 'WebKitAnimationList': return new _AnimationListImpl._wrap(domObject);
    case 'HTMLAppletElement': return new _AppletElementImpl._wrap(domObject);
    case 'HTMLAreaElement': return new _AreaElementImpl._wrap(domObject);
    case 'ArrayBuffer': return new _ArrayBufferImpl._wrap(domObject);
    case 'ArrayBufferView': return new _ArrayBufferViewImpl._wrap(domObject);
    case 'Attr': return new _AttrImpl._wrap(domObject);
    case 'AudioBuffer': return new _AudioBufferImpl._wrap(domObject);
    case 'AudioNode': return new _AudioNodeImpl._wrap(domObject);
    case 'AudioSourceNode': return new _AudioSourceNodeImpl._wrap(domObject);
    case 'AudioBufferSourceNode': return new _AudioBufferSourceNodeImpl._wrap(domObject);
    case 'AudioChannelMerger': return new _AudioChannelMergerImpl._wrap(domObject);
    case 'AudioChannelSplitter': return new _AudioChannelSplitterImpl._wrap(domObject);
    case 'AudioContext': return new _AudioContextImpl._wrap(domObject);
    case 'AudioDestinationNode': return new _AudioDestinationNodeImpl._wrap(domObject);
    case 'HTMLMediaElement': return new _MediaElementImpl._wrap(domObject);
    case 'HTMLAudioElement': return new _AudioElementImpl._wrap(domObject);
    case 'AudioParam': return new _AudioParamImpl._wrap(domObject);
    case 'AudioGain': return new _AudioGainImpl._wrap(domObject);
    case 'AudioGainNode': return new _AudioGainNodeImpl._wrap(domObject);
    case 'AudioListener': return new _AudioListenerImpl._wrap(domObject);
    case 'AudioPannerNode': return new _AudioPannerNodeImpl._wrap(domObject);
    case 'AudioProcessingEvent': return new _AudioProcessingEventImpl._wrap(domObject);
    case 'HTMLBRElement': return new _BRElementImpl._wrap(domObject);
    case 'BarInfo': return new _BarInfoImpl._wrap(domObject);
    case 'HTMLBaseElement': return new _BaseElementImpl._wrap(domObject);
    case 'HTMLBaseFontElement': return new _BaseFontElementImpl._wrap(domObject);
    case 'BatteryManager': return new _BatteryManagerImpl._wrap(domObject);
    case 'BeforeLoadEvent': return new _BeforeLoadEventImpl._wrap(domObject);
    case 'BiquadFilterNode': return new _BiquadFilterNodeImpl._wrap(domObject);
    case 'Blob': return new _BlobImpl._wrap(domObject);
    case 'HTMLBodyElement': return new _BodyElementImpl._wrap(domObject);
    case 'HTMLButtonElement': return new _ButtonElementImpl._wrap(domObject);
    case 'CharacterData': return new _CharacterDataImpl._wrap(domObject);
    case 'Text': return new _TextImpl._wrap(domObject);
    case 'CDATASection': return new _CDATASectionImpl._wrap(domObject);
    case 'CSSRule': return new _CSSRuleImpl._wrap(domObject);
    case 'CSSCharsetRule': return new _CSSCharsetRuleImpl._wrap(domObject);
    case 'CSSFontFaceRule': return new _CSSFontFaceRuleImpl._wrap(domObject);
    case 'CSSImportRule': return new _CSSImportRuleImpl._wrap(domObject);
    case 'WebKitCSSKeyframeRule': return new _CSSKeyframeRuleImpl._wrap(domObject);
    case 'WebKitCSSKeyframesRule': return new _CSSKeyframesRuleImpl._wrap(domObject);
    case 'WebKitCSSMatrix': return new _CSSMatrixImpl._wrap(domObject);
    case 'CSSMediaRule': return new _CSSMediaRuleImpl._wrap(domObject);
    case 'CSSPageRule': return new _CSSPageRuleImpl._wrap(domObject);
    case 'CSSValue': return new _CSSValueImpl._wrap(domObject);
    case 'CSSPrimitiveValue': return new _CSSPrimitiveValueImpl._wrap(domObject);
    case 'CSSRuleList': return new _CSSRuleListImpl._wrap(domObject);
    case 'CSSStyleDeclaration': return new _CSSStyleDeclarationImpl._wrap(domObject);
    case 'CSSStyleRule': return new _CSSStyleRuleImpl._wrap(domObject);
    case 'StyleSheet': return new _StyleSheetImpl._wrap(domObject);
    case 'CSSStyleSheet': return new _CSSStyleSheetImpl._wrap(domObject);
    case 'CSSValueList': return new _CSSValueListImpl._wrap(domObject);
    case 'WebKitCSSTransformValue': return new _CSSTransformValueImpl._wrap(domObject);
    case 'CSSUnknownRule': return new _CSSUnknownRuleImpl._wrap(domObject);
    case 'HTMLCanvasElement': return new _CanvasElementImpl._wrap(domObject);
    case 'CanvasGradient': return new _CanvasGradientImpl._wrap(domObject);
    case 'CanvasPattern': return new _CanvasPatternImpl._wrap(domObject);
    case 'CanvasRenderingContext': return new _CanvasRenderingContextImpl._wrap(domObject);
    case 'CanvasRenderingContext2D': return new _CanvasRenderingContext2DImpl._wrap(domObject);
    case 'ClientRect': return new _ClientRectImpl._wrap(domObject);
    case 'ClientRectList': return new _ClientRectListImpl._wrap(domObject);
    case 'Clipboard': return new _ClipboardImpl._wrap(domObject);
    case 'CloseEvent': return new _CloseEventImpl._wrap(domObject);
    case 'Comment': return new _CommentImpl._wrap(domObject);
    case 'UIEvent': return new _UIEventImpl._wrap(domObject);
    case 'CompositionEvent': return new _CompositionEventImpl._wrap(domObject);
    case 'Console': return new _ConsoleImpl._wrap(domObject);
    case 'HTMLContentElement': return new _ContentElementImpl._wrap(domObject);
    case 'ConvolverNode': return new _ConvolverNodeImpl._wrap(domObject);
    case 'Coordinates': return new _CoordinatesImpl._wrap(domObject);
    case 'Counter': return new _CounterImpl._wrap(domObject);
    case 'Crypto': return new _CryptoImpl._wrap(domObject);
    case 'CustomEvent': return new _CustomEventImpl._wrap(domObject);
    case 'HTMLDListElement': return new _DListElementImpl._wrap(domObject);
    case 'DOMApplicationCache': return new _DOMApplicationCacheImpl._wrap(domObject);
    case 'DOMException': return new _DOMExceptionImpl._wrap(domObject);
    case 'DOMFileSystem': return new _DOMFileSystemImpl._wrap(domObject);
    case 'DOMFileSystemSync': return new _DOMFileSystemSyncImpl._wrap(domObject);
    case 'DOMFormData': return new _DOMFormDataImpl._wrap(domObject);
    case 'DOMImplementation': return new _DOMImplementationImpl._wrap(domObject);
    case 'DOMMimeType': return new _DOMMimeTypeImpl._wrap(domObject);
    case 'DOMMimeTypeArray': return new _DOMMimeTypeArrayImpl._wrap(domObject);
    case 'DOMParser': return new _DOMParserImpl._wrap(domObject);
    case 'DOMPlugin': return new _DOMPluginImpl._wrap(domObject);
    case 'DOMPluginArray': return new _DOMPluginArrayImpl._wrap(domObject);
    case 'DOMSelection': return new _DOMSelectionImpl._wrap(domObject);
    case 'DOMTokenList': return new _DOMTokenListImpl._wrap(domObject);
    case 'DOMSettableTokenList': return new _DOMSettableTokenListImpl._wrap(domObject);
    case 'DOMStringList': return new _DOMStringListImpl._wrap(domObject);
    case 'DOMStringMap': return new _DOMStringMapImpl._wrap(domObject);
    case 'DOMURL': return new _DOMURLImpl._wrap(domObject);
    case 'DataTransferItem': return new _DataTransferItemImpl._wrap(domObject);
    case 'DataTransferItemList': return new _DataTransferItemListImpl._wrap(domObject);
    case 'DataView': return new _DataViewImpl._wrap(domObject);
    case 'Database': return new _DatabaseImpl._wrap(domObject);
    case 'DatabaseSync': return new _DatabaseSyncImpl._wrap(domObject);
    case 'WorkerContext': return new _WorkerContextImpl._wrap(domObject);
    case 'DedicatedWorkerContext': return new _DedicatedWorkerContextImpl._wrap(domObject);
    case 'DelayNode': return new _DelayNodeImpl._wrap(domObject);
    case 'DeprecatedPeerConnection': return new _DeprecatedPeerConnectionImpl._wrap(domObject);
    case 'HTMLDetailsElement': return new _DetailsElementImpl._wrap(domObject);
    case 'DeviceMotionEvent': return new _DeviceMotionEventImpl._wrap(domObject);
    case 'DeviceOrientationEvent': return new _DeviceOrientationEventImpl._wrap(domObject);
    case 'HTMLDirectoryElement': return new _DirectoryElementImpl._wrap(domObject);
    case 'Entry': return new _EntryImpl._wrap(domObject);
    case 'DirectoryEntry': return new _DirectoryEntryImpl._wrap(domObject);
    case 'EntrySync': return new _EntrySyncImpl._wrap(domObject);
    case 'DirectoryEntrySync': return new _DirectoryEntrySyncImpl._wrap(domObject);
    case 'DirectoryReader': return new _DirectoryReaderImpl._wrap(domObject);
    case 'DirectoryReaderSync': return new _DirectoryReaderSyncImpl._wrap(domObject);
    case 'HTMLDivElement': return new _DivElementImpl._wrap(domObject);
    case 'Document': return new _DocumentImpl._wrap(domObject);
    case 'DocumentFragment': return new _DocumentFragmentImpl._wrap(domObject);
    case 'DocumentType': return new _DocumentTypeImpl._wrap(domObject);
    case 'DynamicsCompressorNode': return new _DynamicsCompressorNodeImpl._wrap(domObject);
    case 'EXTTextureFilterAnisotropic': return new _EXTTextureFilterAnisotropicImpl._wrap(domObject);
    case 'ElementTimeControl': return new _ElementTimeControlImpl._wrap(domObject);
    case 'HTMLEmbedElement': return new _EmbedElementImpl._wrap(domObject);
    case 'Entity': return new _EntityImpl._wrap(domObject);
    case 'EntityReference': return new _EntityReferenceImpl._wrap(domObject);
    case 'EntryArray': return new _EntryArrayImpl._wrap(domObject);
    case 'EntryArraySync': return new _EntryArraySyncImpl._wrap(domObject);
    case 'ErrorEvent': return new _ErrorEventImpl._wrap(domObject);
    case 'EventException': return new _EventExceptionImpl._wrap(domObject);
    case 'EventSource': return new _EventSourceImpl._wrap(domObject);
    case 'HTMLFieldSetElement': return new _FieldSetElementImpl._wrap(domObject);
    case 'File': return new _FileImpl._wrap(domObject);
    case 'FileEntry': return new _FileEntryImpl._wrap(domObject);
    case 'FileEntrySync': return new _FileEntrySyncImpl._wrap(domObject);
    case 'FileError': return new _FileErrorImpl._wrap(domObject);
    case 'FileException': return new _FileExceptionImpl._wrap(domObject);
    case 'FileList': return new _FileListImpl._wrap(domObject);
    case 'FileReader': return new _FileReaderImpl._wrap(domObject);
    case 'FileReaderSync': return new _FileReaderSyncImpl._wrap(domObject);
    case 'FileWriter': return new _FileWriterImpl._wrap(domObject);
    case 'FileWriterSync': return new _FileWriterSyncImpl._wrap(domObject);
    case 'Float32Array': return new _Float32ArrayImpl._wrap(domObject);
    case 'Float64Array': return new _Float64ArrayImpl._wrap(domObject);
    case 'HTMLFontElement': return new _FontElementImpl._wrap(domObject);
    case 'HTMLFormElement': return new _FormElementImpl._wrap(domObject);
    case 'HTMLFrameElement': return new _FrameElementImpl._wrap(domObject);
    case 'HTMLFrameSetElement': return new _FrameSetElementImpl._wrap(domObject);
    case 'Geolocation': return new _GeolocationImpl._wrap(domObject);
    case 'Geoposition': return new _GeopositionImpl._wrap(domObject);
    case 'HTMLHRElement': return new _HRElementImpl._wrap(domObject);
    case 'HTMLAllCollection': return new _HTMLAllCollectionImpl._wrap(domObject);
    case 'HTMLCollection': return new _HTMLCollectionImpl._wrap(domObject);
    case 'HTMLOptionsCollection': return new _HTMLOptionsCollectionImpl._wrap(domObject);
    case 'HashChangeEvent': return new _HashChangeEventImpl._wrap(domObject);
    case 'HTMLHeadElement': return new _HeadElementImpl._wrap(domObject);
    case 'HTMLHeadingElement': return new _HeadingElementImpl._wrap(domObject);
    case 'History': return new _HistoryImpl._wrap(domObject);
    case 'HTMLHtmlElement': return new _HtmlElementImpl._wrap(domObject);
    case 'IDBAny': return new _IDBAnyImpl._wrap(domObject);
    case 'IDBCursor': return new _IDBCursorImpl._wrap(domObject);
    case 'IDBCursorWithValue': return new _IDBCursorWithValueImpl._wrap(domObject);
    case 'IDBDatabase': return new _IDBDatabaseImpl._wrap(domObject);
    case 'IDBDatabaseException': return new _IDBDatabaseExceptionImpl._wrap(domObject);
    case 'IDBFactory': return new _IDBFactoryImpl._wrap(domObject);
    case 'IDBIndex': return new _IDBIndexImpl._wrap(domObject);
    case 'IDBKey': return new _IDBKeyImpl._wrap(domObject);
    case 'IDBKeyRange': return new _IDBKeyRangeImpl._wrap(domObject);
    case 'IDBObjectStore': return new _IDBObjectStoreImpl._wrap(domObject);
    case 'IDBRequest': return new _IDBRequestImpl._wrap(domObject);
    case 'IDBTransaction': return new _IDBTransactionImpl._wrap(domObject);
    case 'IDBVersionChangeEvent': return new _IDBVersionChangeEventImpl._wrap(domObject);
    case 'IDBVersionChangeRequest': return new _IDBVersionChangeRequestImpl._wrap(domObject);
    case 'HTMLIFrameElement': return new _IFrameElementImpl._wrap(domObject);
    case 'IceCandidate': return new _IceCandidateImpl._wrap(domObject);
    case 'ImageData': return new _ImageDataImpl._wrap(domObject);
    case 'HTMLImageElement': return new _ImageElementImpl._wrap(domObject);
    case 'HTMLInputElement': return new _InputElementImpl._wrap(domObject);
    case 'Int16Array': return new _Int16ArrayImpl._wrap(domObject);
    case 'Int32Array': return new _Int32ArrayImpl._wrap(domObject);
    case 'Int8Array': return new _Int8ArrayImpl._wrap(domObject);
    case 'JavaScriptAudioNode': return new _JavaScriptAudioNodeImpl._wrap(domObject);
    case 'JavaScriptCallFrame': return new _JavaScriptCallFrameImpl._wrap(domObject);
    case 'KeyboardEvent': return new _KeyboardEventImpl._wrap(domObject);
    case 'HTMLKeygenElement': return new _KeygenElementImpl._wrap(domObject);
    case 'HTMLLIElement': return new _LIElementImpl._wrap(domObject);
    case 'HTMLLabelElement': return new _LabelElementImpl._wrap(domObject);
    case 'HTMLLegendElement': return new _LegendElementImpl._wrap(domObject);
    case 'HTMLLinkElement': return new _LinkElementImpl._wrap(domObject);
    case 'MediaStream': return new _MediaStreamImpl._wrap(domObject);
    case 'LocalMediaStream': return new _LocalMediaStreamImpl._wrap(domObject);
    case 'Location': return new _LocationImpl._wrap(domObject);
    case 'HTMLMapElement': return new _MapElementImpl._wrap(domObject);
    case 'HTMLMarqueeElement': return new _MarqueeElementImpl._wrap(domObject);
    case 'MediaController': return new _MediaControllerImpl._wrap(domObject);
    case 'MediaElementAudioSourceNode': return new _MediaElementAudioSourceNodeImpl._wrap(domObject);
    case 'MediaError': return new _MediaErrorImpl._wrap(domObject);
    case 'MediaKeyError': return new _MediaKeyErrorImpl._wrap(domObject);
    case 'MediaKeyEvent': return new _MediaKeyEventImpl._wrap(domObject);
    case 'MediaList': return new _MediaListImpl._wrap(domObject);
    case 'MediaQueryList': return new _MediaQueryListImpl._wrap(domObject);
    case 'MediaQueryListListener': return new _MediaQueryListListenerImpl._wrap(domObject);
    case 'MediaStreamEvent': return new _MediaStreamEventImpl._wrap(domObject);
    case 'MediaStreamList': return new _MediaStreamListImpl._wrap(domObject);
    case 'MediaStreamTrack': return new _MediaStreamTrackImpl._wrap(domObject);
    case 'MediaStreamTrackList': return new _MediaStreamTrackListImpl._wrap(domObject);
    case 'MemoryInfo': return new _MemoryInfoImpl._wrap(domObject);
    case 'HTMLMenuElement': return new _MenuElementImpl._wrap(domObject);
    case 'MessageChannel': return new _MessageChannelImpl._wrap(domObject);
    case 'MessageEvent': return new _MessageEventImpl._wrap(domObject);
    case 'MessagePort': return new _MessagePortImpl._wrap(domObject);
    case 'HTMLMetaElement': return new _MetaElementImpl._wrap(domObject);
    case 'Metadata': return new _MetadataImpl._wrap(domObject);
    case 'HTMLMeterElement': return new _MeterElementImpl._wrap(domObject);
    case 'HTMLModElement': return new _ModElementImpl._wrap(domObject);
    case 'MouseEvent': return new _MouseEventImpl._wrap(domObject);
    case 'MutationCallback': return new _MutationCallbackImpl._wrap(domObject);
    case 'MutationEvent': return new _MutationEventImpl._wrap(domObject);
    case 'MutationRecord': return new _MutationRecordImpl._wrap(domObject);
    case 'NamedNodeMap': return new _NamedNodeMapImpl._wrap(domObject);
    case 'Navigator': return new _NavigatorImpl._wrap(domObject);
    case 'NavigatorUserMediaError': return new _NavigatorUserMediaErrorImpl._wrap(domObject);
    case 'NodeFilter': return new _NodeFilterImpl._wrap(domObject);
    case 'NodeIterator': return new _NodeIteratorImpl._wrap(domObject);
    case 'NodeList': return new _NodeListImpl._wrap(domObject);
    case 'Notation': return new _NotationImpl._wrap(domObject);
    case 'Notification': return new _NotificationImpl._wrap(domObject);
    case 'NotificationCenter': return new _NotificationCenterImpl._wrap(domObject);
    case 'OESStandardDerivatives': return new _OESStandardDerivativesImpl._wrap(domObject);
    case 'OESTextureFloat': return new _OESTextureFloatImpl._wrap(domObject);
    case 'OESVertexArrayObject': return new _OESVertexArrayObjectImpl._wrap(domObject);
    case 'HTMLOListElement': return new _OListElementImpl._wrap(domObject);
    case 'HTMLObjectElement': return new _ObjectElementImpl._wrap(domObject);
    case 'OfflineAudioCompletionEvent': return new _OfflineAudioCompletionEventImpl._wrap(domObject);
    case 'OperationNotAllowedException': return new _OperationNotAllowedExceptionImpl._wrap(domObject);
    case 'HTMLOptGroupElement': return new _OptGroupElementImpl._wrap(domObject);
    case 'HTMLOptionElement': return new _OptionElementImpl._wrap(domObject);
    case 'Oscillator': return new _OscillatorImpl._wrap(domObject);
    case 'HTMLOutputElement': return new _OutputElementImpl._wrap(domObject);
    case 'OverflowEvent': return new _OverflowEventImpl._wrap(domObject);
    case 'PageTransitionEvent': return new _PageTransitionEventImpl._wrap(domObject);
    case 'HTMLParagraphElement': return new _ParagraphElementImpl._wrap(domObject);
    case 'HTMLParamElement': return new _ParamElementImpl._wrap(domObject);
    case 'PeerConnection00': return new _PeerConnection00Impl._wrap(domObject);
    case 'Performance': return new _PerformanceImpl._wrap(domObject);
    case 'PerformanceNavigation': return new _PerformanceNavigationImpl._wrap(domObject);
    case 'PerformanceTiming': return new _PerformanceTimingImpl._wrap(domObject);
    case 'WebKitPoint': return new _PointImpl._wrap(domObject);
    case 'PointerLock': return new _PointerLockImpl._wrap(domObject);
    case 'PopStateEvent': return new _PopStateEventImpl._wrap(domObject);
    case 'PositionError': return new _PositionErrorImpl._wrap(domObject);
    case 'HTMLPreElement': return new _PreElementImpl._wrap(domObject);
    case 'ProcessingInstruction': return new _ProcessingInstructionImpl._wrap(domObject);
    case 'HTMLProgressElement': return new _ProgressElementImpl._wrap(domObject);
    case 'ProgressEvent': return new _ProgressEventImpl._wrap(domObject);
    case 'HTMLQuoteElement': return new _QuoteElementImpl._wrap(domObject);
    case 'RGBColor': return new _RGBColorImpl._wrap(domObject);
    case 'RadioNodeList': return new _RadioNodeListImpl._wrap(domObject);
    case 'Range': return new _RangeImpl._wrap(domObject);
    case 'RangeException': return new _RangeExceptionImpl._wrap(domObject);
    case 'RealtimeAnalyserNode': return new _RealtimeAnalyserNodeImpl._wrap(domObject);
    case 'Rect': return new _RectImpl._wrap(domObject);
    case 'SQLError': return new _SQLErrorImpl._wrap(domObject);
    case 'SQLException': return new _SQLExceptionImpl._wrap(domObject);
    case 'SQLResultSet': return new _SQLResultSetImpl._wrap(domObject);
    case 'SQLResultSetRowList': return new _SQLResultSetRowListImpl._wrap(domObject);
    case 'SQLTransaction': return new _SQLTransactionImpl._wrap(domObject);
    case 'SQLTransactionSync': return new _SQLTransactionSyncImpl._wrap(domObject);
    case 'SVGElement': return new _SVGElementImpl._wrap(domObject);
    case 'SVGURIReference': return new _SVGURIReferenceImpl._wrap(domObject);
    case 'SVGTests': return new _SVGTestsImpl._wrap(domObject);
    case 'SVGLangSpace': return new _SVGLangSpaceImpl._wrap(domObject);
    case 'SVGExternalResourcesRequired': return new _SVGExternalResourcesRequiredImpl._wrap(domObject);
    case 'SVGStylable': return new _SVGStylableImpl._wrap(domObject);
    case 'SVGLocatable': return new _SVGLocatableImpl._wrap(domObject);
    case 'SVGTransformable': return new _SVGTransformableImpl._wrap(domObject);
    case 'SVGAElement': return new _SVGAElementImpl._wrap(domObject);
    case 'SVGAltGlyphDefElement': return new _SVGAltGlyphDefElementImpl._wrap(domObject);
    case 'SVGTextContentElement': return new _SVGTextContentElementImpl._wrap(domObject);
    case 'SVGTextPositioningElement': return new _SVGTextPositioningElementImpl._wrap(domObject);
    case 'SVGAltGlyphElement': return new _SVGAltGlyphElementImpl._wrap(domObject);
    case 'SVGAltGlyphItemElement': return new _SVGAltGlyphItemElementImpl._wrap(domObject);
    case 'SVGAngle': return new _SVGAngleImpl._wrap(domObject);
    case 'SVGAnimationElement': return new _SVGAnimationElementImpl._wrap(domObject);
    case 'SVGAnimateColorElement': return new _SVGAnimateColorElementImpl._wrap(domObject);
    case 'SVGAnimateElement': return new _SVGAnimateElementImpl._wrap(domObject);
    case 'SVGAnimateMotionElement': return new _SVGAnimateMotionElementImpl._wrap(domObject);
    case 'SVGAnimateTransformElement': return new _SVGAnimateTransformElementImpl._wrap(domObject);
    case 'SVGAnimatedAngle': return new _SVGAnimatedAngleImpl._wrap(domObject);
    case 'SVGAnimatedBoolean': return new _SVGAnimatedBooleanImpl._wrap(domObject);
    case 'SVGAnimatedEnumeration': return new _SVGAnimatedEnumerationImpl._wrap(domObject);
    case 'SVGAnimatedInteger': return new _SVGAnimatedIntegerImpl._wrap(domObject);
    case 'SVGAnimatedLength': return new _SVGAnimatedLengthImpl._wrap(domObject);
    case 'SVGAnimatedLengthList': return new _SVGAnimatedLengthListImpl._wrap(domObject);
    case 'SVGAnimatedNumber': return new _SVGAnimatedNumberImpl._wrap(domObject);
    case 'SVGAnimatedNumberList': return new _SVGAnimatedNumberListImpl._wrap(domObject);
    case 'SVGAnimatedPreserveAspectRatio': return new _SVGAnimatedPreserveAspectRatioImpl._wrap(domObject);
    case 'SVGAnimatedRect': return new _SVGAnimatedRectImpl._wrap(domObject);
    case 'SVGAnimatedString': return new _SVGAnimatedStringImpl._wrap(domObject);
    case 'SVGAnimatedTransformList': return new _SVGAnimatedTransformListImpl._wrap(domObject);
    case 'SVGCircleElement': return new _SVGCircleElementImpl._wrap(domObject);
    case 'SVGClipPathElement': return new _SVGClipPathElementImpl._wrap(domObject);
    case 'SVGColor': return new _SVGColorImpl._wrap(domObject);
    case 'SVGComponentTransferFunctionElement': return new _SVGComponentTransferFunctionElementImpl._wrap(domObject);
    case 'SVGCursorElement': return new _SVGCursorElementImpl._wrap(domObject);
    case 'SVGDefsElement': return new _SVGDefsElementImpl._wrap(domObject);
    case 'SVGDescElement': return new _SVGDescElementImpl._wrap(domObject);
    case 'SVGDocument': return new _SVGDocumentImpl._wrap(domObject);
    case 'SVGElementInstance': return new _SVGElementInstanceImpl._wrap(domObject);
    case 'SVGElementInstanceList': return new _SVGElementInstanceListImpl._wrap(domObject);
    case 'SVGEllipseElement': return new _SVGEllipseElementImpl._wrap(domObject);
    case 'SVGException': return new _SVGExceptionImpl._wrap(domObject);
    case 'SVGFilterPrimitiveStandardAttributes': return new _SVGFilterPrimitiveStandardAttributesImpl._wrap(domObject);
    case 'SVGFEBlendElement': return new _SVGFEBlendElementImpl._wrap(domObject);
    case 'SVGFEColorMatrixElement': return new _SVGFEColorMatrixElementImpl._wrap(domObject);
    case 'SVGFEComponentTransferElement': return new _SVGFEComponentTransferElementImpl._wrap(domObject);
    case 'SVGFECompositeElement': return new _SVGFECompositeElementImpl._wrap(domObject);
    case 'SVGFEConvolveMatrixElement': return new _SVGFEConvolveMatrixElementImpl._wrap(domObject);
    case 'SVGFEDiffuseLightingElement': return new _SVGFEDiffuseLightingElementImpl._wrap(domObject);
    case 'SVGFEDisplacementMapElement': return new _SVGFEDisplacementMapElementImpl._wrap(domObject);
    case 'SVGFEDistantLightElement': return new _SVGFEDistantLightElementImpl._wrap(domObject);
    case 'SVGFEDropShadowElement': return new _SVGFEDropShadowElementImpl._wrap(domObject);
    case 'SVGFEFloodElement': return new _SVGFEFloodElementImpl._wrap(domObject);
    case 'SVGFEFuncAElement': return new _SVGFEFuncAElementImpl._wrap(domObject);
    case 'SVGFEFuncBElement': return new _SVGFEFuncBElementImpl._wrap(domObject);
    case 'SVGFEFuncGElement': return new _SVGFEFuncGElementImpl._wrap(domObject);
    case 'SVGFEFuncRElement': return new _SVGFEFuncRElementImpl._wrap(domObject);
    case 'SVGFEGaussianBlurElement': return new _SVGFEGaussianBlurElementImpl._wrap(domObject);
    case 'SVGFEImageElement': return new _SVGFEImageElementImpl._wrap(domObject);
    case 'SVGFEMergeElement': return new _SVGFEMergeElementImpl._wrap(domObject);
    case 'SVGFEMergeNodeElement': return new _SVGFEMergeNodeElementImpl._wrap(domObject);
    case 'SVGFEMorphologyElement': return new _SVGFEMorphologyElementImpl._wrap(domObject);
    case 'SVGFEOffsetElement': return new _SVGFEOffsetElementImpl._wrap(domObject);
    case 'SVGFEPointLightElement': return new _SVGFEPointLightElementImpl._wrap(domObject);
    case 'SVGFESpecularLightingElement': return new _SVGFESpecularLightingElementImpl._wrap(domObject);
    case 'SVGFESpotLightElement': return new _SVGFESpotLightElementImpl._wrap(domObject);
    case 'SVGFETileElement': return new _SVGFETileElementImpl._wrap(domObject);
    case 'SVGFETurbulenceElement': return new _SVGFETurbulenceElementImpl._wrap(domObject);
    case 'SVGFilterElement': return new _SVGFilterElementImpl._wrap(domObject);
    case 'SVGFitToViewBox': return new _SVGFitToViewBoxImpl._wrap(domObject);
    case 'SVGFontElement': return new _SVGFontElementImpl._wrap(domObject);
    case 'SVGFontFaceElement': return new _SVGFontFaceElementImpl._wrap(domObject);
    case 'SVGFontFaceFormatElement': return new _SVGFontFaceFormatElementImpl._wrap(domObject);
    case 'SVGFontFaceNameElement': return new _SVGFontFaceNameElementImpl._wrap(domObject);
    case 'SVGFontFaceSrcElement': return new _SVGFontFaceSrcElementImpl._wrap(domObject);
    case 'SVGFontFaceUriElement': return new _SVGFontFaceUriElementImpl._wrap(domObject);
    case 'SVGForeignObjectElement': return new _SVGForeignObjectElementImpl._wrap(domObject);
    case 'SVGGElement': return new _SVGGElementImpl._wrap(domObject);
    case 'SVGGlyphElement': return new _SVGGlyphElementImpl._wrap(domObject);
    case 'SVGGlyphRefElement': return new _SVGGlyphRefElementImpl._wrap(domObject);
    case 'SVGGradientElement': return new _SVGGradientElementImpl._wrap(domObject);
    case 'SVGHKernElement': return new _SVGHKernElementImpl._wrap(domObject);
    case 'SVGImageElement': return new _SVGImageElementImpl._wrap(domObject);
    case 'SVGLength': return new _SVGLengthImpl._wrap(domObject);
    case 'SVGLengthList': return new _SVGLengthListImpl._wrap(domObject);
    case 'SVGLineElement': return new _SVGLineElementImpl._wrap(domObject);
    case 'SVGLinearGradientElement': return new _SVGLinearGradientElementImpl._wrap(domObject);
    case 'SVGMPathElement': return new _SVGMPathElementImpl._wrap(domObject);
    case 'SVGMarkerElement': return new _SVGMarkerElementImpl._wrap(domObject);
    case 'SVGMaskElement': return new _SVGMaskElementImpl._wrap(domObject);
    case 'SVGMatrix': return new _SVGMatrixImpl._wrap(domObject);
    case 'SVGMetadataElement': return new _SVGMetadataElementImpl._wrap(domObject);
    case 'SVGMissingGlyphElement': return new _SVGMissingGlyphElementImpl._wrap(domObject);
    case 'SVGNumber': return new _SVGNumberImpl._wrap(domObject);
    case 'SVGNumberList': return new _SVGNumberListImpl._wrap(domObject);
    case 'SVGPaint': return new _SVGPaintImpl._wrap(domObject);
    case 'SVGPathElement': return new _SVGPathElementImpl._wrap(domObject);
    case 'SVGPathSeg': return new _SVGPathSegImpl._wrap(domObject);
    case 'SVGPathSegArcAbs': return new _SVGPathSegArcAbsImpl._wrap(domObject);
    case 'SVGPathSegArcRel': return new _SVGPathSegArcRelImpl._wrap(domObject);
    case 'SVGPathSegClosePath': return new _SVGPathSegClosePathImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicAbs': return new _SVGPathSegCurvetoCubicAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicRel': return new _SVGPathSegCurvetoCubicRelImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicSmoothAbs': return new _SVGPathSegCurvetoCubicSmoothAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicSmoothRel': return new _SVGPathSegCurvetoCubicSmoothRelImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticAbs': return new _SVGPathSegCurvetoQuadraticAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticRel': return new _SVGPathSegCurvetoQuadraticRelImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticSmoothAbs': return new _SVGPathSegCurvetoQuadraticSmoothAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticSmoothRel': return new _SVGPathSegCurvetoQuadraticSmoothRelImpl._wrap(domObject);
    case 'SVGPathSegLinetoAbs': return new _SVGPathSegLinetoAbsImpl._wrap(domObject);
    case 'SVGPathSegLinetoHorizontalAbs': return new _SVGPathSegLinetoHorizontalAbsImpl._wrap(domObject);
    case 'SVGPathSegLinetoHorizontalRel': return new _SVGPathSegLinetoHorizontalRelImpl._wrap(domObject);
    case 'SVGPathSegLinetoRel': return new _SVGPathSegLinetoRelImpl._wrap(domObject);
    case 'SVGPathSegLinetoVerticalAbs': return new _SVGPathSegLinetoVerticalAbsImpl._wrap(domObject);
    case 'SVGPathSegLinetoVerticalRel': return new _SVGPathSegLinetoVerticalRelImpl._wrap(domObject);
    case 'SVGPathSegList': return new _SVGPathSegListImpl._wrap(domObject);
    case 'SVGPathSegMovetoAbs': return new _SVGPathSegMovetoAbsImpl._wrap(domObject);
    case 'SVGPathSegMovetoRel': return new _SVGPathSegMovetoRelImpl._wrap(domObject);
    case 'SVGPatternElement': return new _SVGPatternElementImpl._wrap(domObject);
    case 'SVGPoint': return new _SVGPointImpl._wrap(domObject);
    case 'SVGPointList': return new _SVGPointListImpl._wrap(domObject);
    case 'SVGPolygonElement': return new _SVGPolygonElementImpl._wrap(domObject);
    case 'SVGPolylineElement': return new _SVGPolylineElementImpl._wrap(domObject);
    case 'SVGPreserveAspectRatio': return new _SVGPreserveAspectRatioImpl._wrap(domObject);
    case 'SVGRadialGradientElement': return new _SVGRadialGradientElementImpl._wrap(domObject);
    case 'SVGRect': return new _SVGRectImpl._wrap(domObject);
    case 'SVGRectElement': return new _SVGRectElementImpl._wrap(domObject);
    case 'SVGRenderingIntent': return new _SVGRenderingIntentImpl._wrap(domObject);
    case 'SVGZoomAndPan': return new _SVGZoomAndPanImpl._wrap(domObject);
    case 'SVGSVGElement': return new _SVGSVGElementImpl._wrap(domObject);
    case 'SVGScriptElement': return new _SVGScriptElementImpl._wrap(domObject);
    case 'SVGSetElement': return new _SVGSetElementImpl._wrap(domObject);
    case 'SVGStopElement': return new _SVGStopElementImpl._wrap(domObject);
    case 'SVGStringList': return new _SVGStringListImpl._wrap(domObject);
    case 'SVGStyleElement': return new _SVGStyleElementImpl._wrap(domObject);
    case 'SVGSwitchElement': return new _SVGSwitchElementImpl._wrap(domObject);
    case 'SVGSymbolElement': return new _SVGSymbolElementImpl._wrap(domObject);
    case 'SVGTRefElement': return new _SVGTRefElementImpl._wrap(domObject);
    case 'SVGTSpanElement': return new _SVGTSpanElementImpl._wrap(domObject);
    case 'SVGTextElement': return new _SVGTextElementImpl._wrap(domObject);
    case 'SVGTextPathElement': return new _SVGTextPathElementImpl._wrap(domObject);
    case 'SVGTitleElement': return new _SVGTitleElementImpl._wrap(domObject);
    case 'SVGTransform': return new _SVGTransformImpl._wrap(domObject);
    case 'SVGTransformList': return new _SVGTransformListImpl._wrap(domObject);
    case 'SVGUnitTypes': return new _SVGUnitTypesImpl._wrap(domObject);
    case 'SVGUseElement': return new _SVGUseElementImpl._wrap(domObject);
    case 'SVGVKernElement': return new _SVGVKernElementImpl._wrap(domObject);
    case 'SVGViewElement': return new _SVGViewElementImpl._wrap(domObject);
    case 'SVGViewSpec': return new _SVGViewSpecImpl._wrap(domObject);
    case 'SVGZoomEvent': return new _SVGZoomEventImpl._wrap(domObject);
    case 'Screen': return new _ScreenImpl._wrap(domObject);
    case 'HTMLScriptElement': return new _ScriptElementImpl._wrap(domObject);
    case 'ScriptProfile': return new _ScriptProfileImpl._wrap(domObject);
    case 'ScriptProfileNode': return new _ScriptProfileNodeImpl._wrap(domObject);
    case 'HTMLSelectElement': return new _SelectElementImpl._wrap(domObject);
    case 'SessionDescription': return new _SessionDescriptionImpl._wrap(domObject);
    case 'HTMLShadowElement': return new _ShadowElementImpl._wrap(domObject);
    case 'ShadowRoot': return new _ShadowRootImpl._wrap(domObject);
    case 'SharedWorker': return new _SharedWorkerImpl._wrap(domObject);
    case 'SharedWorkerContext': return new _SharedWorkerContextImpl._wrap(domObject);
    case 'HTMLSourceElement': return new _SourceElementImpl._wrap(domObject);
    case 'HTMLSpanElement': return new _SpanElementImpl._wrap(domObject);
    case 'SpeechGrammar': return new _SpeechGrammarImpl._wrap(domObject);
    case 'SpeechGrammarList': return new _SpeechGrammarListImpl._wrap(domObject);
    case 'SpeechInputEvent': return new _SpeechInputEventImpl._wrap(domObject);
    case 'SpeechInputResult': return new _SpeechInputResultImpl._wrap(domObject);
    case 'SpeechInputResultList': return new _SpeechInputResultListImpl._wrap(domObject);
    case 'SpeechRecognition': return new _SpeechRecognitionImpl._wrap(domObject);
    case 'SpeechRecognitionAlternative': return new _SpeechRecognitionAlternativeImpl._wrap(domObject);
    case 'SpeechRecognitionError': return new _SpeechRecognitionErrorImpl._wrap(domObject);
    case 'SpeechRecognitionEvent': return new _SpeechRecognitionEventImpl._wrap(domObject);
    case 'SpeechRecognitionResult': return new _SpeechRecognitionResultImpl._wrap(domObject);
    case 'SpeechRecognitionResultList': return new _SpeechRecognitionResultListImpl._wrap(domObject);
    case 'Storage': return new _StorageImpl._wrap(domObject);
    case 'StorageEvent': return new _StorageEventImpl._wrap(domObject);
    case 'StorageInfo': return new _StorageInfoImpl._wrap(domObject);
    case 'HTMLStyleElement': return new _StyleElementImpl._wrap(domObject);
    case 'StyleMedia': return new _StyleMediaImpl._wrap(domObject);
    case 'StyleSheetList': return new _StyleSheetListImpl._wrap(domObject);
    case 'HTMLTableCaptionElement': return new _TableCaptionElementImpl._wrap(domObject);
    case 'HTMLTableCellElement': return new _TableCellElementImpl._wrap(domObject);
    case 'HTMLTableColElement': return new _TableColElementImpl._wrap(domObject);
    case 'HTMLTableElement': return new _TableElementImpl._wrap(domObject);
    case 'HTMLTableRowElement': return new _TableRowElementImpl._wrap(domObject);
    case 'HTMLTableSectionElement': return new _TableSectionElementImpl._wrap(domObject);
    case 'HTMLTextAreaElement': return new _TextAreaElementImpl._wrap(domObject);
    case 'TextEvent': return new _TextEventImpl._wrap(domObject);
    case 'TextMetrics': return new _TextMetricsImpl._wrap(domObject);
    case 'TextTrack': return new _TextTrackImpl._wrap(domObject);
    case 'TextTrackCue': return new _TextTrackCueImpl._wrap(domObject);
    case 'TextTrackCueList': return new _TextTrackCueListImpl._wrap(domObject);
    case 'TextTrackList': return new _TextTrackListImpl._wrap(domObject);
    case 'TimeRanges': return new _TimeRangesImpl._wrap(domObject);
    case 'HTMLTitleElement': return new _TitleElementImpl._wrap(domObject);
    case 'Touch': return new _TouchImpl._wrap(domObject);
    case 'TouchEvent': return new _TouchEventImpl._wrap(domObject);
    case 'TouchList': return new _TouchListImpl._wrap(domObject);
    case 'HTMLTrackElement': return new _TrackElementImpl._wrap(domObject);
    case 'TrackEvent': return new _TrackEventImpl._wrap(domObject);
    case 'WebKitTransitionEvent': return new _TransitionEventImpl._wrap(domObject);
    case 'TreeWalker': return new _TreeWalkerImpl._wrap(domObject);
    case 'HTMLUListElement': return new _UListElementImpl._wrap(domObject);
    case 'Uint16Array': return new _Uint16ArrayImpl._wrap(domObject);
    case 'Uint32Array': return new _Uint32ArrayImpl._wrap(domObject);
    case 'Uint8Array': return new _Uint8ArrayImpl._wrap(domObject);
    case 'Uint8ClampedArray': return new _Uint8ClampedArrayImpl._wrap(domObject);
    case 'HTMLUnknownElement': return new _UnknownElementImpl._wrap(domObject);
    case 'ValidityState': return new _ValidityStateImpl._wrap(domObject);
    case 'HTMLVideoElement': return new _VideoElementImpl._wrap(domObject);
    case 'WaveShaperNode': return new _WaveShaperNodeImpl._wrap(domObject);
    case 'WaveTable': return new _WaveTableImpl._wrap(domObject);
    case 'WebGLActiveInfo': return new _WebGLActiveInfoImpl._wrap(domObject);
    case 'WebGLBuffer': return new _WebGLBufferImpl._wrap(domObject);
    case 'WebGLCompressedTextureS3TC': return new _WebGLCompressedTextureS3TCImpl._wrap(domObject);
    case 'WebGLContextAttributes': return new _WebGLContextAttributesImpl._wrap(domObject);
    case 'WebGLContextEvent': return new _WebGLContextEventImpl._wrap(domObject);
    case 'WebGLDebugRendererInfo': return new _WebGLDebugRendererInfoImpl._wrap(domObject);
    case 'WebGLDebugShaders': return new _WebGLDebugShadersImpl._wrap(domObject);
    case 'WebGLFramebuffer': return new _WebGLFramebufferImpl._wrap(domObject);
    case 'WebGLLoseContext': return new _WebGLLoseContextImpl._wrap(domObject);
    case 'WebGLProgram': return new _WebGLProgramImpl._wrap(domObject);
    case 'WebGLRenderbuffer': return new _WebGLRenderbufferImpl._wrap(domObject);
    case 'WebGLRenderingContext': return new _WebGLRenderingContextImpl._wrap(domObject);
    case 'WebGLShader': return new _WebGLShaderImpl._wrap(domObject);
    case 'WebGLShaderPrecisionFormat': return new _WebGLShaderPrecisionFormatImpl._wrap(domObject);
    case 'WebGLTexture': return new _WebGLTextureImpl._wrap(domObject);
    case 'WebGLUniformLocation': return new _WebGLUniformLocationImpl._wrap(domObject);
    case 'WebGLVertexArrayObjectOES': return new _WebGLVertexArrayObjectOESImpl._wrap(domObject);
    case 'WebKitCSSFilterValue': return new _WebKitCSSFilterValueImpl._wrap(domObject);
    case 'WebKitCSSRegionRule': return new _WebKitCSSRegionRuleImpl._wrap(domObject);
    case 'WebKitMutationObserver': return new _WebKitMutationObserverImpl._wrap(domObject);
    case 'WebKitNamedFlow': return new _WebKitNamedFlowImpl._wrap(domObject);
    case 'WebSocket': return new _WebSocketImpl._wrap(domObject);
    case 'WheelEvent': return new _WheelEventImpl._wrap(domObject);
    case 'DOMWindow': return new _WindowImpl._wrap(domObject);
    case 'Worker': return new _WorkerImpl._wrap(domObject);
    case 'WorkerLocation': return new _WorkerLocationImpl._wrap(domObject);
    case 'WorkerNavigator': return new _WorkerNavigatorImpl._wrap(domObject);
    case 'XMLHttpRequest': return new _XMLHttpRequestImpl._wrap(domObject);
    case 'XMLHttpRequestException': return new _XMLHttpRequestExceptionImpl._wrap(domObject);
    case 'XMLHttpRequestProgressEvent': return new _XMLHttpRequestProgressEventImpl._wrap(domObject);
    case 'XMLHttpRequestUpload': return new _XMLHttpRequestUploadImpl._wrap(domObject);
    case 'XMLSerializer': return new _XMLSerializerImpl._wrap(domObject);
    case 'XPathEvaluator': return new _XPathEvaluatorImpl._wrap(domObject);
    case 'XPathException': return new _XPathExceptionImpl._wrap(domObject);
    case 'XPathExpression': return new _XPathExpressionImpl._wrap(domObject);
    case 'XPathNSResolver': return new _XPathNSResolverImpl._wrap(domObject);
    case 'XPathResult': return new _XPathResultImpl._wrap(domObject);
    case 'XSLTProcessor': return new _XSLTProcessorImpl._wrap(domObject);
    case 'HTMLDocument':
      return new _DocumentImpl._wrap(domObject);
    default:
      throw 'Unrecognized object $domObject. Name=${domObject.typeName}';
  }
}

class _AbstractWorkerEventsImpl extends _EventsImpl implements AbstractWorkerEvents {
  _AbstractWorkerEventsImpl(_ptr) : super(_ptr);
  EventListenerList get error() => _get('error');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AbstractWorkerDOMImpl extends _DOMWrapperBase implements AbstractWorker {
  _AbstractWorkerDOMImpl();
  String get typeName() => "AbstractWorker";
  _EventsImpl _on;

  _AbstractWorkerEventsImpl get on() {
    if (_on === null) _on = new _AbstractWorkerEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "AbstractWorker_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "AbstractWorker_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "AbstractWorker_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ArrayBufferDOMImpl extends _DOMWrapperBase implements ArrayBuffer {
  _ArrayBufferDOMImpl();
  String get typeName() => "ArrayBuffer";

  int get byteLength() native "ArrayBuffer_byteLength_Getter";

  ArrayBuffer slice(int begin, [int end = null]) {
    //
    // slice(int begin)
    // slice(int begin, [Optional] int end)
    //
    // -- reduced:
    // slice(int begin, [Optional] int end)
    //
    return _slice(begin, end);
  }

  ArrayBuffer _slice(begin, end) native "ArrayBuffer_slice_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ArrayBufferViewDOMImpl extends _DOMWrapperBase implements ArrayBufferView {
  _ArrayBufferViewDOMImpl();
  String get typeName() => "ArrayBufferView";

  ArrayBuffer get buffer() native "ArrayBufferView_buffer_Getter";

  int get byteLength() native "ArrayBufferView_byteLength_Getter";

  int get byteOffset() native "ArrayBufferView_byteOffset_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AttrDOMImpl extends _NodeDOMImpl implements Attr {
  _AttrDOMImpl();
  String get typeName() => "Attr";

  bool get isId() native "Attr_isId_Getter";

  String get name() native "Attr_name_Getter";

  Element get ownerElement() native "Attr_ownerElement_Getter";

  bool get specified() native "Attr_specified_Getter";

  String get value() native "Attr_value_Getter";

  void set value(String) native "Attr_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioBufferDOMImpl extends _DOMWrapperBase implements AudioBuffer {
  _AudioBufferDOMImpl();
  String get typeName() => "AudioBuffer";

  num get duration() native "AudioBuffer_duration_Getter";

  num get gain() native "AudioBuffer_gain_Getter";

  void set gain(num) native "AudioBuffer_gain_Setter";

  int get length() native "AudioBuffer_length_Getter";

  int get numberOfChannels() native "AudioBuffer_numberOfChannels_Getter";

  num get sampleRate() native "AudioBuffer_sampleRate_Getter";

  Float32Array getChannelData(int channelIndex) {
    return _getChannelData(channelIndex);
  }

  Float32Array _getChannelData(channelIndex) native "AudioBuffer_getChannelData_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioBufferSourceNodeDOMImpl extends _AudioSourceNodeDOMImpl implements AudioBufferSourceNode {
  _AudioBufferSourceNodeDOMImpl();
  String get typeName() => "AudioBufferSourceNode";

  AudioBuffer get buffer() native "AudioBufferSourceNode_buffer_Getter";

  void set buffer(AudioBuffer) native "AudioBufferSourceNode_buffer_Setter";

  AudioGain get gain() native "AudioBufferSourceNode_gain_Getter";

  bool get loop() native "AudioBufferSourceNode_loop_Getter";

  void set loop(bool) native "AudioBufferSourceNode_loop_Setter";

  bool get looping() native "AudioBufferSourceNode_looping_Getter";

  void set looping(bool) native "AudioBufferSourceNode_looping_Setter";

  AudioParam get playbackRate() native "AudioBufferSourceNode_playbackRate_Getter";

  int get playbackState() native "AudioBufferSourceNode_playbackState_Getter";

  void noteGrainOn(num when, num grainOffset, num grainDuration) {
    _noteGrainOn(when, grainOffset, grainDuration);
    return;
  }

  void _noteGrainOn(when, grainOffset, grainDuration) native "AudioBufferSourceNode_noteGrainOn_Callback";

  void noteOff(num when) {
    _noteOff(when);
    return;
  }

  void _noteOff(when) native "AudioBufferSourceNode_noteOff_Callback";

  void noteOn(num when) {
    _noteOn(when);
    return;
  }

  void _noteOn(when) native "AudioBufferSourceNode_noteOn_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioChannelMergerDOMImpl extends _AudioNodeDOMImpl implements AudioChannelMerger {
  _AudioChannelMergerDOMImpl();
  String get typeName() => "AudioChannelMerger";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioChannelSplitterDOMImpl extends _AudioNodeDOMImpl implements AudioChannelSplitter {
  _AudioChannelSplitterDOMImpl();
  String get typeName() => "AudioChannelSplitter";

}

class _AudioContextEventsImpl extends _EventsImpl implements AudioContextEvents {
  _AudioContextEventsImpl(_ptr) : super(_ptr);
  EventListenerList get complete() => _get('complete');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioContextDOMImpl extends _EventTargetDOMImpl implements AudioContext {
  _AudioContextDOMImpl();
  String get typeName() => "AudioContext";
  _EventsImpl _on;

  _AudioContextEventsImpl get on() {
    if (_on === null) _on = new _AudioContextEventsImpl(this);
    return _on;
  }

  int get activeSourceCount() native "AudioContext_activeSourceCount_Getter";

  num get currentTime() native "AudioContext_currentTime_Getter";

  AudioDestinationNode get destination() native "AudioContext_destination_Getter";

  AudioListener get listener() native "AudioContext_listener_Getter";

  num get sampleRate() native "AudioContext_sampleRate_Getter";

  RealtimeAnalyserNode createAnalyser() {
    return _createAnalyser();
  }

  RealtimeAnalyserNode _createAnalyser() native "AudioContext_createAnalyser_Callback";

  BiquadFilterNode createBiquadFilter() {
    return _createBiquadFilter();
  }

  BiquadFilterNode _createBiquadFilter() native "AudioContext_createBiquadFilter_Callback";

  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate = null]) {
    //
    // createBuffer(int numberOfChannels, int numberOfFrames, num sampleRate)
    // createBuffer(ArrayBuffer buffer, bool mixToMono)
    //
    if ((buffer_OR_numberOfChannels === null || buffer_OR_numberOfChannels is int) &&
        (mixToMono_OR_numberOfFrames === null || mixToMono_OR_numberOfFrames is int)) {
      return _createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, sampleRate);
    }
    if ((buffer_OR_numberOfChannels === null || buffer_OR_numberOfChannels is ArrayBuffer) &&
        (mixToMono_OR_numberOfFrames === null || mixToMono_OR_numberOfFrames is bool) &&
        sampleRate === null) {
      return _createBuffer_2(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames);
    }
    throw "Incorrect number or type of arguments";
  }

  AudioBuffer _createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, sampleRate) native "AudioContext_createBuffer_Callback";

  AudioBuffer _createBuffer_2(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames) native "AudioContext_createBuffer_2_Callback";

  AudioBufferSourceNode createBufferSource() {
    return _createBufferSource();
  }

  AudioBufferSourceNode _createBufferSource() native "AudioContext_createBufferSource_Callback";

  AudioChannelMerger createChannelMerger([int numberOfInputs = null]) {
    //
    // createChannelMerger()
    // createChannelMerger([Optional] int numberOfInputs)
    //
    // -- reduced:
    // createChannelMerger([Optional] int numberOfInputs)
    //
    return _createChannelMerger(numberOfInputs);
  }

  AudioChannelMerger _createChannelMerger(numberOfInputs) native "AudioContext_createChannelMerger_Callback";

  AudioChannelSplitter createChannelSplitter([int numberOfOutputs = null]) {
    //
    // createChannelSplitter()
    // createChannelSplitter([Optional] int numberOfOutputs)
    //
    // -- reduced:
    // createChannelSplitter([Optional] int numberOfOutputs)
    //
    return _createChannelSplitter(numberOfOutputs);
  }

  AudioChannelSplitter _createChannelSplitter(numberOfOutputs) native "AudioContext_createChannelSplitter_Callback";

  ConvolverNode createConvolver() {
    return _createConvolver();
  }

  ConvolverNode _createConvolver() native "AudioContext_createConvolver_Callback";

  DelayNode createDelayNode([num maxDelayTime = null]) {
    //
    // createDelayNode()
    // createDelayNode([Optional] num maxDelayTime)
    //
    // -- reduced:
    // createDelayNode([Optional] num maxDelayTime)
    //
    return _createDelayNode(maxDelayTime);
  }

  DelayNode _createDelayNode(maxDelayTime) native "AudioContext_createDelayNode_Callback";

  DynamicsCompressorNode createDynamicsCompressor() {
    return _createDynamicsCompressor();
  }

  DynamicsCompressorNode _createDynamicsCompressor() native "AudioContext_createDynamicsCompressor_Callback";

  AudioGainNode createGainNode() {
    return _createGainNode();
  }

  AudioGainNode _createGainNode() native "AudioContext_createGainNode_Callback";

  JavaScriptAudioNode createJavaScriptNode(int bufferSize, [int numberOfInputChannels = null, int numberOfOutputChannels = null]) {
    //
    // createJavaScriptNode(int bufferSize)
    // createJavaScriptNode(int bufferSize, [Optional] int numberOfInputChannels)
    // createJavaScriptNode(int bufferSize, [Optional] int numberOfInputChannels, [Optional] int numberOfOutputChannels)
    //
    // -- reduced:
    // createJavaScriptNode(int bufferSize, [Optional] int numberOfInputChannels, [Optional] int numberOfOutputChannels)
    //
    return _createJavaScriptNode(bufferSize, numberOfInputChannels, numberOfOutputChannels);
  }

  JavaScriptAudioNode _createJavaScriptNode(bufferSize, numberOfInputChannels, numberOfOutputChannels) native "AudioContext_createJavaScriptNode_Callback";

  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement) {
    if ((mediaElement === null || mediaElement is MediaElement)) {
      return _createMediaElementSource(mediaElement);
    }
    throw "Incorrect number or type of arguments";
  }

  MediaElementAudioSourceNode _createMediaElementSource(mediaElement) native "AudioContext_createMediaElementSource_Callback";

  Oscillator createOscillator() {
    return _createOscillator();
  }

  Oscillator _createOscillator() native "AudioContext_createOscillator_Callback";

  AudioPannerNode createPanner() {
    return _createPanner();
  }

  AudioPannerNode _createPanner() native "AudioContext_createPanner_Callback";

  WaveShaperNode createWaveShaper() {
    return _createWaveShaper();
  }

  WaveShaperNode _createWaveShaper() native "AudioContext_createWaveShaper_Callback";

  WaveTable createWaveTable(Float32Array real, Float32Array imag) {
    return _createWaveTable(real, imag);
  }

  WaveTable _createWaveTable(real, imag) native "AudioContext_createWaveTable_Callback";

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback = null]) {
    _decodeAudioData(audioData, successCallback, errorCallback);
    return;
  }

  void _decodeAudioData(audioData, successCallback, errorCallback) native "AudioContext_decodeAudioData_Callback";

  void startRendering() {
    _startRendering();
    return;
  }

  void _startRendering() native "AudioContext_startRendering_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioDestinationNodeDOMImpl extends _AudioNodeDOMImpl implements AudioDestinationNode {
  _AudioDestinationNodeDOMImpl();
  String get typeName() => "AudioDestinationNode";

  int get numberOfChannels() native "AudioDestinationNode_numberOfChannels_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioGainDOMImpl extends _AudioParamDOMImpl implements AudioGain {
  _AudioGainDOMImpl();
  String get typeName() => "AudioGain";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioGainNodeDOMImpl extends _AudioNodeDOMImpl implements AudioGainNode {
  _AudioGainNodeDOMImpl();
  String get typeName() => "AudioGainNode";

  AudioGain get gain() native "AudioGainNode_gain_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioListenerDOMImpl extends _DOMWrapperBase implements AudioListener {
  _AudioListenerDOMImpl();
  String get typeName() => "AudioListener";

  num get dopplerFactor() native "AudioListener_dopplerFactor_Getter";

  void set dopplerFactor(num) native "AudioListener_dopplerFactor_Setter";

  num get speedOfSound() native "AudioListener_speedOfSound_Getter";

  void set speedOfSound(num) native "AudioListener_speedOfSound_Setter";

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) {
    _setOrientation(x, y, z, xUp, yUp, zUp);
    return;
  }

  void _setOrientation(x, y, z, xUp, yUp, zUp) native "AudioListener_setOrientation_Callback";

  void setPosition(num x, num y, num z) {
    _setPosition(x, y, z);
    return;
  }

  void _setPosition(x, y, z) native "AudioListener_setPosition_Callback";

  void setVelocity(num x, num y, num z) {
    _setVelocity(x, y, z);
    return;
  }

  void _setVelocity(x, y, z) native "AudioListener_setVelocity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioNodeDOMImpl extends _DOMWrapperBase implements AudioNode {
  _AudioNodeDOMImpl();
  String get typeName() => "AudioNode";

  AudioContext get context() native "AudioNode_context_Getter";

  int get numberOfInputs() native "AudioNode_numberOfInputs_Getter";

  int get numberOfOutputs() native "AudioNode_numberOfOutputs_Getter";

  void connect(destination, int output, [int input = null]) {
    //
    // connect(AudioNode destination, int output, int input)
    // connect(AudioParam destination, int output)
    //
    if ((destination === null || destination is AudioNode)) {
      _connect(destination, output, input);
      return;
    }
    if ((destination === null || destination is AudioParam) && input === null) {
      _connect_2(destination, output);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _connect(destination, output, input) native "AudioNode_connect_Callback";

  void _connect_2(destination, output) native "AudioNode_connect_2_Callback";

  void disconnect(int output) {
    _disconnect(output);
    return;
  }

  void _disconnect(output) native "AudioNode_disconnect_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioPannerNodeDOMImpl extends _AudioNodeDOMImpl implements AudioPannerNode {
  _AudioPannerNodeDOMImpl();
  String get typeName() => "AudioPannerNode";

  AudioGain get coneGain() native "AudioPannerNode_coneGain_Getter";

  num get coneInnerAngle() native "AudioPannerNode_coneInnerAngle_Getter";

  void set coneInnerAngle(num) native "AudioPannerNode_coneInnerAngle_Setter";

  num get coneOuterAngle() native "AudioPannerNode_coneOuterAngle_Getter";

  void set coneOuterAngle(num) native "AudioPannerNode_coneOuterAngle_Setter";

  num get coneOuterGain() native "AudioPannerNode_coneOuterGain_Getter";

  void set coneOuterGain(num) native "AudioPannerNode_coneOuterGain_Setter";

  AudioGain get distanceGain() native "AudioPannerNode_distanceGain_Getter";

  int get distanceModel() native "AudioPannerNode_distanceModel_Getter";

  void set distanceModel(int) native "AudioPannerNode_distanceModel_Setter";

  num get maxDistance() native "AudioPannerNode_maxDistance_Getter";

  void set maxDistance(num) native "AudioPannerNode_maxDistance_Setter";

  int get panningModel() native "AudioPannerNode_panningModel_Getter";

  void set panningModel(int) native "AudioPannerNode_panningModel_Setter";

  num get refDistance() native "AudioPannerNode_refDistance_Getter";

  void set refDistance(num) native "AudioPannerNode_refDistance_Setter";

  num get rolloffFactor() native "AudioPannerNode_rolloffFactor_Getter";

  void set rolloffFactor(num) native "AudioPannerNode_rolloffFactor_Setter";

  void setOrientation(num x, num y, num z) {
    _setOrientation(x, y, z);
    return;
  }

  void _setOrientation(x, y, z) native "AudioPannerNode_setOrientation_Callback";

  void setPosition(num x, num y, num z) {
    _setPosition(x, y, z);
    return;
  }

  void _setPosition(x, y, z) native "AudioPannerNode_setPosition_Callback";

  void setVelocity(num x, num y, num z) {
    _setVelocity(x, y, z);
    return;
  }

  void _setVelocity(x, y, z) native "AudioPannerNode_setVelocity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioParamDOMImpl extends _DOMWrapperBase implements AudioParam {
  _AudioParamDOMImpl();
  String get typeName() => "AudioParam";

  num get defaultValue() native "AudioParam_defaultValue_Getter";

  num get maxValue() native "AudioParam_maxValue_Getter";

  num get minValue() native "AudioParam_minValue_Getter";

  String get name() native "AudioParam_name_Getter";

  int get units() native "AudioParam_units_Getter";

  num get value() native "AudioParam_value_Getter";

  void set value(num) native "AudioParam_value_Setter";

  void cancelScheduledValues(num startTime) {
    _cancelScheduledValues(startTime);
    return;
  }

  void _cancelScheduledValues(startTime) native "AudioParam_cancelScheduledValues_Callback";

  void exponentialRampToValueAtTime(num value, num time) {
    _exponentialRampToValueAtTime(value, time);
    return;
  }

  void _exponentialRampToValueAtTime(value, time) native "AudioParam_exponentialRampToValueAtTime_Callback";

  void linearRampToValueAtTime(num value, num time) {
    _linearRampToValueAtTime(value, time);
    return;
  }

  void _linearRampToValueAtTime(value, time) native "AudioParam_linearRampToValueAtTime_Callback";

  void setTargetValueAtTime(num targetValue, num time, num timeConstant) {
    _setTargetValueAtTime(targetValue, time, timeConstant);
    return;
  }

  void _setTargetValueAtTime(targetValue, time, timeConstant) native "AudioParam_setTargetValueAtTime_Callback";

  void setValueAtTime(num value, num time) {
    _setValueAtTime(value, time);
    return;
  }

  void _setValueAtTime(value, time) native "AudioParam_setValueAtTime_Callback";

  void setValueCurveAtTime(Float32Array values, num time, num duration) {
    _setValueCurveAtTime(values, time, duration);
    return;
  }

  void _setValueCurveAtTime(values, time, duration) native "AudioParam_setValueCurveAtTime_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioProcessingEventDOMImpl extends _EventDOMImpl implements AudioProcessingEvent {
  _AudioProcessingEventDOMImpl();
  String get typeName() => "AudioProcessingEvent";

  AudioBuffer get inputBuffer() native "AudioProcessingEvent_inputBuffer_Getter";

  AudioBuffer get outputBuffer() native "AudioProcessingEvent_outputBuffer_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _AudioSourceNodeDOMImpl extends _AudioNodeDOMImpl implements AudioSourceNode {
  _AudioSourceNodeDOMImpl();
  String get typeName() => "AudioSourceNode";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _BarInfoDOMImpl extends _DOMWrapperBase implements BarInfo {
  _BarInfoDOMImpl();
  String get typeName() => "BarInfo";

  bool get visible() native "BarInfo_visible_Getter";

}

class _BatteryManagerEventsImpl extends _EventsImpl implements BatteryManagerEvents {
  _BatteryManagerEventsImpl(_ptr) : super(_ptr);
  EventListenerList get chargingChange() => _get('chargingchange');
  EventListenerList get chargingTimeChange() => _get('chargingtimechange');
  EventListenerList get dischargingTimeChange() => _get('dischargingtimechange');
  EventListenerList get levelChange() => _get('levelchange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _BatteryManagerDOMImpl extends _DOMWrapperBase implements BatteryManager {
  _BatteryManagerDOMImpl();
  String get typeName() => "BatteryManager";
  _EventsImpl _on;

  _BatteryManagerEventsImpl get on() {
    if (_on === null) _on = new _BatteryManagerEventsImpl(this);
    return _on;
  }

  bool get charging() native "BatteryManager_charging_Getter";

  num get chargingTime() native "BatteryManager_chargingTime_Getter";

  num get dischargingTime() native "BatteryManager_dischargingTime_Getter";

  num get level() native "BatteryManager_level_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "BatteryManager_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "BatteryManager_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "BatteryManager_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _BeforeLoadEventDOMImpl extends _EventDOMImpl implements BeforeLoadEvent {
  _BeforeLoadEventDOMImpl();
  String get typeName() => "BeforeLoadEvent";

  String get url() native "BeforeLoadEvent_url_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _BiquadFilterNodeDOMImpl extends _AudioNodeDOMImpl implements BiquadFilterNode {
  _BiquadFilterNodeDOMImpl();
  String get typeName() => "BiquadFilterNode";

  AudioParam get Q() native "BiquadFilterNode_Q_Getter";

  AudioParam get frequency() native "BiquadFilterNode_frequency_Getter";

  AudioParam get gain() native "BiquadFilterNode_gain_Getter";

  int get type() native "BiquadFilterNode_type_Getter";

  void set type(int) native "BiquadFilterNode_type_Setter";

  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse) {
    _getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
    return;
  }

  void _getFrequencyResponse(frequencyHz, magResponse, phaseResponse) native "BiquadFilterNode_getFrequencyResponse_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _BlobDOMImpl extends _DOMWrapperBase implements Blob {
  _BlobDOMImpl();
  String get typeName() => "Blob";

  int get size() native "Blob_size_Getter";

  String get type() native "Blob_type_Getter";

  Blob webkitSlice([int start = null, int end = null, String contentType = null]) {
    //
    // webkitSlice()
    // webkitSlice([Optional] int start)
    // webkitSlice([Optional] int start, [Optional] int end)
    // webkitSlice([Optional] int start, [Optional] int end, [Optional] String contentType)
    //
    // -- reduced:
    // webkitSlice([Optional] int start, [Optional] int end, [Optional] String contentType)
    //
    return _webkitSlice(start, end, contentType);
  }

  Blob _webkitSlice(start, end, contentType) native "Blob_webkitSlice_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CDATASectionDOMImpl extends _TextDOMImpl implements CDATASection {
  _CDATASectionDOMImpl();
  String get typeName() => "CDATASection";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSCharsetRuleDOMImpl extends _CSSRuleDOMImpl implements CSSCharsetRule {
  _CSSCharsetRuleDOMImpl();
  String get typeName() => "CSSCharsetRule";

  String get encoding() native "CSSCharsetRule_encoding_Getter";

  void set encoding(String) native "CSSCharsetRule_encoding_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSFontFaceRuleDOMImpl extends _CSSRuleDOMImpl implements CSSFontFaceRule {
  _CSSFontFaceRuleDOMImpl();
  String get typeName() => "CSSFontFaceRule";

  CSSStyleDeclaration get style() native "CSSFontFaceRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSImportRuleDOMImpl extends _CSSRuleDOMImpl implements CSSImportRule {
  _CSSImportRuleDOMImpl();
  String get typeName() => "CSSImportRule";

  String get href() native "CSSImportRule_href_Getter";

  MediaList get media() native "CSSImportRule_media_Getter";

  CSSStyleSheet get styleSheet() native "CSSImportRule_styleSheet_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSMediaRuleDOMImpl extends _CSSRuleDOMImpl implements CSSMediaRule {
  _CSSMediaRuleDOMImpl();
  String get typeName() => "CSSMediaRule";

  CSSRuleList get cssRules() native "CSSMediaRule_cssRules_Getter";

  MediaList get media() native "CSSMediaRule_media_Getter";

  void deleteRule(int index) {
    _deleteRule(index);
    return;
  }

  void _deleteRule(index) native "CSSMediaRule_deleteRule_Callback";

  int insertRule(String rule, int index) {
    return _insertRule(rule, index);
  }

  int _insertRule(rule, index) native "CSSMediaRule_insertRule_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSPageRuleDOMImpl extends _CSSRuleDOMImpl implements CSSPageRule {
  _CSSPageRuleDOMImpl();
  String get typeName() => "CSSPageRule";

  String get selectorText() native "CSSPageRule_selectorText_Getter";

  void set selectorText(String) native "CSSPageRule_selectorText_Setter";

  CSSStyleDeclaration get style() native "CSSPageRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSPrimitiveValueDOMImpl extends _CSSValueDOMImpl implements CSSPrimitiveValue {
  _CSSPrimitiveValueDOMImpl();
  String get typeName() => "CSSPrimitiveValue";

  int get primitiveType() native "CSSPrimitiveValue_primitiveType_Getter";

  Counter getCounterValue() {
    return _getCounterValue();
  }

  Counter _getCounterValue() native "CSSPrimitiveValue_getCounterValue_Callback";

  num getFloatValue(int unitType) {
    return _getFloatValue(unitType);
  }

  num _getFloatValue(unitType) native "CSSPrimitiveValue_getFloatValue_Callback";

  RGBColor getRGBColorValue() {
    return _getRGBColorValue();
  }

  RGBColor _getRGBColorValue() native "CSSPrimitiveValue_getRGBColorValue_Callback";

  Rect getRectValue() {
    return _getRectValue();
  }

  Rect _getRectValue() native "CSSPrimitiveValue_getRectValue_Callback";

  String getStringValue() {
    return _getStringValue();
  }

  String _getStringValue() native "CSSPrimitiveValue_getStringValue_Callback";

  void setFloatValue(int unitType, num floatValue) {
    _setFloatValue(unitType, floatValue);
    return;
  }

  void _setFloatValue(unitType, floatValue) native "CSSPrimitiveValue_setFloatValue_Callback";

  void setStringValue(int stringType, String stringValue) {
    _setStringValue(stringType, stringValue);
    return;
  }

  void _setStringValue(stringType, stringValue) native "CSSPrimitiveValue_setStringValue_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSRuleDOMImpl extends _DOMWrapperBase implements CSSRule {
  _CSSRuleDOMImpl();
  String get typeName() => "CSSRule";

  String get cssText() native "CSSRule_cssText_Getter";

  void set cssText(String) native "CSSRule_cssText_Setter";

  CSSRule get parentRule() native "CSSRule_parentRule_Getter";

  CSSStyleSheet get parentStyleSheet() native "CSSRule_parentStyleSheet_Getter";

  int get type() native "CSSRule_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSRuleListDOMImpl extends _DOMWrapperBase implements CSSRuleList {
  _CSSRuleListDOMImpl();
  String get typeName() => "CSSRuleList";

  int get length() native "CSSRuleList_length_Getter";

  CSSRule item(int index) {
    return _item(index);
  }

  CSSRule _item(index) native "CSSRuleList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSStyleDeclarationDOMImpl extends _DOMWrapperBase implements CSSStyleDeclaration {
  _CSSStyleDeclarationDOMImpl();
  String get typeName() => "CSSStyleDeclaration";

  String get cssText() native "CSSStyleDeclaration_cssText_Getter";

  void set cssText(String) native "CSSStyleDeclaration_cssText_Setter";

  int get length() native "CSSStyleDeclaration_length_Getter";

  CSSRule get parentRule() native "CSSStyleDeclaration_parentRule_Getter";

  CSSValue getPropertyCSSValue(String propertyName) {
    return _getPropertyCSSValue(propertyName);
  }

  CSSValue _getPropertyCSSValue(propertyName) native "CSSStyleDeclaration_getPropertyCSSValue_Callback";

  String getPropertyPriority(String propertyName) {
    return _getPropertyPriority(propertyName);
  }

  String _getPropertyPriority(propertyName) native "CSSStyleDeclaration_getPropertyPriority_Callback";

  String getPropertyShorthand(String propertyName) {
    return _getPropertyShorthand(propertyName);
  }

  String _getPropertyShorthand(propertyName) native "CSSStyleDeclaration_getPropertyShorthand_Callback";

  String getPropertyValue(String propertyName) {
    return _getPropertyValue(propertyName);
  }

  String _getPropertyValue(propertyName) native "CSSStyleDeclaration_getPropertyValue_Callback";

  bool isPropertyImplicit(String propertyName) {
    return _isPropertyImplicit(propertyName);
  }

  bool _isPropertyImplicit(propertyName) native "CSSStyleDeclaration_isPropertyImplicit_Callback";

  String item(int index) {
    return _item(index);
  }

  String _item(index) native "CSSStyleDeclaration_item_Callback";

  String removeProperty(String propertyName) {
    return _removeProperty(propertyName);
  }

  String _removeProperty(propertyName) native "CSSStyleDeclaration_removeProperty_Callback";

  void setProperty(String propertyName, String value, [String priority = null]) {
    _setProperty(propertyName, value, priority);
    return;
  }

  void _setProperty(propertyName, value, priority) native "CSSStyleDeclaration_setProperty_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSStyleRuleDOMImpl extends _CSSRuleDOMImpl implements CSSStyleRule {
  _CSSStyleRuleDOMImpl();
  String get typeName() => "CSSStyleRule";

  String get selectorText() native "CSSStyleRule_selectorText_Getter";

  void set selectorText(String) native "CSSStyleRule_selectorText_Setter";

  CSSStyleDeclaration get style() native "CSSStyleRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSStyleSheetDOMImpl extends _StyleSheetDOMImpl implements CSSStyleSheet {
  _CSSStyleSheetDOMImpl();
  String get typeName() => "CSSStyleSheet";

  CSSRuleList get cssRules() native "CSSStyleSheet_cssRules_Getter";

  CSSRule get ownerRule() native "CSSStyleSheet_ownerRule_Getter";

  CSSRuleList get rules() native "CSSStyleSheet_rules_Getter";

  int addRule(String selector, String style, [int index = null]) {
    //
    // addRule(String selector, String style)
    // addRule(String selector, String style, [Optional] int index)
    //
    // -- reduced:
    // addRule(String selector, String style, [Optional] int index)
    //
    return _addRule(selector, style, index);
  }

  int _addRule(selector, style, index) native "CSSStyleSheet_addRule_Callback";

  void deleteRule(int index) {
    _deleteRule(index);
    return;
  }

  void _deleteRule(index) native "CSSStyleSheet_deleteRule_Callback";

  int insertRule(String rule, int index) {
    return _insertRule(rule, index);
  }

  int _insertRule(rule, index) native "CSSStyleSheet_insertRule_Callback";

  void removeRule(int index) {
    _removeRule(index);
    return;
  }

  void _removeRule(index) native "CSSStyleSheet_removeRule_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSUnknownRuleDOMImpl extends _CSSRuleDOMImpl implements CSSUnknownRule {
  _CSSUnknownRuleDOMImpl();
  String get typeName() => "CSSUnknownRule";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSValueDOMImpl extends _DOMWrapperBase implements CSSValue {
  _CSSValueDOMImpl();
  String get typeName() => "CSSValue";

  String get cssText() native "CSSValue_cssText_Getter";

  void set cssText(String) native "CSSValue_cssText_Setter";

  int get cssValueType() native "CSSValue_cssValueType_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CSSValueListDOMImpl extends _CSSValueDOMImpl implements CSSValueList {
  _CSSValueListDOMImpl();
  String get typeName() => "CSSValueList";

  int get length() native "CSSValueList_length_Getter";

  CSSValue item(int index) {
    return _item(index);
  }

  CSSValue _item(index) native "CSSValueList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CanvasGradientDOMImpl extends _DOMWrapperBase implements CanvasGradient {
  _CanvasGradientDOMImpl();
  String get typeName() => "CanvasGradient";

  void addColorStop(num offset, String color) {
    _addColorStop(offset, color);
    return;
  }

  void _addColorStop(offset, color) native "CanvasGradient_addColorStop_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CanvasPatternDOMImpl extends _DOMWrapperBase implements CanvasPattern {
  _CanvasPatternDOMImpl();
  String get typeName() => "CanvasPattern";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CanvasRenderingContext2DDOMImpl extends _CanvasRenderingContextDOMImpl implements CanvasRenderingContext2D {
  _CanvasRenderingContext2DDOMImpl();
  String get typeName() => "CanvasRenderingContext2D";

  Dynamic get fillStyle() native "CanvasRenderingContext2D_fillStyle_Getter";

  void set fillStyle(Dynamic) native "CanvasRenderingContext2D_fillStyle_Setter";

  String get font() native "CanvasRenderingContext2D_font_Getter";

  void set font(String) native "CanvasRenderingContext2D_font_Setter";

  num get globalAlpha() native "CanvasRenderingContext2D_globalAlpha_Getter";

  void set globalAlpha(num) native "CanvasRenderingContext2D_globalAlpha_Setter";

  String get globalCompositeOperation() native "CanvasRenderingContext2D_globalCompositeOperation_Getter";

  void set globalCompositeOperation(String) native "CanvasRenderingContext2D_globalCompositeOperation_Setter";

  String get lineCap() native "CanvasRenderingContext2D_lineCap_Getter";

  void set lineCap(String) native "CanvasRenderingContext2D_lineCap_Setter";

  String get lineJoin() native "CanvasRenderingContext2D_lineJoin_Getter";

  void set lineJoin(String) native "CanvasRenderingContext2D_lineJoin_Setter";

  num get lineWidth() native "CanvasRenderingContext2D_lineWidth_Getter";

  void set lineWidth(num) native "CanvasRenderingContext2D_lineWidth_Setter";

  num get miterLimit() native "CanvasRenderingContext2D_miterLimit_Getter";

  void set miterLimit(num) native "CanvasRenderingContext2D_miterLimit_Setter";

  num get shadowBlur() native "CanvasRenderingContext2D_shadowBlur_Getter";

  void set shadowBlur(num) native "CanvasRenderingContext2D_shadowBlur_Setter";

  String get shadowColor() native "CanvasRenderingContext2D_shadowColor_Getter";

  void set shadowColor(String) native "CanvasRenderingContext2D_shadowColor_Setter";

  num get shadowOffsetX() native "CanvasRenderingContext2D_shadowOffsetX_Getter";

  void set shadowOffsetX(num) native "CanvasRenderingContext2D_shadowOffsetX_Setter";

  num get shadowOffsetY() native "CanvasRenderingContext2D_shadowOffsetY_Getter";

  void set shadowOffsetY(num) native "CanvasRenderingContext2D_shadowOffsetY_Setter";

  Dynamic get strokeStyle() native "CanvasRenderingContext2D_strokeStyle_Getter";

  void set strokeStyle(Dynamic) native "CanvasRenderingContext2D_strokeStyle_Setter";

  String get textAlign() native "CanvasRenderingContext2D_textAlign_Getter";

  void set textAlign(String) native "CanvasRenderingContext2D_textAlign_Setter";

  String get textBaseline() native "CanvasRenderingContext2D_textBaseline_Getter";

  void set textBaseline(String) native "CanvasRenderingContext2D_textBaseline_Setter";

  num get webkitBackingStorePixelRatio() native "CanvasRenderingContext2D_webkitBackingStorePixelRatio_Getter";

  List get webkitLineDash() native "CanvasRenderingContext2D_webkitLineDash_Getter";

  void set webkitLineDash(List) native "CanvasRenderingContext2D_webkitLineDash_Setter";

  num get webkitLineDashOffset() native "CanvasRenderingContext2D_webkitLineDashOffset_Getter";

  void set webkitLineDashOffset(num) native "CanvasRenderingContext2D_webkitLineDashOffset_Setter";

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) {
    _arc(x, y, radius, startAngle, endAngle, anticlockwise);
    return;
  }

  void _arc(x, y, radius, startAngle, endAngle, anticlockwise) native "CanvasRenderingContext2D_arc_Callback";

  void arcTo(num x1, num y1, num x2, num y2, num radius) {
    _arcTo(x1, y1, x2, y2, radius);
    return;
  }

  void _arcTo(x1, y1, x2, y2, radius) native "CanvasRenderingContext2D_arcTo_Callback";

  void beginPath() {
    _beginPath();
    return;
  }

  void _beginPath() native "CanvasRenderingContext2D_beginPath_Callback";

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) {
    _bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    return;
  }

  void _bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) native "CanvasRenderingContext2D_bezierCurveTo_Callback";

  void clearRect(num x, num y, num width, num height) {
    _clearRect(x, y, width, height);
    return;
  }

  void _clearRect(x, y, width, height) native "CanvasRenderingContext2D_clearRect_Callback";

  void clearShadow() {
    _clearShadow();
    return;
  }

  void _clearShadow() native "CanvasRenderingContext2D_clearShadow_Callback";

  void clip() {
    _clip();
    return;
  }

  void _clip() native "CanvasRenderingContext2D_clip_Callback";

  void closePath() {
    _closePath();
    return;
  }

  void _closePath() native "CanvasRenderingContext2D_closePath_Callback";

  ImageData createImageData(imagedata_OR_sw, [num sh = null]) {
    //
    // createImageData(ImageData imagedata)
    // createImageData(num sw, num sh)
    //
    if ((imagedata_OR_sw === null || imagedata_OR_sw is ImageData) &&
        sh === null) {
      return _createImageData(imagedata_OR_sw);
    }
    if ((imagedata_OR_sw === null || imagedata_OR_sw is num)) {
      return _createImageData_2(imagedata_OR_sw, sh);
    }
    throw "Incorrect number or type of arguments";
  }

  ImageData _createImageData(imagedata_OR_sw) native "CanvasRenderingContext2D_createImageData_Callback";

  ImageData _createImageData_2(imagedata_OR_sw, sh) native "CanvasRenderingContext2D_createImageData_2_Callback";

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) {
    return _createLinearGradient(x0, y0, x1, y1);
  }

  CanvasGradient _createLinearGradient(x0, y0, x1, y1) native "CanvasRenderingContext2D_createLinearGradient_Callback";

  CanvasPattern createPattern(canvas_OR_image, String repetitionType) {
    //
    // createPattern(HTMLCanvasElement canvas, String repetitionType)
    // createPattern(HTMLImageElement image, String repetitionType)
    //
    if ((canvas_OR_image === null || canvas_OR_image is CanvasElement)) {
      return _createPattern(canvas_OR_image, repetitionType);
    }
    if ((canvas_OR_image === null || canvas_OR_image is ImageElement)) {
      return _createPattern_2(canvas_OR_image, repetitionType);
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasPattern _createPattern(canvas_OR_image, repetitionType) native "CanvasRenderingContext2D_createPattern_Callback";

  CanvasPattern _createPattern_2(canvas_OR_image, repetitionType) native "CanvasRenderingContext2D_createPattern_2_Callback";

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) {
    return _createRadialGradient(x0, y0, r0, x1, y1, r1);
  }

  CanvasGradient _createRadialGradient(x0, y0, r0, x1, y1, r1) native "CanvasRenderingContext2D_createRadialGradient_Callback";

  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width = null, num height_OR_sh = null, num dx = null, num dy = null, num dw = null, num dh = null]) {
    //
    // drawImage(HTMLImageElement image, num x, num y)
    // drawImage(HTMLImageElement image, num x, num y, num width, num height)
    // drawImage(HTMLImageElement image, num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh)
    // drawImage(HTMLCanvasElement canvas, num x, num y)
    // drawImage(HTMLCanvasElement canvas, num x, num y, num width, num height)
    // drawImage(HTMLCanvasElement canvas, num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh)
    // drawImage(HTMLVideoElement video, num x, num y)
    // drawImage(HTMLVideoElement video, num x, num y, num width, num height)
    // drawImage(HTMLVideoElement video, num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh)
    //
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is ImageElement) &&
        sw_OR_width === null &&
        height_OR_sh === null &&
        dx === null &&
        dy === null &&
        dw === null &&
        dh === null) {
      _drawImage(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is ImageElement) &&
        dx === null &&
        dy === null &&
        dw === null &&
        dh === null) {
      _drawImage_2(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is ImageElement)) {
      _drawImage_3(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is CanvasElement) &&
        sw_OR_width === null &&
        height_OR_sh === null &&
        dx === null &&
        dy === null &&
        dw === null &&
        dh === null) {
      _drawImage_4(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is CanvasElement) &&
        dx === null &&
        dy === null &&
        dw === null &&
        dh === null) {
      _drawImage_5(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is CanvasElement)) {
      _drawImage_6(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is VideoElement) &&
        sw_OR_width === null &&
        height_OR_sh === null &&
        dx === null &&
        dy === null &&
        dw === null &&
        dh === null) {
      _drawImage_7(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is VideoElement) &&
        dx === null &&
        dy === null &&
        dw === null &&
        dh === null) {
      _drawImage_8(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh);
      return;
    }
    if ((canvas_OR_image_OR_video === null || canvas_OR_image_OR_video is VideoElement)) {
      _drawImage_9(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _drawImage(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y) native "CanvasRenderingContext2D_drawImage_Callback";

  void _drawImage_2(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh) native "CanvasRenderingContext2D_drawImage_2_Callback";

  void _drawImage_3(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh) native "CanvasRenderingContext2D_drawImage_3_Callback";

  void _drawImage_4(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y) native "CanvasRenderingContext2D_drawImage_4_Callback";

  void _drawImage_5(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh) native "CanvasRenderingContext2D_drawImage_5_Callback";

  void _drawImage_6(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh) native "CanvasRenderingContext2D_drawImage_6_Callback";

  void _drawImage_7(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y) native "CanvasRenderingContext2D_drawImage_7_Callback";

  void _drawImage_8(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh) native "CanvasRenderingContext2D_drawImage_8_Callback";

  void _drawImage_9(canvas_OR_image_OR_video, sx_OR_x, sy_OR_y, sw_OR_width, height_OR_sh, dx, dy, dw, dh) native "CanvasRenderingContext2D_drawImage_9_Callback";

  void drawImageFromRect(ImageElement image, [num sx = null, num sy = null, num sw = null, num sh = null, num dx = null, num dy = null, num dw = null, num dh = null, String compositeOperation = null]) {
    //
    // drawImageFromRect(HTMLImageElement image)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh, [Optional] num dx)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh, [Optional] num dx, [Optional] num dy)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh, [Optional] num dx, [Optional] num dy, [Optional] num dw)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh, [Optional] num dx, [Optional] num dy, [Optional] num dw, [Optional] num dh)
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh, [Optional] num dx, [Optional] num dy, [Optional] num dw, [Optional] num dh, [Optional] String compositeOperation)
    //
    // -- reduced:
    // drawImageFromRect(HTMLImageElement image, [Optional] num sx, [Optional] num sy, [Optional] num sw, [Optional] num sh, [Optional] num dx, [Optional] num dy, [Optional] num dw, [Optional] num dh, [Optional] String compositeOperation)
    //
    if ((image === null || image is ImageElement)) {
      _drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw, dh, compositeOperation);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _drawImageFromRect(image, sx, sy, sw, sh, dx, dy, dw, dh, compositeOperation) native "CanvasRenderingContext2D_drawImageFromRect_Callback";

  void fill() {
    _fill();
    return;
  }

  void _fill() native "CanvasRenderingContext2D_fill_Callback";

  void fillRect(num x, num y, num width, num height) {
    _fillRect(x, y, width, height);
    return;
  }

  void _fillRect(x, y, width, height) native "CanvasRenderingContext2D_fillRect_Callback";

  void fillText(String text, num x, num y, [num maxWidth = null]) {
    //
    // fillText(String text, num x, num y)
    // fillText(String text, num x, num y, [Optional] num maxWidth)
    //
    // -- reduced:
    // fillText(String text, num x, num y, [Optional] num maxWidth)
    //
    _fillText(text, x, y, maxWidth);
    return;
  }

  void _fillText(text, x, y, maxWidth) native "CanvasRenderingContext2D_fillText_Callback";

  ImageData getImageData(num sx, num sy, num sw, num sh) {
    return _getImageData(sx, sy, sw, sh);
  }

  ImageData _getImageData(sx, sy, sw, sh) native "CanvasRenderingContext2D_getImageData_Callback";

  bool isPointInPath(num x, num y) {
    return _isPointInPath(x, y);
  }

  bool _isPointInPath(x, y) native "CanvasRenderingContext2D_isPointInPath_Callback";

  void lineTo(num x, num y) {
    _lineTo(x, y);
    return;
  }

  void _lineTo(x, y) native "CanvasRenderingContext2D_lineTo_Callback";

  TextMetrics measureText(String text) {
    return _measureText(text);
  }

  TextMetrics _measureText(text) native "CanvasRenderingContext2D_measureText_Callback";

  void moveTo(num x, num y) {
    _moveTo(x, y);
    return;
  }

  void _moveTo(x, y) native "CanvasRenderingContext2D_moveTo_Callback";

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) {
    //
    // putImageData(ImageData imagedata, num dx, num dy)
    // putImageData(ImageData imagedata, num dx, num dy, num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight)
    //
    if (dirtyX === null &&
        dirtyY === null &&
        dirtyWidth === null &&
        dirtyHeight === null) {
      _putImageData(imagedata, dx, dy);
      return;
    }
    _putImageData_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    return;
  }

  void _putImageData(imagedata, dx, dy) native "CanvasRenderingContext2D_putImageData_Callback";

  void _putImageData_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native "CanvasRenderingContext2D_putImageData_2_Callback";

  void quadraticCurveTo(num cpx, num cpy, num x, num y) {
    _quadraticCurveTo(cpx, cpy, x, y);
    return;
  }

  void _quadraticCurveTo(cpx, cpy, x, y) native "CanvasRenderingContext2D_quadraticCurveTo_Callback";

  void rect(num x, num y, num width, num height) {
    _rect(x, y, width, height);
    return;
  }

  void _rect(x, y, width, height) native "CanvasRenderingContext2D_rect_Callback";

  void restore() {
    _restore();
    return;
  }

  void _restore() native "CanvasRenderingContext2D_restore_Callback";

  void rotate(num angle) {
    _rotate(angle);
    return;
  }

  void _rotate(angle) native "CanvasRenderingContext2D_rotate_Callback";

  void save() {
    _save();
    return;
  }

  void _save() native "CanvasRenderingContext2D_save_Callback";

  void scale(num sx, num sy) {
    _scale(sx, sy);
    return;
  }

  void _scale(sx, sy) native "CanvasRenderingContext2D_scale_Callback";

  void setAlpha(num alpha) {
    _setAlpha(alpha);
    return;
  }

  void _setAlpha(alpha) native "CanvasRenderingContext2D_setAlpha_Callback";

  void setCompositeOperation(String compositeOperation) {
    _setCompositeOperation(compositeOperation);
    return;
  }

  void _setCompositeOperation(compositeOperation) native "CanvasRenderingContext2D_setCompositeOperation_Callback";

  void setFillColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    //
    // setFillColor(String color)
    // setFillColor(String color, [Optional] num alpha)
    // setFillColor(num grayLevel)
    // setFillColor(num grayLevel, [Optional] num alpha)
    // setFillColor(num r, num g, num b, num a)
    // setFillColor(num c, num m, num y, num k, num a)
    //
    // -- reduced:
    // setFillColor(String color, [Optional] num alpha)
    // setFillColor(num grayLevel, [Optional] num alpha)
    // setFillColor(num r, num g, num b, num a)
    // setFillColor(num c, num m, num y, num k, num a)
    //
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is String) &&
        b_OR_y === null &&
        a_OR_k === null &&
        a === null) {
      _setFillColor(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num) &&
        b_OR_y === null &&
        a_OR_k === null &&
        a === null) {
      _setFillColor_2(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num) &&
        a === null) {
      _setFillColor_3(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num)) {
      _setFillColor_4(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k, a);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _setFillColor(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m) native "CanvasRenderingContext2D_setFillColor_Callback";

  void _setFillColor_2(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m) native "CanvasRenderingContext2D_setFillColor_2_Callback";

  void _setFillColor_3(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k) native "CanvasRenderingContext2D_setFillColor_3_Callback";

  void _setFillColor_4(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k, a) native "CanvasRenderingContext2D_setFillColor_4_Callback";

  void setLineCap(String cap) {
    _setLineCap(cap);
    return;
  }

  void _setLineCap(cap) native "CanvasRenderingContext2D_setLineCap_Callback";

  void setLineJoin(String join) {
    _setLineJoin(join);
    return;
  }

  void _setLineJoin(join) native "CanvasRenderingContext2D_setLineJoin_Callback";

  void setLineWidth(num width) {
    _setLineWidth(width);
    return;
  }

  void _setLineWidth(width) native "CanvasRenderingContext2D_setLineWidth_Callback";

  void setMiterLimit(num limit) {
    _setMiterLimit(limit);
    return;
  }

  void _setMiterLimit(limit) native "CanvasRenderingContext2D_setMiterLimit_Callback";

  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r = null, num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    //
    // setShadow(num width, num height, num blur)
    // setShadow(num width, num height, num blur, [Optional] String color)
    // setShadow(num width, num height, num blur, [Optional] String color, [Optional] num alpha)
    // setShadow(num width, num height, num blur, num grayLevel)
    // setShadow(num width, num height, num blur, num grayLevel, [Optional] num alpha)
    // setShadow(num width, num height, num blur, num r, num g, num b, num a)
    // setShadow(num width, num height, num blur, num c, num m, num y, num k, num a)
    //
    // -- reduced:
    // setShadow(num width, num height, num blur, [Optional] String color, [Optional] num alpha)
    // setShadow(num width, num height, num blur, num grayLevel, [Optional] num alpha)
    // setShadow(num width, num height, num blur, num r, num g, num b, num a)
    // setShadow(num width, num height, num blur, num c, num m, num y, num k, num a)
    //
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is String) &&
        b_OR_y === null &&
        a_OR_k === null &&
        a === null) {
      _setShadow(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num) &&
        b_OR_y === null &&
        a_OR_k === null &&
        a === null) {
      _setShadow_2(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num) &&
        a === null) {
      _setShadow_3(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num)) {
      _setShadow_4(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k, a);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _setShadow(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m) native "CanvasRenderingContext2D_setShadow_Callback";

  void _setShadow_2(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m) native "CanvasRenderingContext2D_setShadow_2_Callback";

  void _setShadow_3(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k) native "CanvasRenderingContext2D_setShadow_3_Callback";

  void _setShadow_4(width, height, blur, c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k, a) native "CanvasRenderingContext2D_setShadow_4_Callback";

  void setStrokeColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    //
    // setStrokeColor(String color)
    // setStrokeColor(String color, [Optional] num alpha)
    // setStrokeColor(num grayLevel)
    // setStrokeColor(num grayLevel, [Optional] num alpha)
    // setStrokeColor(num r, num g, num b, num a)
    // setStrokeColor(num c, num m, num y, num k, num a)
    //
    // -- reduced:
    // setStrokeColor(String color, [Optional] num alpha)
    // setStrokeColor(num grayLevel, [Optional] num alpha)
    // setStrokeColor(num r, num g, num b, num a)
    // setStrokeColor(num c, num m, num y, num k, num a)
    //
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is String) &&
        b_OR_y === null &&
        a_OR_k === null &&
        a === null) {
      _setStrokeColor(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num) &&
        b_OR_y === null &&
        a_OR_k === null &&
        a === null) {
      _setStrokeColor_2(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num) &&
        a === null) {
      _setStrokeColor_3(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k);
      return;
    }
    if ((c_OR_color_OR_grayLevel_OR_r === null || c_OR_color_OR_grayLevel_OR_r is num)) {
      _setStrokeColor_4(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k, a);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _setStrokeColor(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m) native "CanvasRenderingContext2D_setStrokeColor_Callback";

  void _setStrokeColor_2(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m) native "CanvasRenderingContext2D_setStrokeColor_2_Callback";

  void _setStrokeColor_3(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k) native "CanvasRenderingContext2D_setStrokeColor_3_Callback";

  void _setStrokeColor_4(c_OR_color_OR_grayLevel_OR_r, alpha_OR_g_OR_m, b_OR_y, a_OR_k, a) native "CanvasRenderingContext2D_setStrokeColor_4_Callback";

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _setTransform(m11, m12, m21, m22, dx, dy);
    return;
  }

  void _setTransform(m11, m12, m21, m22, dx, dy) native "CanvasRenderingContext2D_setTransform_Callback";

  void stroke() {
    _stroke();
    return;
  }

  void _stroke() native "CanvasRenderingContext2D_stroke_Callback";

  void strokeRect(num x, num y, num width, num height, [num lineWidth = null]) {
    //
    // strokeRect(num x, num y, num width, num height)
    // strokeRect(num x, num y, num width, num height, [Optional] num lineWidth)
    //
    // -- reduced:
    // strokeRect(num x, num y, num width, num height, [Optional] num lineWidth)
    //
    _strokeRect(x, y, width, height, lineWidth);
    return;
  }

  void _strokeRect(x, y, width, height, lineWidth) native "CanvasRenderingContext2D_strokeRect_Callback";

  void strokeText(String text, num x, num y, [num maxWidth = null]) {
    //
    // strokeText(String text, num x, num y)
    // strokeText(String text, num x, num y, [Optional] num maxWidth)
    //
    // -- reduced:
    // strokeText(String text, num x, num y, [Optional] num maxWidth)
    //
    _strokeText(text, x, y, maxWidth);
    return;
  }

  void _strokeText(text, x, y, maxWidth) native "CanvasRenderingContext2D_strokeText_Callback";

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _transform(m11, m12, m21, m22, dx, dy);
    return;
  }

  void _transform(m11, m12, m21, m22, dx, dy) native "CanvasRenderingContext2D_transform_Callback";

  void translate(num tx, num ty) {
    _translate(tx, ty);
    return;
  }

  void _translate(tx, ty) native "CanvasRenderingContext2D_translate_Callback";

  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh) {
    return _webkitGetImageDataHD(sx, sy, sw, sh);
  }

  ImageData _webkitGetImageDataHD(sx, sy, sw, sh) native "CanvasRenderingContext2D_webkitGetImageDataHD_Callback";

  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) {
    //
    // webkitPutImageDataHD(ImageData imagedata, num dx, num dy)
    // webkitPutImageDataHD(ImageData imagedata, num dx, num dy, num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight)
    //
    if (dirtyX === null &&
        dirtyY === null &&
        dirtyWidth === null &&
        dirtyHeight === null) {
      _webkitPutImageDataHD(imagedata, dx, dy);
      return;
    }
    _webkitPutImageDataHD_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    return;
  }

  void _webkitPutImageDataHD(imagedata, dx, dy) native "CanvasRenderingContext2D_webkitPutImageDataHD_Callback";

  void _webkitPutImageDataHD_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native "CanvasRenderingContext2D_webkitPutImageDataHD_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CanvasRenderingContextDOMImpl extends _DOMWrapperBase implements CanvasRenderingContext {
  _CanvasRenderingContextDOMImpl();
  String get typeName() => "CanvasRenderingContext";

  CanvasElement get canvas() native "CanvasRenderingContext_canvas_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CharacterDataDOMImpl extends _NodeDOMImpl implements CharacterData {
  _CharacterDataDOMImpl();
  String get typeName() => "CharacterData";

  String get data() native "CharacterData_data_Getter";

  void set data(String) native "CharacterData_data_Setter";

  int get length() native "CharacterData_length_Getter";

  void appendData(String data) {
    _appendData(data);
    return;
  }

  void _appendData(data) native "CharacterData_appendData_Callback";

  void deleteData(int offset, int length) {
    _deleteData(offset, length);
    return;
  }

  void _deleteData(offset, length) native "CharacterData_deleteData_Callback";

  void insertData(int offset, String data) {
    _insertData(offset, data);
    return;
  }

  void _insertData(offset, data) native "CharacterData_insertData_Callback";

  void replaceData(int offset, int length, String data) {
    _replaceData(offset, length, data);
    return;
  }

  void _replaceData(offset, length, data) native "CharacterData_replaceData_Callback";

  String substringData(int offset, int length) {
    return _substringData(offset, length);
  }

  String _substringData(offset, length) native "CharacterData_substringData_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ClientRectDOMImpl extends _DOMWrapperBase implements ClientRect {
  _ClientRectDOMImpl();
  String get typeName() => "ClientRect";

  num get bottom() native "ClientRect_bottom_Getter";

  num get height() native "ClientRect_height_Getter";

  num get left() native "ClientRect_left_Getter";

  num get right() native "ClientRect_right_Getter";

  num get top() native "ClientRect_top_Getter";

  num get width() native "ClientRect_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ClientRectListDOMImpl extends _DOMWrapperBase implements ClientRectList {
  _ClientRectListDOMImpl();
  String get typeName() => "ClientRectList";

  int get length() native "ClientRectList_length_Getter";

  ClientRect item(int index) {
    return _item(index);
  }

  ClientRect _item(index) native "ClientRectList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ClipboardDOMImpl extends _DOMWrapperBase implements Clipboard {
  _ClipboardDOMImpl();
  String get typeName() => "Clipboard";

  String get dropEffect() native "Clipboard_dropEffect_Getter";

  void set dropEffect(String) native "Clipboard_dropEffect_Setter";

  String get effectAllowed() native "Clipboard_effectAllowed_Getter";

  void set effectAllowed(String) native "Clipboard_effectAllowed_Setter";

  FileList get files() native "Clipboard_files_Getter";

  DataTransferItemList get items() native "Clipboard_items_Getter";

  List get types() native "Clipboard_types_Getter";

  void clearData([String type = null]) native "Clipboard_clearData_Callback";

  String getData(String type) {
    return _getData(type);
  }

  String _getData(type) native "Clipboard_getData_Callback";

  bool setData(String type, String data) {
    return _setData(type, data);
  }

  bool _setData(type, data) native "Clipboard_setData_Callback";

  void setDragImage(ImageElement image, int x, int y) native "Clipboard_setDragImage_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CloseEventDOMImpl extends _EventDOMImpl implements CloseEvent {
  _CloseEventDOMImpl();
  String get typeName() => "CloseEvent";

  int get code() native "CloseEvent_code_Getter";

  String get reason() native "CloseEvent_reason_Getter";

  bool get wasClean() native "CloseEvent_wasClean_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CommentDOMImpl extends _CharacterDataDOMImpl implements Comment {
  _CommentDOMImpl();
  String get typeName() => "Comment";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CompositionEventDOMImpl extends _UIEventDOMImpl implements CompositionEvent {
  _CompositionEventDOMImpl();
  String get typeName() => "CompositionEvent";

  String get data() native "CompositionEvent_data_Getter";

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) {
    if ((viewArg === null || viewArg is Window)) {
      _initCompositionEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initCompositionEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg) native "CompositionEvent_initCompositionEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ConsoleDOMImpl extends _DOMWrapperBase implements Console {
  _ConsoleDOMImpl();
  String get typeName() => "Console";

  MemoryInfo get memory() native "Console_memory_Getter";

  List<ScriptProfile> get profiles() native "Console_profiles_Getter";

  void assertCondition(bool condition, Object arg) {
    _assertCondition(condition, arg);
    return;
  }

  void _assertCondition(condition, arg) native "Console_assertCondition_Callback";

  void count() {
    _count();
    return;
  }

  void _count() native "Console_count_Callback";

  void debug(Object arg) {
    _debug(arg);
    return;
  }

  void _debug(arg) native "Console_debug_Callback";

  void dir() {
    _dir();
    return;
  }

  void _dir() native "Console_dir_Callback";

  void dirxml() {
    _dirxml();
    return;
  }

  void _dirxml() native "Console_dirxml_Callback";

  void error(Object arg) {
    _error(arg);
    return;
  }

  void _error(arg) native "Console_error_Callback";

  void group(Object arg) {
    _group(arg);
    return;
  }

  void _group(arg) native "Console_group_Callback";

  void groupCollapsed(Object arg) {
    _groupCollapsed(arg);
    return;
  }

  void _groupCollapsed(arg) native "Console_groupCollapsed_Callback";

  void groupEnd() {
    _groupEnd();
    return;
  }

  void _groupEnd() native "Console_groupEnd_Callback";

  void info(Object arg) {
    _info(arg);
    return;
  }

  void _info(arg) native "Console_info_Callback";

  void log(Object arg) {
    _log(arg);
    return;
  }

  void _log(arg) native "Console_log_Callback";

  void markTimeline() {
    _markTimeline();
    return;
  }

  void _markTimeline() native "Console_markTimeline_Callback";

  void profile(String title) native "Console_profile_Callback";

  void profileEnd(String title) native "Console_profileEnd_Callback";

  void time(String title) {
    _time(title);
    return;
  }

  void _time(title) native "Console_time_Callback";

  void timeEnd(String title, Object arg) {
    _timeEnd(title, arg);
    return;
  }

  void _timeEnd(title, arg) native "Console_timeEnd_Callback";

  void timeStamp(Object arg) {
    _timeStamp(arg);
    return;
  }

  void _timeStamp(arg) native "Console_timeStamp_Callback";

  void trace(Object arg) {
    _trace(arg);
    return;
  }

  void _trace(arg) native "Console_trace_Callback";

  void warn(Object arg) {
    _warn(arg);
    return;
  }

  void _warn(arg) native "Console_warn_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ConvolverNodeDOMImpl extends _AudioNodeDOMImpl implements ConvolverNode {
  _ConvolverNodeDOMImpl();
  String get typeName() => "ConvolverNode";

  AudioBuffer get buffer() native "ConvolverNode_buffer_Getter";

  void set buffer(AudioBuffer) native "ConvolverNode_buffer_Setter";

  bool get normalize() native "ConvolverNode_normalize_Getter";

  void set normalize(bool) native "ConvolverNode_normalize_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CoordinatesDOMImpl extends _DOMWrapperBase implements Coordinates {
  _CoordinatesDOMImpl();
  String get typeName() => "Coordinates";

  num get accuracy() native "Coordinates_accuracy_Getter";

  num get altitude() native "Coordinates_altitude_Getter";

  num get altitudeAccuracy() native "Coordinates_altitudeAccuracy_Getter";

  num get heading() native "Coordinates_heading_Getter";

  num get latitude() native "Coordinates_latitude_Getter";

  num get longitude() native "Coordinates_longitude_Getter";

  num get speed() native "Coordinates_speed_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CounterDOMImpl extends _DOMWrapperBase implements Counter {
  _CounterDOMImpl();
  String get typeName() => "Counter";

  String get identifier() native "Counter_identifier_Getter";

  String get listStyle() native "Counter_listStyle_Getter";

  String get separator() native "Counter_separator_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CryptoDOMImpl extends _DOMWrapperBase implements Crypto {
  _CryptoDOMImpl();
  String get typeName() => "Crypto";

  void getRandomValues(ArrayBufferView array) {
    _getRandomValues(array);
    return;
  }

  void _getRandomValues(array) native "Crypto_getRandomValues_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _CustomEventDOMImpl extends _EventDOMImpl implements CustomEvent {
  _CustomEventDOMImpl();
  String get typeName() => "CustomEvent";

  Object get detail() native "CustomEvent_detail_Getter";

  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) {
    _initCustomEvent(typeArg, canBubbleArg, cancelableArg, detailArg);
    return;
  }

  void _initCustomEvent(typeArg, canBubbleArg, cancelableArg, detailArg) native "CustomEvent_initCustomEvent_Callback";

}

class _DOMApplicationCacheEventsImpl extends _EventsImpl implements DOMApplicationCacheEvents {
  _DOMApplicationCacheEventsImpl(_ptr) : super(_ptr);
  EventListenerList get cached() => _get('cached');
  EventListenerList get checking() => _get('checking');
  EventListenerList get downloading() => _get('downloading');
  EventListenerList get error() => _get('error');
  EventListenerList get noUpdate() => _get('noupdate');
  EventListenerList get obsolete() => _get('obsolete');
  EventListenerList get progress() => _get('progress');
  EventListenerList get updateReady() => _get('updateready');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMApplicationCacheDOMImpl extends _DOMWrapperBase implements DOMApplicationCache {
  _DOMApplicationCacheDOMImpl();
  String get typeName() => "DOMApplicationCache";
  _EventsImpl _on;

  _DOMApplicationCacheEventsImpl get on() {
    if (_on === null) _on = new _DOMApplicationCacheEventsImpl(this);
    return _on;
  }

  int get status() native "DOMApplicationCache_status_Getter";

  void abort() {
    _abort();
    return;
  }

  void _abort() native "DOMApplicationCache_abort_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "DOMApplicationCache_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "DOMApplicationCache_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "DOMApplicationCache_removeEventListener_Callback";

  void swapCache() {
    _swapCache();
    return;
  }

  void _swapCache() native "DOMApplicationCache_swapCache_Callback";

  void update() {
    _update();
    return;
  }

  void _update() native "DOMApplicationCache_update_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMExceptionDOMImpl extends _DOMWrapperBase implements DOMException {
  _DOMExceptionDOMImpl();
  String get typeName() => "DOMException";

  int get code() native "DOMException_code_Getter";

  String get message() native "DOMException_message_Getter";

  String get name() native "DOMException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "DOMException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMFileSystemDOMImpl extends _DOMWrapperBase implements DOMFileSystem {
  _DOMFileSystemDOMImpl();
  String get typeName() => "DOMFileSystem";

  String get name() native "DOMFileSystem_name_Getter";

  DirectoryEntry get root() native "DOMFileSystem_root_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMFileSystemSyncDOMImpl extends _DOMWrapperBase implements DOMFileSystemSync {
  _DOMFileSystemSyncDOMImpl();
  String get typeName() => "DOMFileSystemSync";

  String get name() native "DOMFileSystemSync_name_Getter";

  DirectoryEntrySync get root() native "DOMFileSystemSync_root_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMFormDataDOMImpl extends _DOMWrapperBase implements DOMFormData {
  _DOMFormDataDOMImpl();
  String get typeName() => "DOMFormData";

  void append(String name, String value, String filename) native "DOMFormData_append_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMImplementationDOMImpl extends _DOMWrapperBase implements DOMImplementation {
  _DOMImplementationDOMImpl();
  String get typeName() => "DOMImplementation";

  CSSStyleSheet createCSSStyleSheet(String title, String media) {
    return _createCSSStyleSheet(title, media);
  }

  CSSStyleSheet _createCSSStyleSheet(title, media) native "DOMImplementation_createCSSStyleSheet_Callback";

  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) {
    return _createDocument(namespaceURI, qualifiedName, doctype);
  }

  Document _createDocument(namespaceURI, qualifiedName, doctype) native "DOMImplementation_createDocument_Callback";

  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) {
    return _createDocumentType(qualifiedName, publicId, systemId);
  }

  DocumentType _createDocumentType(qualifiedName, publicId, systemId) native "DOMImplementation_createDocumentType_Callback";

  Document createHTMLDocument(String title) {
    return _createHTMLDocument(title);
  }

  Document _createHTMLDocument(title) native "DOMImplementation_createHTMLDocument_Callback";

  bool hasFeature(String feature, String version) {
    return _hasFeature(feature, version);
  }

  bool _hasFeature(feature, version) native "DOMImplementation_hasFeature_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMMimeTypeArrayDOMImpl extends _DOMWrapperBase implements DOMMimeTypeArray {
  _DOMMimeTypeArrayDOMImpl();
  String get typeName() => "DOMMimeTypeArray";

  int get length() native "DOMMimeTypeArray_length_Getter";

  DOMMimeType item(int index) {
    return _item(index);
  }

  DOMMimeType _item(index) native "DOMMimeTypeArray_item_Callback";

  DOMMimeType namedItem(String name) {
    return _namedItem(name);
  }

  DOMMimeType _namedItem(name) native "DOMMimeTypeArray_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMMimeTypeDOMImpl extends _DOMWrapperBase implements DOMMimeType {
  _DOMMimeTypeDOMImpl();
  String get typeName() => "DOMMimeType";

  String get description() native "DOMMimeType_description_Getter";

  DOMPlugin get enabledPlugin() native "DOMMimeType_enabledPlugin_Getter";

  String get suffixes() native "DOMMimeType_suffixes_Getter";

  String get type() native "DOMMimeType_type_Getter";

}
class _DOMParserFactoryProviderImpl {
  static _DOMParserDOMImpl createDOMParser()
      native "DOMParser_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMParserDOMImpl extends _DOMWrapperBase implements DOMParser {
  _DOMParserDOMImpl();
  String get typeName() => "DOMParser";

  Document parseFromString(String str, String contentType) {
    return _parseFromString(str, contentType);
  }

  Document _parseFromString(str, contentType) native "DOMParser_parseFromString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMPluginArrayDOMImpl extends _DOMWrapperBase implements DOMPluginArray {
  _DOMPluginArrayDOMImpl();
  String get typeName() => "DOMPluginArray";

  int get length() native "DOMPluginArray_length_Getter";

  DOMPlugin item(int index) {
    return _item(index);
  }

  DOMPlugin _item(index) native "DOMPluginArray_item_Callback";

  DOMPlugin namedItem(String name) {
    return _namedItem(name);
  }

  DOMPlugin _namedItem(name) native "DOMPluginArray_namedItem_Callback";

  void refresh(bool reload) {
    _refresh(reload);
    return;
  }

  void _refresh(reload) native "DOMPluginArray_refresh_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMPluginDOMImpl extends _DOMWrapperBase implements DOMPlugin {
  _DOMPluginDOMImpl();
  String get typeName() => "DOMPlugin";

  String get description() native "DOMPlugin_description_Getter";

  String get filename() native "DOMPlugin_filename_Getter";

  int get length() native "DOMPlugin_length_Getter";

  String get name() native "DOMPlugin_name_Getter";

  DOMMimeType item(int index) {
    return _item(index);
  }

  DOMMimeType _item(index) native "DOMPlugin_item_Callback";

  DOMMimeType namedItem(String name) {
    return _namedItem(name);
  }

  DOMMimeType _namedItem(name) native "DOMPlugin_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMSelectionDOMImpl extends _DOMWrapperBase implements DOMSelection {
  _DOMSelectionDOMImpl();
  String get typeName() => "DOMSelection";

  Node get anchorNode() native "DOMSelection_anchorNode_Getter";

  int get anchorOffset() native "DOMSelection_anchorOffset_Getter";

  Node get baseNode() native "DOMSelection_baseNode_Getter";

  int get baseOffset() native "DOMSelection_baseOffset_Getter";

  Node get extentNode() native "DOMSelection_extentNode_Getter";

  int get extentOffset() native "DOMSelection_extentOffset_Getter";

  Node get focusNode() native "DOMSelection_focusNode_Getter";

  int get focusOffset() native "DOMSelection_focusOffset_Getter";

  bool get isCollapsed() native "DOMSelection_isCollapsed_Getter";

  int get rangeCount() native "DOMSelection_rangeCount_Getter";

  String get type() native "DOMSelection_type_Getter";

  void addRange(Range range) {
    _addRange(range);
    return;
  }

  void _addRange(range) native "DOMSelection_addRange_Callback";

  void collapse(Node node, int index) {
    _collapse(node, index);
    return;
  }

  void _collapse(node, index) native "DOMSelection_collapse_Callback";

  void collapseToEnd() {
    _collapseToEnd();
    return;
  }

  void _collapseToEnd() native "DOMSelection_collapseToEnd_Callback";

  void collapseToStart() {
    _collapseToStart();
    return;
  }

  void _collapseToStart() native "DOMSelection_collapseToStart_Callback";

  bool containsNode(Node node, bool allowPartial) {
    return _containsNode(node, allowPartial);
  }

  bool _containsNode(node, allowPartial) native "DOMSelection_containsNode_Callback";

  void deleteFromDocument() {
    _deleteFromDocument();
    return;
  }

  void _deleteFromDocument() native "DOMSelection_deleteFromDocument_Callback";

  void empty() {
    _empty();
    return;
  }

  void _empty() native "DOMSelection_empty_Callback";

  void extend(Node node, int offset) {
    _extend(node, offset);
    return;
  }

  void _extend(node, offset) native "DOMSelection_extend_Callback";

  Range getRangeAt(int index) {
    return _getRangeAt(index);
  }

  Range _getRangeAt(index) native "DOMSelection_getRangeAt_Callback";

  void modify(String alter, String direction, String granularity) {
    _modify(alter, direction, granularity);
    return;
  }

  void _modify(alter, direction, granularity) native "DOMSelection_modify_Callback";

  void removeAllRanges() {
    _removeAllRanges();
    return;
  }

  void _removeAllRanges() native "DOMSelection_removeAllRanges_Callback";

  void selectAllChildren(Node node) {
    _selectAllChildren(node);
    return;
  }

  void _selectAllChildren(node) native "DOMSelection_selectAllChildren_Callback";

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) {
    _setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset);
    return;
  }

  void _setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset) native "DOMSelection_setBaseAndExtent_Callback";

  void setPosition(Node node, int offset) {
    _setPosition(node, offset);
    return;
  }

  void _setPosition(node, offset) native "DOMSelection_setPosition_Callback";

  String toString() {
    return _toString();
  }

  String _toString() native "DOMSelection_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMSettableTokenListDOMImpl extends _DOMTokenListDOMImpl implements DOMSettableTokenList {
  _DOMSettableTokenListDOMImpl();
  String get typeName() => "DOMSettableTokenList";

  String get value() native "DOMSettableTokenList_value_Getter";

  void set value(String) native "DOMSettableTokenList_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMStringListDOMImpl extends _DOMWrapperBase implements DOMStringList {
  _DOMStringListDOMImpl();
  String get typeName() => "DOMStringList";

  int get length() native "DOMStringList_length_Getter";

  String operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(String element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(String element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  String last() {
    return this[length - 1];
  }

  void forEach(void f(String element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(String element)) {
    return _Collections.map(this, [], f);
  }

  Collection<String> filter(bool f(String element)) {
    return _Collections.filter(this, new List<String>(), f);
  }

  bool every(bool f(String element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(String element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<String> iterator() {
    return new _FixedSizeListIterator<String>(this);
  }

  bool contains(String string) {
    return _contains(string);
  }

  bool _contains(string) native "DOMStringList_contains_Callback";

  String item(int index) {
    return _item(index);
  }

  String _item(index) native "DOMStringList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMTokenListDOMImpl extends _DOMWrapperBase implements DOMTokenList {
  _DOMTokenListDOMImpl();
  String get typeName() => "DOMTokenList";

  int get length() native "DOMTokenList_length_Getter";

  void add(String token) {
    _add(token);
    return;
  }

  void _add(token) native "DOMTokenList_add_Callback";

  bool contains(String token) {
    return _contains(token);
  }

  bool _contains(token) native "DOMTokenList_contains_Callback";

  String item(int index) {
    return _item(index);
  }

  String _item(index) native "DOMTokenList_item_Callback";

  void remove(String token) {
    _remove(token);
    return;
  }

  void _remove(token) native "DOMTokenList_remove_Callback";

  String toString() {
    return _toString();
  }

  String _toString() native "DOMTokenList_toString_Callback";

  bool toggle(String token) {
    return _toggle(token);
  }

  bool _toggle(token) native "DOMTokenList_toggle_Callback";

}
class _DOMURLFactoryProviderImpl {
  static _DOMURLDOMImpl createDOMURL()
      native "DOMURL_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMURLDOMImpl extends _DOMWrapperBase implements DOMURL {
  _DOMURLDOMImpl();
  String get typeName() => "DOMURL";

  static String createObjectURL(blob_OR_stream) {
    //
    // createObjectURL(MediaStream stream)
    // createObjectURL(Blob blob)
    //
    if ((blob_OR_stream === null || blob_OR_stream is MediaStream)) {
      return _createObjectURL(blob_OR_stream);
    }
    if ((blob_OR_stream === null || blob_OR_stream is Blob)) {
      return _createObjectURL_2(blob_OR_stream);
    }
    throw "Incorrect number or type of arguments";
  }

  static String _createObjectURL(blob_OR_stream) native "DOMURL_createObjectURL_Callback";

  static String _createObjectURL_2(blob_OR_stream) native "DOMURL_createObjectURL_2_Callback";

  static void revokeObjectURL(String url) {
    _revokeObjectURL(url);
    return;
  }

  static void _revokeObjectURL(url) native "DOMURL_revokeObjectURL_Callback";

}

class _DOMWindowEventsImpl extends _EventsImpl implements WindowEvents {
  _DOMWindowEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get animationEnd() => _get('webkitAnimationEnd');
  EventListenerList get animationIteration() => _get('webkitAnimationIteration');
  EventListenerList get animationStart() => _get('webkitAnimationStart');
  EventListenerList get beforeUnload() => _get('beforeunload');
  EventListenerList get blur() => _get('blur');
  EventListenerList get canPlay() => _get('canplay');
  EventListenerList get canPlayThrough() => _get('canplaythrough');
  EventListenerList get change() => _get('change');
  EventListenerList get click() => _get('click');
  EventListenerList get contextMenu() => _get('contextmenu');
  EventListenerList get deviceMotion() => _get('devicemotion');
  EventListenerList get deviceOrientation() => _get('deviceorientation');
  EventListenerList get doubleClick() => _get('dblclick');
  EventListenerList get drag() => _get('drag');
  EventListenerList get dragEnd() => _get('dragend');
  EventListenerList get dragEnter() => _get('dragenter');
  EventListenerList get dragLeave() => _get('dragleave');
  EventListenerList get dragOver() => _get('dragover');
  EventListenerList get dragStart() => _get('dragstart');
  EventListenerList get drop() => _get('drop');
  EventListenerList get durationChange() => _get('durationchange');
  EventListenerList get emptied() => _get('emptied');
  EventListenerList get ended() => _get('ended');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get hashChange() => _get('hashchange');
  EventListenerList get input() => _get('input');
  EventListenerList get invalid() => _get('invalid');
  EventListenerList get keyDown() => _get('keydown');
  EventListenerList get keyPress() => _get('keypress');
  EventListenerList get keyUp() => _get('keyup');
  EventListenerList get load() => _get('load');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get loadedData() => _get('loadeddata');
  EventListenerList get loadedMetadata() => _get('loadedmetadata');
  EventListenerList get message() => _get('message');
  EventListenerList get mouseDown() => _get('mousedown');
  EventListenerList get mouseMove() => _get('mousemove');
  EventListenerList get mouseOut() => _get('mouseout');
  EventListenerList get mouseOver() => _get('mouseover');
  EventListenerList get mouseUp() => _get('mouseup');
  EventListenerList get mouseWheel() => _get('mousewheel');
  EventListenerList get offline() => _get('offline');
  EventListenerList get online() => _get('online');
  EventListenerList get pageHide() => _get('pagehide');
  EventListenerList get pageShow() => _get('pageshow');
  EventListenerList get pause() => _get('pause');
  EventListenerList get play() => _get('play');
  EventListenerList get playing() => _get('playing');
  EventListenerList get popState() => _get('popstate');
  EventListenerList get progress() => _get('progress');
  EventListenerList get rateChange() => _get('ratechange');
  EventListenerList get reset() => _get('reset');
  EventListenerList get resize() => _get('resize');
  EventListenerList get scroll() => _get('scroll');
  EventListenerList get search() => _get('search');
  EventListenerList get seeked() => _get('seeked');
  EventListenerList get seeking() => _get('seeking');
  EventListenerList get select() => _get('select');
  EventListenerList get stalled() => _get('stalled');
  EventListenerList get storage() => _get('storage');
  EventListenerList get submit() => _get('submit');
  EventListenerList get suspend() => _get('suspend');
  EventListenerList get timeUpdate() => _get('timeupdate');
  EventListenerList get touchCancel() => _get('touchcancel');
  EventListenerList get touchEnd() => _get('touchend');
  EventListenerList get touchMove() => _get('touchmove');
  EventListenerList get touchStart() => _get('touchstart');
  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');
  EventListenerList get unload() => _get('unload');
  EventListenerList get volumeChange() => _get('volumechange');
  EventListenerList get waiting() => _get('waiting');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DOMWindowDOMImpl extends _DOMWrapperBase implements Window {
  _DOMWindowDOMImpl();
  String get typeName() => "DOMWindow";
  _EventsImpl _on;

  _DOMWindowEventsImpl get on() {
    if (_on === null) _on = new _DOMWindowEventsImpl(this);
    return _on;
  }

  DOMApplicationCache get applicationCache() native "DOMWindow_applicationCache_Getter";

  Navigator get clientInformation() native "DOMWindow_clientInformation_Getter";

  bool get closed() native "DOMWindow_closed_Getter";

  Console get console() native "DOMWindow_console_Getter";

  Crypto get crypto() native "DOMWindow_crypto_Getter";

  String get defaultStatus() native "DOMWindow_defaultStatus_Getter";

  void set defaultStatus(String) native "DOMWindow_defaultStatus_Setter";

  String get defaultstatus() native "DOMWindow_defaultstatus_Getter";

  void set defaultstatus(String) native "DOMWindow_defaultstatus_Setter";

  num get devicePixelRatio() native "DOMWindow_devicePixelRatio_Getter";

  Document get document() native "DOMWindow_document_Getter";

  Event get event() native "DOMWindow_event_Getter";

  Window get frames() native "DOMWindow_frames_Getter";

  History get history() native "DOMWindow_history_Getter";

  int get innerHeight() native "DOMWindow_innerHeight_Getter";

  int get innerWidth() native "DOMWindow_innerWidth_Getter";

  int get length() native "DOMWindow_length_Getter";

  Storage get localStorage() native "DOMWindow_localStorage_Getter";

  Location get location() native "DOMWindow_location_Getter";

  void set location(Location) native "DOMWindow_location_Setter";

  BarInfo get locationbar() native "DOMWindow_locationbar_Getter";

  BarInfo get menubar() native "DOMWindow_menubar_Getter";

  String get name() native "DOMWindow_name_Getter";

  void set name(String) native "DOMWindow_name_Setter";

  Navigator get navigator() native "DOMWindow_navigator_Getter";

  bool get offscreenBuffering() native "DOMWindow_offscreenBuffering_Getter";

  Window get opener() native "DOMWindow_opener_Getter";

  int get outerHeight() native "DOMWindow_outerHeight_Getter";

  int get outerWidth() native "DOMWindow_outerWidth_Getter";

  int get pageXOffset() native "DOMWindow_pageXOffset_Getter";

  int get pageYOffset() native "DOMWindow_pageYOffset_Getter";

  Window get parent() native "DOMWindow_parent_Getter";

  Performance get performance() native "DOMWindow_performance_Getter";

  BarInfo get personalbar() native "DOMWindow_personalbar_Getter";

  Screen get screen() native "DOMWindow_screen_Getter";

  int get screenLeft() native "DOMWindow_screenLeft_Getter";

  int get screenTop() native "DOMWindow_screenTop_Getter";

  int get screenX() native "DOMWindow_screenX_Getter";

  int get screenY() native "DOMWindow_screenY_Getter";

  int get scrollX() native "DOMWindow_scrollX_Getter";

  int get scrollY() native "DOMWindow_scrollY_Getter";

  BarInfo get scrollbars() native "DOMWindow_scrollbars_Getter";

  Window get self() native "DOMWindow_self_Getter";

  Storage get sessionStorage() native "DOMWindow_sessionStorage_Getter";

  String get status() native "DOMWindow_status_Getter";

  void set status(String) native "DOMWindow_status_Setter";

  BarInfo get statusbar() native "DOMWindow_statusbar_Getter";

  StyleMedia get styleMedia() native "DOMWindow_styleMedia_Getter";

  BarInfo get toolbar() native "DOMWindow_toolbar_Getter";

  Window get top() native "DOMWindow_top_Getter";

  IDBFactory get webkitIndexedDB() native "DOMWindow_webkitIndexedDB_Getter";

  NotificationCenter get webkitNotifications() native "DOMWindow_webkitNotifications_Getter";

  StorageInfo get webkitStorageInfo() native "DOMWindow_webkitStorageInfo_Getter";

  Window get window() native "DOMWindow_window_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) native "DOMWindow_addEventListener_Callback";

  void alert(String message) {
    _alert(message);
    return;
  }

  void _alert(message) native "DOMWindow_alert_Callback";

  String atob(String string) {
    return _atob(string);
  }

  String _atob(string) native "DOMWindow_atob_Callback";

  void blur() {
    _blur();
    return;
  }

  void _blur() native "DOMWindow_blur_Callback";

  String btoa(String string) {
    return _btoa(string);
  }

  String _btoa(string) native "DOMWindow_btoa_Callback";

  void captureEvents() {
    _captureEvents();
    return;
  }

  void _captureEvents() native "DOMWindow_captureEvents_Callback";

  void clearInterval(int handle) {
    _clearInterval(handle);
    return;
  }

  void _clearInterval(handle) native "DOMWindow_clearInterval_Callback";

  void clearTimeout(int handle) {
    _clearTimeout(handle);
    return;
  }

  void _clearTimeout(handle) native "DOMWindow_clearTimeout_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "DOMWindow_close_Callback";

  bool confirm(String message) {
    return _confirm(message);
  }

  bool _confirm(message) native "DOMWindow_confirm_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "DOMWindow_dispatchEvent_Callback";

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) {
    return _find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog);
  }

  bool _find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog) native "DOMWindow_find_Callback";

  void focus() {
    _focus();
    return;
  }

  void _focus() native "DOMWindow_focus_Callback";

  CSSStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement) {
    return _getComputedStyle(element, pseudoElement);
  }

  CSSStyleDeclaration _getComputedStyle(element, pseudoElement) native "DOMWindow_getComputedStyle_Callback";

  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement) {
    return _getMatchedCSSRules(element, pseudoElement);
  }

  CSSRuleList _getMatchedCSSRules(element, pseudoElement) native "DOMWindow_getMatchedCSSRules_Callback";

  DOMSelection getSelection() {
    return _getSelection();
  }

  DOMSelection _getSelection() native "DOMWindow_getSelection_Callback";

  MediaQueryList matchMedia(String query) {
    return _matchMedia(query);
  }

  MediaQueryList _matchMedia(query) native "DOMWindow_matchMedia_Callback";

  void moveBy(num x, num y) {
    _moveBy(x, y);
    return;
  }

  void _moveBy(x, y) native "DOMWindow_moveBy_Callback";

  void moveTo(num x, num y) {
    _moveTo(x, y);
    return;
  }

  void _moveTo(x, y) native "DOMWindow_moveTo_Callback";

  Window open(String url, String name, [String options = null]) native "DOMWindow_open_Callback";

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    return _openDatabase(name, version, displayName, estimatedSize, creationCallback);
  }

  Database _openDatabase(name, version, displayName, estimatedSize, creationCallback) native "DOMWindow_openDatabase_Callback";

  void postMessage(message, String targetOrigin, [List messagePorts = null]) native "DOMWindow_postMessage_Callback";

  void print() {
    _print();
    return;
  }

  void _print() native "DOMWindow_print_Callback";

  String prompt(String message, String defaultValue) {
    return _prompt(message, defaultValue);
  }

  String _prompt(message, defaultValue) native "DOMWindow_prompt_Callback";

  void releaseEvents() {
    _releaseEvents();
    return;
  }

  void _releaseEvents() native "DOMWindow_releaseEvents_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) native "DOMWindow_removeEventListener_Callback";

  void resizeBy(num x, num y) {
    _resizeBy(x, y);
    return;
  }

  void _resizeBy(x, y) native "DOMWindow_resizeBy_Callback";

  void resizeTo(num width, num height) {
    _resizeTo(width, height);
    return;
  }

  void _resizeTo(width, height) native "DOMWindow_resizeTo_Callback";

  void scroll(int x, int y) {
    _scroll(x, y);
    return;
  }

  void _scroll(x, y) native "DOMWindow_scroll_Callback";

  void scrollBy(int x, int y) {
    _scrollBy(x, y);
    return;
  }

  void _scrollBy(x, y) native "DOMWindow_scrollBy_Callback";

  void scrollTo(int x, int y) {
    _scrollTo(x, y);
    return;
  }

  void _scrollTo(x, y) native "DOMWindow_scrollTo_Callback";

  int setInterval(TimeoutHandler handler, int timeout) native "DOMWindow_setInterval_Callback";

  int setTimeout(TimeoutHandler handler, int timeout) native "DOMWindow_setTimeout_Callback";

  Object showModalDialog(String url, [Object dialogArgs = null, String featureArgs = null]) native "DOMWindow_showModalDialog_Callback";

  void stop() {
    _stop();
    return;
  }

  void _stop() native "DOMWindow_stop_Callback";

  void webkitCancelAnimationFrame(int id) {
    _webkitCancelAnimationFrame(id);
    return;
  }

  void _webkitCancelAnimationFrame(id) native "DOMWindow_webkitCancelAnimationFrame_Callback";

  void webkitCancelRequestAnimationFrame(int id) {
    _webkitCancelRequestAnimationFrame(id);
    return;
  }

  void _webkitCancelRequestAnimationFrame(id) native "DOMWindow_webkitCancelRequestAnimationFrame_Callback";

  Point webkitConvertPointFromNodeToPage(Node node, Point p) {
    if ((p === null || p is Point)) {
      return _webkitConvertPointFromNodeToPage(node, p);
    }
    throw "Incorrect number or type of arguments";
  }

  Point _webkitConvertPointFromNodeToPage(node, p) native "DOMWindow_webkitConvertPointFromNodeToPage_Callback";

  Point webkitConvertPointFromPageToNode(Node node, Point p) {
    if ((p === null || p is Point)) {
      return _webkitConvertPointFromPageToNode(node, p);
    }
    throw "Incorrect number or type of arguments";
  }

  Point _webkitConvertPointFromPageToNode(node, p) native "DOMWindow_webkitConvertPointFromPageToNode_Callback";

  void webkitPostMessage(message, String targetOrigin, [List transferList = null]) native "DOMWindow_webkitPostMessage_Callback";

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback) {
    return _webkitRequestAnimationFrame(callback);
  }

  int _webkitRequestAnimationFrame(callback) native "DOMWindow_webkitRequestAnimationFrame_Callback";

  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback = null]) {
    _webkitRequestFileSystem(type, size, successCallback, errorCallback);
    return;
  }

  void _webkitRequestFileSystem(type, size, successCallback, errorCallback) native "DOMWindow_webkitRequestFileSystem_Callback";

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    _webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    return;
  }

  void _webkitResolveLocalFileSystemURL(url, successCallback, errorCallback) native "DOMWindow_webkitResolveLocalFileSystemURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DataTransferItemDOMImpl extends _DOMWrapperBase implements DataTransferItem {
  _DataTransferItemDOMImpl();
  String get typeName() => "DataTransferItem";

  String get kind() native "DataTransferItem_kind_Getter";

  String get type() native "DataTransferItem_type_Getter";

  Blob getAsFile() {
    return _getAsFile();
  }

  Blob _getAsFile() native "DataTransferItem_getAsFile_Callback";

  void getAsString([StringCallback callback = null]) {
    _getAsString(callback);
    return;
  }

  void _getAsString(callback) native "DataTransferItem_getAsString_Callback";

  void webkitGetAsEntry([EntryCallback callback = null]) {
    _webkitGetAsEntry(callback);
    return;
  }

  void _webkitGetAsEntry(callback) native "DataTransferItem_webkitGetAsEntry_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DataTransferItemListDOMImpl extends _DOMWrapperBase implements DataTransferItemList {
  _DataTransferItemListDOMImpl();
  String get typeName() => "DataTransferItemList";

  int get length() native "DataTransferItemList_length_Getter";

  void add(data_OR_file, [String type = null]) {
    //
    // add(File file)
    // add(String data, String type)
    //
    if ((data_OR_file === null || data_OR_file is File) && type === null) {
      _add(data_OR_file);
      return;
    }
    if ((data_OR_file === null || data_OR_file is String)) {
      _add_2(data_OR_file, type);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _add(data_OR_file) native "DataTransferItemList_add_Callback";

  void _add_2(data_OR_file, type) native "DataTransferItemList_add_2_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "DataTransferItemList_clear_Callback";

  DataTransferItem item(int index) {
    return _item(index);
  }

  DataTransferItem _item(index) native "DataTransferItemList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DataViewDOMImpl extends _ArrayBufferViewDOMImpl implements DataView {
  _DataViewDOMImpl();
  String get typeName() => "DataView";

  num getFloat32(int byteOffset, [bool littleEndian = null]) {
    //
    // getFloat32(int byteOffset)
    // getFloat32(int byteOffset, [Optional] bool littleEndian)
    //
    // -- reduced:
    // getFloat32(int byteOffset, [Optional] bool littleEndian)
    //
    return _getFloat32(byteOffset, littleEndian);
  }

  num _getFloat32(byteOffset, littleEndian) native "DataView_getFloat32_Callback";

  num getFloat64(int byteOffset, [bool littleEndian = null]) {
    //
    // getFloat64(int byteOffset)
    // getFloat64(int byteOffset, [Optional] bool littleEndian)
    //
    // -- reduced:
    // getFloat64(int byteOffset, [Optional] bool littleEndian)
    //
    return _getFloat64(byteOffset, littleEndian);
  }

  num _getFloat64(byteOffset, littleEndian) native "DataView_getFloat64_Callback";

  int getInt16(int byteOffset, [bool littleEndian = null]) {
    //
    // getInt16(int byteOffset)
    // getInt16(int byteOffset, [Optional] bool littleEndian)
    //
    // -- reduced:
    // getInt16(int byteOffset, [Optional] bool littleEndian)
    //
    return _getInt16(byteOffset, littleEndian);
  }

  int _getInt16(byteOffset, littleEndian) native "DataView_getInt16_Callback";

  int getInt32(int byteOffset, [bool littleEndian = null]) {
    //
    // getInt32(int byteOffset)
    // getInt32(int byteOffset, [Optional] bool littleEndian)
    //
    // -- reduced:
    // getInt32(int byteOffset, [Optional] bool littleEndian)
    //
    return _getInt32(byteOffset, littleEndian);
  }

  int _getInt32(byteOffset, littleEndian) native "DataView_getInt32_Callback";

  Object getInt8() native "DataView_getInt8_Callback";

  int getUint16(int byteOffset, [bool littleEndian = null]) {
    //
    // getUint16(int byteOffset)
    // getUint16(int byteOffset, [Optional] bool littleEndian)
    //
    // -- reduced:
    // getUint16(int byteOffset, [Optional] bool littleEndian)
    //
    return _getUint16(byteOffset, littleEndian);
  }

  int _getUint16(byteOffset, littleEndian) native "DataView_getUint16_Callback";

  int getUint32(int byteOffset, [bool littleEndian = null]) {
    //
    // getUint32(int byteOffset)
    // getUint32(int byteOffset, [Optional] bool littleEndian)
    //
    // -- reduced:
    // getUint32(int byteOffset, [Optional] bool littleEndian)
    //
    return _getUint32(byteOffset, littleEndian);
  }

  int _getUint32(byteOffset, littleEndian) native "DataView_getUint32_Callback";

  Object getUint8() native "DataView_getUint8_Callback";

  void setFloat32(int byteOffset, num value, [bool littleEndian = null]) {
    //
    // setFloat32(int byteOffset, num value)
    // setFloat32(int byteOffset, num value, [Optional] bool littleEndian)
    //
    // -- reduced:
    // setFloat32(int byteOffset, num value, [Optional] bool littleEndian)
    //
    _setFloat32(byteOffset, value, littleEndian);
    return;
  }

  void _setFloat32(byteOffset, value, littleEndian) native "DataView_setFloat32_Callback";

  void setFloat64(int byteOffset, num value, [bool littleEndian = null]) {
    //
    // setFloat64(int byteOffset, num value)
    // setFloat64(int byteOffset, num value, [Optional] bool littleEndian)
    //
    // -- reduced:
    // setFloat64(int byteOffset, num value, [Optional] bool littleEndian)
    //
    _setFloat64(byteOffset, value, littleEndian);
    return;
  }

  void _setFloat64(byteOffset, value, littleEndian) native "DataView_setFloat64_Callback";

  void setInt16(int byteOffset, int value, [bool littleEndian = null]) {
    //
    // setInt16(int byteOffset, int value)
    // setInt16(int byteOffset, int value, [Optional] bool littleEndian)
    //
    // -- reduced:
    // setInt16(int byteOffset, int value, [Optional] bool littleEndian)
    //
    _setInt16(byteOffset, value, littleEndian);
    return;
  }

  void _setInt16(byteOffset, value, littleEndian) native "DataView_setInt16_Callback";

  void setInt32(int byteOffset, int value, [bool littleEndian = null]) {
    //
    // setInt32(int byteOffset, int value)
    // setInt32(int byteOffset, int value, [Optional] bool littleEndian)
    //
    // -- reduced:
    // setInt32(int byteOffset, int value, [Optional] bool littleEndian)
    //
    _setInt32(byteOffset, value, littleEndian);
    return;
  }

  void _setInt32(byteOffset, value, littleEndian) native "DataView_setInt32_Callback";

  void setInt8() native "DataView_setInt8_Callback";

  void setUint16(int byteOffset, int value, [bool littleEndian = null]) {
    //
    // setUint16(int byteOffset, int value)
    // setUint16(int byteOffset, int value, [Optional] bool littleEndian)
    //
    // -- reduced:
    // setUint16(int byteOffset, int value, [Optional] bool littleEndian)
    //
    _setUint16(byteOffset, value, littleEndian);
    return;
  }

  void _setUint16(byteOffset, value, littleEndian) native "DataView_setUint16_Callback";

  void setUint32(int byteOffset, int value, [bool littleEndian = null]) {
    //
    // setUint32(int byteOffset, int value)
    // setUint32(int byteOffset, int value, [Optional] bool littleEndian)
    //
    // -- reduced:
    // setUint32(int byteOffset, int value, [Optional] bool littleEndian)
    //
    _setUint32(byteOffset, value, littleEndian);
    return;
  }

  void _setUint32(byteOffset, value, littleEndian) native "DataView_setUint32_Callback";

  void setUint8() native "DataView_setUint8_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DatabaseDOMImpl extends _DOMWrapperBase implements Database {
  _DatabaseDOMImpl();
  String get typeName() => "Database";

  String get version() native "Database_version_Getter";

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback = null, SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    _changeVersion(oldVersion, newVersion, callback, errorCallback, successCallback);
    return;
  }

  void _changeVersion(oldVersion, newVersion, callback, errorCallback, successCallback) native "Database_changeVersion_Callback";

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    _readTransaction(callback, errorCallback, successCallback);
    return;
  }

  void _readTransaction(callback, errorCallback, successCallback) native "Database_readTransaction_Callback";

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    _transaction(callback, errorCallback, successCallback);
    return;
  }

  void _transaction(callback, errorCallback, successCallback) native "Database_transaction_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DatabaseSyncDOMImpl extends _DOMWrapperBase implements DatabaseSync {
  _DatabaseSyncDOMImpl();
  String get typeName() => "DatabaseSync";

  String get lastErrorMessage() native "DatabaseSync_lastErrorMessage_Getter";

  String get version() native "DatabaseSync_version_Getter";

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback = null]) {
    _changeVersion(oldVersion, newVersion, callback);
    return;
  }

  void _changeVersion(oldVersion, newVersion, callback) native "DatabaseSync_changeVersion_Callback";

  void readTransaction(SQLTransactionSyncCallback callback) {
    _readTransaction(callback);
    return;
  }

  void _readTransaction(callback) native "DatabaseSync_readTransaction_Callback";

  void transaction(SQLTransactionSyncCallback callback) {
    _transaction(callback);
    return;
  }

  void _transaction(callback) native "DatabaseSync_transaction_Callback";

}

class _DedicatedWorkerContextEventsImpl extends _WorkerContextEventsImpl implements DedicatedWorkerContextEvents {
  _DedicatedWorkerContextEventsImpl(_ptr) : super(_ptr);
  EventListenerList get message() => _get('message');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DedicatedWorkerContextDOMImpl extends _WorkerContextDOMImpl implements DedicatedWorkerContext {
  _DedicatedWorkerContextDOMImpl();
  String get typeName() => "DedicatedWorkerContext";

  _DedicatedWorkerContextEventsImpl get on() {
    if (_on === null) _on = new _DedicatedWorkerContextEventsImpl(this);
    return _on;
  }

  void postMessage(Object message, [List messagePorts = null]) native "DedicatedWorkerContext_postMessage_Callback";

  void webkitPostMessage(Object message, [List transferList = null]) native "DedicatedWorkerContext_webkitPostMessage_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DelayNodeDOMImpl extends _AudioNodeDOMImpl implements DelayNode {
  _DelayNodeDOMImpl();
  String get typeName() => "DelayNode";

  AudioParam get delayTime() native "DelayNode_delayTime_Getter";

}
class _DeprecatedPeerConnectionFactoryProviderImpl {
  static _DeprecatedPeerConnectionDOMImpl createDeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback)
      native "DeprecatedPeerConnection_constructor_Callback";
}
class _DeprecatedPeerConnectionEventsImpl extends _EventsImpl implements DeprecatedPeerConnectionEvents {
  _DeprecatedPeerConnectionEventsImpl(_ptr) : super(_ptr);
  EventListenerList get addStream() => _get('addstream');
  EventListenerList get connecting() => _get('connecting');
  EventListenerList get message() => _get('message');
  EventListenerList get open() => _get('open');
  EventListenerList get removeStream() => _get('removestream');
  EventListenerList get stateChange() => _get('statechange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DeprecatedPeerConnectionDOMImpl extends _DOMWrapperBase implements DeprecatedPeerConnection {
  _DeprecatedPeerConnectionDOMImpl();
  String get typeName() => "DeprecatedPeerConnection";
  _EventsImpl _on;

  _DeprecatedPeerConnectionEventsImpl get on() {
    if (_on === null) _on = new _DeprecatedPeerConnectionEventsImpl(this);
    return _on;
  }

  MediaStreamList get localStreams() native "DeprecatedPeerConnection_localStreams_Getter";

  int get readyState() native "DeprecatedPeerConnection_readyState_Getter";

  MediaStreamList get remoteStreams() native "DeprecatedPeerConnection_remoteStreams_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "DeprecatedPeerConnection_addEventListener_Callback";

  void addStream(MediaStream stream) {
    _addStream(stream);
    return;
  }

  void _addStream(stream) native "DeprecatedPeerConnection_addStream_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "DeprecatedPeerConnection_close_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "DeprecatedPeerConnection_dispatchEvent_Callback";

  void processSignalingMessage(String message) {
    _processSignalingMessage(message);
    return;
  }

  void _processSignalingMessage(message) native "DeprecatedPeerConnection_processSignalingMessage_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "DeprecatedPeerConnection_removeEventListener_Callback";

  void removeStream(MediaStream stream) {
    _removeStream(stream);
    return;
  }

  void _removeStream(stream) native "DeprecatedPeerConnection_removeStream_Callback";

  void send(String text) {
    _send(text);
    return;
  }

  void _send(text) native "DeprecatedPeerConnection_send_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DeviceMotionEventDOMImpl extends _EventDOMImpl implements DeviceMotionEvent {
  _DeviceMotionEventDOMImpl();
  String get typeName() => "DeviceMotionEvent";

  num get interval() native "DeviceMotionEvent_interval_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DeviceOrientationEventDOMImpl extends _EventDOMImpl implements DeviceOrientationEvent {
  _DeviceOrientationEventDOMImpl();
  String get typeName() => "DeviceOrientationEvent";

  bool get absolute() native "DeviceOrientationEvent_absolute_Getter";

  num get alpha() native "DeviceOrientationEvent_alpha_Getter";

  num get beta() native "DeviceOrientationEvent_beta_Getter";

  num get gamma() native "DeviceOrientationEvent_gamma_Getter";

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) native "DeviceOrientationEvent_initDeviceOrientationEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DirectoryEntryDOMImpl extends _EntryDOMImpl implements DirectoryEntry {
  _DirectoryEntryDOMImpl();
  String get typeName() => "DirectoryEntry";

  DirectoryReader createReader() {
    return _createReader();
  }

  DirectoryReader _createReader() native "DirectoryEntry_createReader_Callback";

  void getDirectory(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native "DirectoryEntry_getDirectory_Callback";

  void getFile(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) native "DirectoryEntry_getFile_Callback";

  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback = null]) {
    _removeRecursively(successCallback, errorCallback);
    return;
  }

  void _removeRecursively(successCallback, errorCallback) native "DirectoryEntry_removeRecursively_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DirectoryEntrySyncDOMImpl extends _EntrySyncDOMImpl implements DirectoryEntrySync {
  _DirectoryEntrySyncDOMImpl();
  String get typeName() => "DirectoryEntrySync";

  DirectoryReaderSync createReader() {
    return _createReader();
  }

  DirectoryReaderSync _createReader() native "DirectoryEntrySync_createReader_Callback";

  DirectoryEntrySync getDirectory(String path, Object flags) native "DirectoryEntrySync_getDirectory_Callback";

  FileEntrySync getFile(String path, Object flags) native "DirectoryEntrySync_getFile_Callback";

  void removeRecursively() {
    _removeRecursively();
    return;
  }

  void _removeRecursively() native "DirectoryEntrySync_removeRecursively_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DirectoryReaderDOMImpl extends _DOMWrapperBase implements DirectoryReader {
  _DirectoryReaderDOMImpl();
  String get typeName() => "DirectoryReader";

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback = null]) {
    _readEntries(successCallback, errorCallback);
    return;
  }

  void _readEntries(successCallback, errorCallback) native "DirectoryReader_readEntries_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DirectoryReaderSyncDOMImpl extends _DOMWrapperBase implements DirectoryReaderSync {
  _DirectoryReaderSyncDOMImpl();
  String get typeName() => "DirectoryReaderSync";

  EntryArraySync readEntries() {
    return _readEntries();
  }

  EntryArraySync _readEntries() native "DirectoryReaderSync_readEntries_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DocumentFragmentDOMImpl extends _NodeDOMImpl implements DocumentFragment {
  _DocumentFragmentDOMImpl();
  String get typeName() => "DocumentFragment";

  _ElementEventsImpl get on() {
    if (_on === null) _on = new _ElementEventsImpl(this);
    return _on;
  }

  Element query(String selectors) {
    return _querySelector(selectors);
  }

  Element _querySelector(selectors) native "DocumentFragment_querySelector_Callback";

  NodeList $dom_querySelectorAll(String selectors) {
    return _querySelectorAll(selectors);
  }

  NodeList _querySelectorAll(selectors) native "DocumentFragment_querySelectorAll_Callback";

}

class _DocumentEventsImpl extends _EventsImpl implements DocumentEvents {
  _DocumentEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get beforeCopy() => _get('beforecopy');
  EventListenerList get beforeCut() => _get('beforecut');
  EventListenerList get beforePaste() => _get('beforepaste');
  EventListenerList get blur() => _get('blur');
  EventListenerList get change() => _get('change');
  EventListenerList get click() => _get('click');
  EventListenerList get contextMenu() => _get('contextmenu');
  EventListenerList get copy() => _get('copy');
  EventListenerList get cut() => _get('cut');
  EventListenerList get doubleClick() => _get('dblclick');
  EventListenerList get drag() => _get('drag');
  EventListenerList get dragEnd() => _get('dragend');
  EventListenerList get dragEnter() => _get('dragenter');
  EventListenerList get dragLeave() => _get('dragleave');
  EventListenerList get dragOver() => _get('dragover');
  EventListenerList get dragStart() => _get('dragstart');
  EventListenerList get drop() => _get('drop');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get fullscreenChange() => _get('webkitfullscreenchange');
  EventListenerList get fullscreenError() => _get('webkitfullscreenerror');
  EventListenerList get input() => _get('input');
  EventListenerList get invalid() => _get('invalid');
  EventListenerList get keyDown() => _get('keydown');
  EventListenerList get keyPress() => _get('keypress');
  EventListenerList get keyUp() => _get('keyup');
  EventListenerList get load() => _get('load');
  EventListenerList get mouseDown() => _get('mousedown');
  EventListenerList get mouseMove() => _get('mousemove');
  EventListenerList get mouseOut() => _get('mouseout');
  EventListenerList get mouseOver() => _get('mouseover');
  EventListenerList get mouseUp() => _get('mouseup');
  EventListenerList get mouseWheel() => _get('mousewheel');
  EventListenerList get paste() => _get('paste');
  EventListenerList get readyStateChange() => _get('readystatechange');
  EventListenerList get reset() => _get('reset');
  EventListenerList get scroll() => _get('scroll');
  EventListenerList get search() => _get('search');
  EventListenerList get select() => _get('select');
  EventListenerList get selectStart() => _get('selectstart');
  EventListenerList get selectionChange() => _get('selectionchange');
  EventListenerList get submit() => _get('submit');
  EventListenerList get touchCancel() => _get('touchcancel');
  EventListenerList get touchEnd() => _get('touchend');
  EventListenerList get touchMove() => _get('touchmove');
  EventListenerList get touchStart() => _get('touchstart');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DocumentDOMImpl extends _NodeDOMImpl implements Document {
  _DocumentDOMImpl();
  String get typeName() => "Document";

  _DocumentEventsImpl get on() {
    if (_on === null) _on = new _DocumentEventsImpl(this);
    return _on;
  }

  Element get body() native "Document_body_Getter";

  void set body(Element) native "Document_body_Setter";

  String get charset() native "Document_charset_Getter";

  void set charset(String) native "Document_charset_Setter";

  String get cookie() native "Document_cookie_Getter";

  void set cookie(String) native "Document_cookie_Setter";

  Window get window() native "Document_defaultView_Getter";

  Element get documentElement() native "Document_documentElement_Getter";

  String get domain() native "Document_domain_Getter";

  HeadElement get head() native "Document_head_Getter";

  String get lastModified() native "Document_lastModified_Getter";

  String get preferredStylesheetSet() native "Document_preferredStylesheetSet_Getter";

  String get readyState() native "Document_readyState_Getter";

  String get referrer() native "Document_referrer_Getter";

  String get selectedStylesheetSet() native "Document_selectedStylesheetSet_Getter";

  void set selectedStylesheetSet(String) native "Document_selectedStylesheetSet_Setter";

  StyleSheetList get styleSheets() native "Document_styleSheets_Getter";

  String get title() native "Document_title_Getter";

  void set title(String) native "Document_title_Setter";

  Element get webkitCurrentFullScreenElement() native "Document_webkitCurrentFullScreenElement_Getter";

  bool get webkitFullScreenKeyboardInputAllowed() native "Document_webkitFullScreenKeyboardInputAllowed_Getter";

  Element get webkitFullscreenElement() native "Document_webkitFullscreenElement_Getter";

  bool get webkitFullscreenEnabled() native "Document_webkitFullscreenEnabled_Getter";

  bool get webkitHidden() native "Document_webkitHidden_Getter";

  bool get webkitIsFullScreen() native "Document_webkitIsFullScreen_Getter";

  String get webkitVisibilityState() native "Document_webkitVisibilityState_Getter";

  Range caretRangeFromPoint(int x, int y) {
    return _caretRangeFromPoint(x, y);
  }

  Range _caretRangeFromPoint(x, y) native "Document_caretRangeFromPoint_Callback";

  CDATASection createCDATASection(String data) {
    return _createCDATASection(data);
  }

  CDATASection _createCDATASection(data) native "Document_createCDATASection_Callback";

  DocumentFragment createDocumentFragment() {
    return _createDocumentFragment();
  }

  DocumentFragment _createDocumentFragment() native "Document_createDocumentFragment_Callback";

  Element $dom_createElement(String tagName) {
    return _createElement(tagName);
  }

  Element _createElement(tagName) native "Document_createElement_Callback";

  Element $dom_createElementNS(String namespaceURI, String qualifiedName) {
    return _createElementNS(namespaceURI, qualifiedName);
  }

  Element _createElementNS(namespaceURI, qualifiedName) native "Document_createElementNS_Callback";

  Event $dom_createEvent(String eventType) {
    return _createEvent(eventType);
  }

  Event _createEvent(eventType) native "Document_createEvent_Callback";

  Range createRange() {
    return _createRange();
  }

  Range _createRange() native "Document_createRange_Callback";

  Text $dom_createTextNode(String data) {
    return _createTextNode(data);
  }

  Text _createTextNode(data) native "Document_createTextNode_Callback";

  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) {
    if ((window === null || window is Window)) {
      return _createTouch(window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce);
    }
    throw "Incorrect number or type of arguments";
  }

  Touch _createTouch(window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce) native "Document_createTouch_Callback";

  TouchList $dom_createTouchList() native "Document_createTouchList_Callback";

  Element elementFromPoint(int x, int y) {
    return _elementFromPoint(x, y);
  }

  Element _elementFromPoint(x, y) native "Document_elementFromPoint_Callback";

  bool execCommand(String command, bool userInterface, String value) {
    return _execCommand(command, userInterface, value);
  }

  bool _execCommand(command, userInterface, value) native "Document_execCommand_Callback";

  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height) {
    return _getCSSCanvasContext(contextId, name, width, height);
  }

  CanvasRenderingContext _getCSSCanvasContext(contextId, name, width, height) native "Document_getCSSCanvasContext_Callback";

  Element $dom_getElementById(String elementId) {
    return _getElementById(elementId);
  }

  Element _getElementById(elementId) native "Document_getElementById_Callback";

  NodeList $dom_getElementsByClassName(String tagname) {
    return _getElementsByClassName(tagname);
  }

  NodeList _getElementsByClassName(tagname) native "Document_getElementsByClassName_Callback";

  NodeList $dom_getElementsByName(String elementName) {
    return _getElementsByName(elementName);
  }

  NodeList _getElementsByName(elementName) native "Document_getElementsByName_Callback";

  NodeList $dom_getElementsByTagName(String tagname) {
    return _getElementsByTagName(tagname);
  }

  NodeList _getElementsByTagName(tagname) native "Document_getElementsByTagName_Callback";

  bool queryCommandEnabled(String command) {
    return _queryCommandEnabled(command);
  }

  bool _queryCommandEnabled(command) native "Document_queryCommandEnabled_Callback";

  bool queryCommandIndeterm(String command) {
    return _queryCommandIndeterm(command);
  }

  bool _queryCommandIndeterm(command) native "Document_queryCommandIndeterm_Callback";

  bool queryCommandState(String command) {
    return _queryCommandState(command);
  }

  bool _queryCommandState(command) native "Document_queryCommandState_Callback";

  bool queryCommandSupported(String command) {
    return _queryCommandSupported(command);
  }

  bool _queryCommandSupported(command) native "Document_queryCommandSupported_Callback";

  String queryCommandValue(String command) {
    return _queryCommandValue(command);
  }

  String _queryCommandValue(command) native "Document_queryCommandValue_Callback";

  Element query(String selectors) {
    return _querySelector(selectors);
  }

  Element _querySelector(selectors) native "Document_querySelector_Callback";

  NodeList $dom_querySelectorAll(String selectors) {
    return _querySelectorAll(selectors);
  }

  NodeList _querySelectorAll(selectors) native "Document_querySelectorAll_Callback";

  void webkitCancelFullScreen() {
    _webkitCancelFullScreen();
    return;
  }

  void _webkitCancelFullScreen() native "Document_webkitCancelFullScreen_Callback";

  void webkitExitFullscreen() {
    _webkitExitFullscreen();
    return;
  }

  void _webkitExitFullscreen() native "Document_webkitExitFullscreen_Callback";

  WebKitNamedFlow webkitGetFlowByName(String name) {
    return _webkitGetFlowByName(name);
  }

  WebKitNamedFlow _webkitGetFlowByName(name) native "Document_webkitGetFlowByName_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DocumentTypeDOMImpl extends _NodeDOMImpl implements DocumentType {
  _DocumentTypeDOMImpl();
  String get typeName() => "DocumentType";

  NamedNodeMap get entities() native "DocumentType_entities_Getter";

  String get internalSubset() native "DocumentType_internalSubset_Getter";

  String get name() native "DocumentType_name_Getter";

  NamedNodeMap get notations() native "DocumentType_notations_Getter";

  String get publicId() native "DocumentType_publicId_Getter";

  String get systemId() native "DocumentType_systemId_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _DynamicsCompressorNodeDOMImpl extends _AudioNodeDOMImpl implements DynamicsCompressorNode {
  _DynamicsCompressorNodeDOMImpl();
  String get typeName() => "DynamicsCompressorNode";

  AudioParam get attack() native "DynamicsCompressorNode_attack_Getter";

  AudioParam get knee() native "DynamicsCompressorNode_knee_Getter";

  AudioParam get ratio() native "DynamicsCompressorNode_ratio_Getter";

  AudioParam get reduction() native "DynamicsCompressorNode_reduction_Getter";

  AudioParam get release() native "DynamicsCompressorNode_release_Getter";

  AudioParam get threshold() native "DynamicsCompressorNode_threshold_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EXTTextureFilterAnisotropicDOMImpl extends _DOMWrapperBase implements EXTTextureFilterAnisotropic {
  _EXTTextureFilterAnisotropicDOMImpl();
  String get typeName() => "EXTTextureFilterAnisotropic";

}

class _ElementEventsImpl extends _EventsImpl implements ElementEvents {
  _ElementEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get beforeCopy() => _get('beforecopy');
  EventListenerList get beforeCut() => _get('beforecut');
  EventListenerList get beforePaste() => _get('beforepaste');
  EventListenerList get blur() => _get('blur');
  EventListenerList get change() => _get('change');
  EventListenerList get click() => _get('click');
  EventListenerList get contextMenu() => _get('contextmenu');
  EventListenerList get copy() => _get('copy');
  EventListenerList get cut() => _get('cut');
  EventListenerList get doubleClick() => _get('dblclick');
  EventListenerList get drag() => _get('drag');
  EventListenerList get dragEnd() => _get('dragend');
  EventListenerList get dragEnter() => _get('dragenter');
  EventListenerList get dragLeave() => _get('dragleave');
  EventListenerList get dragOver() => _get('dragover');
  EventListenerList get dragStart() => _get('dragstart');
  EventListenerList get drop() => _get('drop');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get fullscreenChange() => _get('webkitfullscreenchange');
  EventListenerList get fullscreenError() => _get('webkitfullscreenerror');
  EventListenerList get input() => _get('input');
  EventListenerList get invalid() => _get('invalid');
  EventListenerList get keyDown() => _get('keydown');
  EventListenerList get keyPress() => _get('keypress');
  EventListenerList get keyUp() => _get('keyup');
  EventListenerList get load() => _get('load');
  EventListenerList get mouseDown() => _get('mousedown');
  EventListenerList get mouseMove() => _get('mousemove');
  EventListenerList get mouseOut() => _get('mouseout');
  EventListenerList get mouseOver() => _get('mouseover');
  EventListenerList get mouseUp() => _get('mouseup');
  EventListenerList get mouseWheel() => _get('mousewheel');
  EventListenerList get paste() => _get('paste');
  EventListenerList get reset() => _get('reset');
  EventListenerList get scroll() => _get('scroll');
  EventListenerList get search() => _get('search');
  EventListenerList get select() => _get('select');
  EventListenerList get selectStart() => _get('selectstart');
  EventListenerList get submit() => _get('submit');
  EventListenerList get touchCancel() => _get('touchcancel');
  EventListenerList get touchEnd() => _get('touchend');
  EventListenerList get touchEnter() => _get('touchenter');
  EventListenerList get touchLeave() => _get('touchleave');
  EventListenerList get touchMove() => _get('touchmove');
  EventListenerList get touchStart() => _get('touchstart');
  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ElementDOMImpl extends _NodeDOMImpl implements Element {
  _ElementDOMImpl();
  String get typeName() => "Element";

  _ElementEventsImpl get on() {
    if (_on === null) _on = new _ElementEventsImpl(this);
    return _on;
  }

  int get $dom_childElementCount() native "Element_childElementCount_Getter";

  int get $dom_clientHeight() native "Element_clientHeight_Getter";

  int get $dom_clientLeft() native "Element_clientLeft_Getter";

  int get $dom_clientTop() native "Element_clientTop_Getter";

  int get $dom_clientWidth() native "Element_clientWidth_Getter";

  Map<String, String> get dataset() native "Element_dataset_Getter";

  Element get $dom_firstElementChild() native "Element_firstElementChild_Getter";

  Element get $dom_lastElementChild() native "Element_lastElementChild_Getter";

  Element get nextElementSibling() native "Element_nextElementSibling_Getter";

  int get $dom_offsetHeight() native "Element_offsetHeight_Getter";

  int get $dom_offsetLeft() native "Element_offsetLeft_Getter";

  Element get offsetParent() native "Element_offsetParent_Getter";

  int get $dom_offsetTop() native "Element_offsetTop_Getter";

  int get $dom_offsetWidth() native "Element_offsetWidth_Getter";

  Element get previousElementSibling() native "Element_previousElementSibling_Getter";

  int get $dom_scrollHeight() native "Element_scrollHeight_Getter";

  int get $dom_scrollLeft() native "Element_scrollLeft_Getter";

  void set $dom_scrollLeft(int) native "Element_scrollLeft_Setter";

  int get $dom_scrollTop() native "Element_scrollTop_Getter";

  void set $dom_scrollTop(int) native "Element_scrollTop_Setter";

  int get $dom_scrollWidth() native "Element_scrollWidth_Getter";

  CSSStyleDeclaration get style() native "Element_style_Getter";

  String get tagName() native "Element_tagName_Getter";

  String get webkitRegionOverflow() native "Element_webkitRegionOverflow_Getter";

  void blur() {
    _blur();
    return;
  }

  void _blur() native "Element_blur_Callback";

  void focus() {
    _focus();
    return;
  }

  void _focus() native "Element_focus_Callback";

  String $dom_getAttribute(String name) {
    return _getAttribute(name);
  }

  String _getAttribute(name) native "Element_getAttribute_Callback";

  ClientRect $dom_getBoundingClientRect() {
    return _getBoundingClientRect();
  }

  ClientRect _getBoundingClientRect() native "Element_getBoundingClientRect_Callback";

  ClientRectList $dom_getClientRects() {
    return _getClientRects();
  }

  ClientRectList _getClientRects() native "Element_getClientRects_Callback";

  NodeList $dom_getElementsByClassName(String name) {
    return _getElementsByClassName(name);
  }

  NodeList _getElementsByClassName(name) native "Element_getElementsByClassName_Callback";

  NodeList $dom_getElementsByTagName(String name) {
    return _getElementsByTagName(name);
  }

  NodeList _getElementsByTagName(name) native "Element_getElementsByTagName_Callback";

  bool $dom_hasAttribute(String name) {
    return _hasAttribute(name);
  }

  bool _hasAttribute(name) native "Element_hasAttribute_Callback";

  Element query(String selectors) {
    return _querySelector(selectors);
  }

  Element _querySelector(selectors) native "Element_querySelector_Callback";

  NodeList $dom_querySelectorAll(String selectors) {
    return _querySelectorAll(selectors);
  }

  NodeList _querySelectorAll(selectors) native "Element_querySelectorAll_Callback";

  void $dom_removeAttribute(String name) {
    _removeAttribute(name);
    return;
  }

  void _removeAttribute(name) native "Element_removeAttribute_Callback";

  void scrollByLines(int lines) {
    _scrollByLines(lines);
    return;
  }

  void _scrollByLines(lines) native "Element_scrollByLines_Callback";

  void scrollByPages(int pages) {
    _scrollByPages(pages);
    return;
  }

  void _scrollByPages(pages) native "Element_scrollByPages_Callback";

  void scrollIntoView([bool centerIfNeeded = null]) {
    //
    // scrollIntoViewIfNeeded()
    // scrollIntoViewIfNeeded([Optional] bool centerIfNeeded)
    //
    // -- reduced:
    // scrollIntoViewIfNeeded([Optional] bool centerIfNeeded)
    //
    _scrollIntoViewIfNeeded(centerIfNeeded);
    return;
  }

  void _scrollIntoViewIfNeeded(centerIfNeeded) native "Element_scrollIntoViewIfNeeded_Callback";

  void $dom_setAttribute(String name, String value) {
    _setAttribute(name, value);
    return;
  }

  void _setAttribute(name, value) native "Element_setAttribute_Callback";

  bool matchesSelector(String selectors) {
    return _webkitMatchesSelector(selectors);
  }

  bool _webkitMatchesSelector(selectors) native "Element_webkitMatchesSelector_Callback";

  void webkitRequestFullScreen(int flags) {
    _webkitRequestFullScreen(flags);
    return;
  }

  void _webkitRequestFullScreen(flags) native "Element_webkitRequestFullScreen_Callback";

  void webkitRequestFullscreen() {
    _webkitRequestFullscreen();
    return;
  }

  void _webkitRequestFullscreen() native "Element_webkitRequestFullscreen_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EntityDOMImpl extends _NodeDOMImpl implements Entity {
  _EntityDOMImpl();
  String get typeName() => "Entity";

  String get notationName() native "Entity_notationName_Getter";

  String get publicId() native "Entity_publicId_Getter";

  String get systemId() native "Entity_systemId_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EntityReferenceDOMImpl extends _NodeDOMImpl implements EntityReference {
  _EntityReferenceDOMImpl();
  String get typeName() => "EntityReference";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EntryArrayDOMImpl extends _DOMWrapperBase implements EntryArray {
  _EntryArrayDOMImpl();
  String get typeName() => "EntryArray";

  int get length() native "EntryArray_length_Getter";

  Entry item(int index) {
    return _item(index);
  }

  Entry _item(index) native "EntryArray_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EntryArraySyncDOMImpl extends _DOMWrapperBase implements EntryArraySync {
  _EntryArraySyncDOMImpl();
  String get typeName() => "EntryArraySync";

  int get length() native "EntryArraySync_length_Getter";

  EntrySync item(int index) {
    return _item(index);
  }

  EntrySync _item(index) native "EntryArraySync_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EntryDOMImpl extends _DOMWrapperBase implements Entry {
  _EntryDOMImpl();
  String get typeName() => "Entry";

  DOMFileSystem get filesystem() native "Entry_filesystem_Getter";

  String get fullPath() native "Entry_fullPath_Getter";

  bool get isDirectory() native "Entry_isDirectory_Getter";

  bool get isFile() native "Entry_isFile_Getter";

  String get name() native "Entry_name_Getter";

  void copyTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    _copyTo(parent, name, successCallback, errorCallback);
    return;
  }

  void _copyTo(parent, name, successCallback, errorCallback) native "Entry_copyTo_Callback";

  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback = null]) {
    _getMetadata(successCallback, errorCallback);
    return;
  }

  void _getMetadata(successCallback, errorCallback) native "Entry_getMetadata_Callback";

  void getParent([EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    _getParent(successCallback, errorCallback);
    return;
  }

  void _getParent(successCallback, errorCallback) native "Entry_getParent_Callback";

  void moveTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    _moveTo(parent, name, successCallback, errorCallback);
    return;
  }

  void _moveTo(parent, name, successCallback, errorCallback) native "Entry_moveTo_Callback";

  void remove(VoidCallback successCallback, [ErrorCallback errorCallback = null]) {
    _remove(successCallback, errorCallback);
    return;
  }

  void _remove(successCallback, errorCallback) native "Entry_remove_Callback";

  String toURL() {
    return _toURL();
  }

  String _toURL() native "Entry_toURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EntrySyncDOMImpl extends _DOMWrapperBase implements EntrySync {
  _EntrySyncDOMImpl();
  String get typeName() => "EntrySync";

  DOMFileSystemSync get filesystem() native "EntrySync_filesystem_Getter";

  String get fullPath() native "EntrySync_fullPath_Getter";

  bool get isDirectory() native "EntrySync_isDirectory_Getter";

  bool get isFile() native "EntrySync_isFile_Getter";

  String get name() native "EntrySync_name_Getter";

  EntrySync copyTo(DirectoryEntrySync parent, String name) {
    return _copyTo(parent, name);
  }

  EntrySync _copyTo(parent, name) native "EntrySync_copyTo_Callback";

  Metadata getMetadata() {
    return _getMetadata();
  }

  Metadata _getMetadata() native "EntrySync_getMetadata_Callback";

  EntrySync getParent() {
    return _getParent();
  }

  EntrySync _getParent() native "EntrySync_getParent_Callback";

  EntrySync moveTo(DirectoryEntrySync parent, String name) {
    return _moveTo(parent, name);
  }

  EntrySync _moveTo(parent, name) native "EntrySync_moveTo_Callback";

  void remove() {
    _remove();
    return;
  }

  void _remove() native "EntrySync_remove_Callback";

  String toURL() {
    return _toURL();
  }

  String _toURL() native "EntrySync_toURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ErrorEventDOMImpl extends _EventDOMImpl implements ErrorEvent {
  _ErrorEventDOMImpl();
  String get typeName() => "ErrorEvent";

  String get filename() native "ErrorEvent_filename_Getter";

  int get lineno() native "ErrorEvent_lineno_Getter";

  String get message() native "ErrorEvent_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EventExceptionDOMImpl extends _DOMWrapperBase implements EventException {
  _EventExceptionDOMImpl();
  String get typeName() => "EventException";

  int get code() native "EventException_code_Getter";

  String get message() native "EventException_message_Getter";

  String get name() native "EventException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "EventException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EventDOMImpl extends _DOMWrapperBase implements Event {
  _EventDOMImpl();
  String get typeName() => "Event";

  bool get bubbles() native "Event_bubbles_Getter";

  bool get cancelBubble() native "Event_cancelBubble_Getter";

  void set cancelBubble(bool) native "Event_cancelBubble_Setter";

  bool get cancelable() native "Event_cancelable_Getter";

  Clipboard get clipboardData() native "Event_clipboardData_Getter";

  EventTarget get currentTarget() native "Event_currentTarget_Getter";

  bool get defaultPrevented() native "Event_defaultPrevented_Getter";

  int get eventPhase() native "Event_eventPhase_Getter";

  bool get returnValue() native "Event_returnValue_Getter";

  void set returnValue(bool) native "Event_returnValue_Setter";

  EventTarget get srcElement() native "Event_srcElement_Getter";

  EventTarget get target() native "Event_target_Getter";

  int get timeStamp() native "Event_timeStamp_Getter";

  String get type() native "Event_type_Getter";

  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) {
    _initEvent(eventTypeArg, canBubbleArg, cancelableArg);
    return;
  }

  void _initEvent(eventTypeArg, canBubbleArg, cancelableArg) native "Event_initEvent_Callback";

  void preventDefault() {
    _preventDefault();
    return;
  }

  void _preventDefault() native "Event_preventDefault_Callback";

  void stopImmediatePropagation() {
    _stopImmediatePropagation();
    return;
  }

  void _stopImmediatePropagation() native "Event_stopImmediatePropagation_Callback";

  void stopPropagation() {
    _stopPropagation();
    return;
  }

  void _stopPropagation() native "Event_stopPropagation_Callback";

}
class _EventSourceFactoryProviderImpl {
  static _EventSourceDOMImpl createEventSource(String scriptUrl)
      native "EventSource_constructor_Callback";
}
class _EventSourceEventsImpl extends _EventsImpl implements EventSourceEvents {
  _EventSourceEventsImpl(_ptr) : super(_ptr);
  EventListenerList get error() => _get('error');
  EventListenerList get message() => _get('message');
  EventListenerList get open() => _get('open');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EventSourceDOMImpl extends _DOMWrapperBase implements EventSource {
  _EventSourceDOMImpl();
  String get typeName() => "EventSource";
  _EventsImpl _on;

  _EventSourceEventsImpl get on() {
    if (_on === null) _on = new _EventSourceEventsImpl(this);
    return _on;
  }

  String get URL() native "EventSource_URL_Getter";

  int get readyState() native "EventSource_readyState_Getter";

  String get url() native "EventSource_url_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "EventSource_addEventListener_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "EventSource_close_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "EventSource_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "EventSource_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _EventTargetDOMImpl extends _DOMWrapperBase implements EventTarget {
  _EventTargetDOMImpl();
  String get typeName() => "EventTarget";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "EventTarget_addEventListener_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "EventTarget_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "EventTarget_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileEntryDOMImpl extends _EntryDOMImpl implements FileEntry {
  _FileEntryDOMImpl();
  String get typeName() => "FileEntry";

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback = null]) {
    _createWriter(successCallback, errorCallback);
    return;
  }

  void _createWriter(successCallback, errorCallback) native "FileEntry_createWriter_Callback";

  void file(FileCallback successCallback, [ErrorCallback errorCallback = null]) {
    _file(successCallback, errorCallback);
    return;
  }

  void _file(successCallback, errorCallback) native "FileEntry_file_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileEntrySyncDOMImpl extends _EntrySyncDOMImpl implements FileEntrySync {
  _FileEntrySyncDOMImpl();
  String get typeName() => "FileEntrySync";

  FileWriterSync createWriter() {
    return _createWriter();
  }

  FileWriterSync _createWriter() native "FileEntrySync_createWriter_Callback";

  File file() {
    return _file();
  }

  File _file() native "FileEntrySync_file_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileErrorDOMImpl extends _DOMWrapperBase implements FileError {
  _FileErrorDOMImpl();
  String get typeName() => "FileError";

  int get code() native "FileError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileExceptionDOMImpl extends _DOMWrapperBase implements FileException {
  _FileExceptionDOMImpl();
  String get typeName() => "FileException";

  int get code() native "FileException_code_Getter";

  String get message() native "FileException_message_Getter";

  String get name() native "FileException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "FileException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileDOMImpl extends _BlobDOMImpl implements File {
  _FileDOMImpl();
  String get typeName() => "File";

  Date get lastModifiedDate() native "File_lastModifiedDate_Getter";

  String get name() native "File_name_Getter";

  String get webkitRelativePath() native "File_webkitRelativePath_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileListDOMImpl extends _DOMWrapperBase implements FileList {
  _FileListDOMImpl();
  String get typeName() => "FileList";

  int get length() native "FileList_length_Getter";

  File operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, File value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(File value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(File value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<File> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(File a, File b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(File element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(File element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  File removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  File last() {
    return this[length - 1];
  }

  void forEach(void f(File element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(File element)) {
    return _Collections.map(this, [], f);
  }

  Collection<File> filter(bool f(File element)) {
    return _Collections.filter(this, new List<File>(), f);
  }

  bool every(bool f(File element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(File element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<File> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [File initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<File> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<File> iterator() {
    return new _FixedSizeListIterator<File>(this);
  }

  File item(int index) {
    return _item(index);
  }

  File _item(index) native "FileList_item_Callback";

}
class _FileReaderFactoryProviderImpl {
  static _FileReaderDOMImpl createFileReader()
      native "FileReader_constructor_Callback";
}
class _FileReaderEventsImpl extends _EventsImpl implements FileReaderEvents {
  _FileReaderEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get load() => _get('load');
  EventListenerList get loadEnd() => _get('loadend');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get progress() => _get('progress');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileReaderDOMImpl extends _DOMWrapperBase implements FileReader {
  _FileReaderDOMImpl();
  String get typeName() => "FileReader";
  _EventsImpl _on;

  _FileReaderEventsImpl get on() {
    if (_on === null) _on = new _FileReaderEventsImpl(this);
    return _on;
  }

  FileError get error() native "FileReader_error_Getter";

  int get readyState() native "FileReader_readyState_Getter";

  Object get result() native "FileReader_result_Getter";

  void abort() {
    _abort();
    return;
  }

  void _abort() native "FileReader_abort_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "FileReader_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "FileReader_dispatchEvent_Callback";

  void readAsArrayBuffer(Blob blob) {
    _readAsArrayBuffer(blob);
    return;
  }

  void _readAsArrayBuffer(blob) native "FileReader_readAsArrayBuffer_Callback";

  void readAsBinaryString(Blob blob) {
    _readAsBinaryString(blob);
    return;
  }

  void _readAsBinaryString(blob) native "FileReader_readAsBinaryString_Callback";

  void readAsDataURL(Blob blob) {
    _readAsDataURL(blob);
    return;
  }

  void _readAsDataURL(blob) native "FileReader_readAsDataURL_Callback";

  void readAsText(Blob blob, [String encoding = null]) {
    //
    // readAsText(Blob blob)
    // readAsText(Blob blob, [Optional] String encoding)
    //
    // -- reduced:
    // readAsText(Blob blob, [Optional] String encoding)
    //
    _readAsText(blob, encoding);
    return;
  }

  void _readAsText(blob, encoding) native "FileReader_readAsText_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "FileReader_removeEventListener_Callback";

}
class _FileReaderSyncFactoryProviderImpl {
  static _FileReaderSyncDOMImpl createFileReaderSync()
      native "FileReaderSync_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileReaderSyncDOMImpl extends _DOMWrapperBase implements FileReaderSync {
  _FileReaderSyncDOMImpl();
  String get typeName() => "FileReaderSync";

  ArrayBuffer readAsArrayBuffer(Blob blob) {
    return _readAsArrayBuffer(blob);
  }

  ArrayBuffer _readAsArrayBuffer(blob) native "FileReaderSync_readAsArrayBuffer_Callback";

  String readAsBinaryString(Blob blob) {
    return _readAsBinaryString(blob);
  }

  String _readAsBinaryString(blob) native "FileReaderSync_readAsBinaryString_Callback";

  String readAsDataURL(Blob blob) {
    return _readAsDataURL(blob);
  }

  String _readAsDataURL(blob) native "FileReaderSync_readAsDataURL_Callback";

  String readAsText(Blob blob, [String encoding = null]) {
    //
    // readAsText(Blob blob)
    // readAsText(Blob blob, [Optional] String encoding)
    //
    // -- reduced:
    // readAsText(Blob blob, [Optional] String encoding)
    //
    return _readAsText(blob, encoding);
  }

  String _readAsText(blob, encoding) native "FileReaderSync_readAsText_Callback";

}

class _FileWriterEventsImpl extends _EventsImpl implements FileWriterEvents {
  _FileWriterEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get progress() => _get('progress');
  EventListenerList get write() => _get('write');
  EventListenerList get writeEnd() => _get('writeend');
  EventListenerList get writeStart() => _get('writestart');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileWriterDOMImpl extends _DOMWrapperBase implements FileWriter {
  _FileWriterDOMImpl();
  String get typeName() => "FileWriter";
  _EventsImpl _on;

  _FileWriterEventsImpl get on() {
    if (_on === null) _on = new _FileWriterEventsImpl(this);
    return _on;
  }

  FileError get error() native "FileWriter_error_Getter";

  int get length() native "FileWriter_length_Getter";

  int get position() native "FileWriter_position_Getter";

  int get readyState() native "FileWriter_readyState_Getter";

  void abort() {
    _abort();
    return;
  }

  void _abort() native "FileWriter_abort_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "FileWriter_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "FileWriter_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "FileWriter_removeEventListener_Callback";

  void seek(int position) {
    _seek(position);
    return;
  }

  void _seek(position) native "FileWriter_seek_Callback";

  void truncate(int size) {
    _truncate(size);
    return;
  }

  void _truncate(size) native "FileWriter_truncate_Callback";

  void write(Blob data) {
    _write(data);
    return;
  }

  void _write(data) native "FileWriter_write_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _FileWriterSyncDOMImpl extends _DOMWrapperBase implements FileWriterSync {
  _FileWriterSyncDOMImpl();
  String get typeName() => "FileWriterSync";

  int get length() native "FileWriterSync_length_Getter";

  int get position() native "FileWriterSync_position_Getter";

  void seek(int position) {
    _seek(position);
    return;
  }

  void _seek(position) native "FileWriterSync_seek_Callback";

  void truncate(int size) {
    _truncate(size);
    return;
  }

  void _truncate(size) native "FileWriterSync_truncate_Callback";

  void write(Blob data) {
    _write(data);
    return;
  }

  void _write(data) native "FileWriterSync_write_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Float32ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Float32Array {
  _Float32ArrayDOMImpl();
  String get typeName() => "Float32Array";

  int get length() native "Float32Array_length_Getter";

  num operator[](int index) native "Float32Array_numericIndexGetter_Callback";

  void operator[]=(int index, num value) native "Float32Array_numericIndexSetter_Callback";

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(num element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(num element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  num last() {
    return this[length - 1];
  }

  void forEach(void f(num element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(num element)) {
    return _Collections.map(this, [], f);
  }

  Collection<num> filter(bool f(num element)) {
    return _Collections.filter(this, new List<num>(), f);
  }

  bool every(bool f(num element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(num element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<num> iterator() {
    return new _FixedSizeListIterator<num>(this);
  }

  void setElements(Object array, [int offset = null]) native "Float32Array_setElements_Callback";

  Float32Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Float32Array _subarray(start, end) native "Float32Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Float64ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Float64Array {
  _Float64ArrayDOMImpl();
  String get typeName() => "Float64Array";

  int get length() native "Float64Array_length_Getter";

  num operator[](int index) native "Float64Array_numericIndexGetter_Callback";

  void operator[]=(int index, num value) native "Float64Array_numericIndexSetter_Callback";

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(num element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(num element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  num last() {
    return this[length - 1];
  }

  void forEach(void f(num element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(num element)) {
    return _Collections.map(this, [], f);
  }

  Collection<num> filter(bool f(num element)) {
    return _Collections.filter(this, new List<num>(), f);
  }

  bool every(bool f(num element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(num element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<num> iterator() {
    return new _FixedSizeListIterator<num>(this);
  }

  void setElements(Object array, [int offset = null]) native "Float64Array_setElements_Callback";

  Float64Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Float64Array _subarray(start, end) native "Float64Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _GeolocationDOMImpl extends _DOMWrapperBase implements Geolocation {
  _GeolocationDOMImpl();
  String get typeName() => "Geolocation";

  void clearWatch(int watchId) {
    _clearWatch(watchId);
    return;
  }

  void _clearWatch(watchId) native "Geolocation_clearWatch_Callback";

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) native "Geolocation_getCurrentPosition_Callback";

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) native "Geolocation_watchPosition_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _GeopositionDOMImpl extends _DOMWrapperBase implements Geoposition {
  _GeopositionDOMImpl();
  String get typeName() => "Geoposition";

  Coordinates get coords() native "Geoposition_coords_Getter";

  int get timestamp() native "Geoposition_timestamp_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLAllCollectionDOMImpl extends _DOMWrapperBase implements HTMLAllCollection {
  _HTMLAllCollectionDOMImpl();
  String get typeName() => "HTMLAllCollection";

  int get length() native "HTMLAllCollection_length_Getter";

  Node item(int index) native "HTMLAllCollection_item_Callback";

  Node namedItem(String name) native "HTMLAllCollection_namedItem_Callback";

  NodeList tags(String name) {
    return _tags(name);
  }

  NodeList _tags(name) native "HTMLAllCollection_tags_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLAnchorElementDOMImpl extends _HTMLElementDOMImpl implements AnchorElement {
  _HTMLAnchorElementDOMImpl();
  String get typeName() => "HTMLAnchorElement";

  String get charset() native "HTMLAnchorElement_charset_Getter";

  void set charset(String) native "HTMLAnchorElement_charset_Setter";

  String get coords() native "HTMLAnchorElement_coords_Getter";

  void set coords(String) native "HTMLAnchorElement_coords_Setter";

  String get download() native "HTMLAnchorElement_download_Getter";

  void set download(String) native "HTMLAnchorElement_download_Setter";

  String get hash() native "HTMLAnchorElement_hash_Getter";

  void set hash(String) native "HTMLAnchorElement_hash_Setter";

  String get host() native "HTMLAnchorElement_host_Getter";

  void set host(String) native "HTMLAnchorElement_host_Setter";

  String get hostname() native "HTMLAnchorElement_hostname_Getter";

  void set hostname(String) native "HTMLAnchorElement_hostname_Setter";

  String get href() native "HTMLAnchorElement_href_Getter";

  void set href(String) native "HTMLAnchorElement_href_Setter";

  String get hreflang() native "HTMLAnchorElement_hreflang_Getter";

  void set hreflang(String) native "HTMLAnchorElement_hreflang_Setter";

  String get name() native "HTMLAnchorElement_name_Getter";

  void set name(String) native "HTMLAnchorElement_name_Setter";

  String get origin() native "HTMLAnchorElement_origin_Getter";

  String get pathname() native "HTMLAnchorElement_pathname_Getter";

  void set pathname(String) native "HTMLAnchorElement_pathname_Setter";

  String get ping() native "HTMLAnchorElement_ping_Getter";

  void set ping(String) native "HTMLAnchorElement_ping_Setter";

  String get port() native "HTMLAnchorElement_port_Getter";

  void set port(String) native "HTMLAnchorElement_port_Setter";

  String get protocol() native "HTMLAnchorElement_protocol_Getter";

  void set protocol(String) native "HTMLAnchorElement_protocol_Setter";

  String get rel() native "HTMLAnchorElement_rel_Getter";

  void set rel(String) native "HTMLAnchorElement_rel_Setter";

  String get rev() native "HTMLAnchorElement_rev_Getter";

  void set rev(String) native "HTMLAnchorElement_rev_Setter";

  String get search() native "HTMLAnchorElement_search_Getter";

  void set search(String) native "HTMLAnchorElement_search_Setter";

  String get shape() native "HTMLAnchorElement_shape_Getter";

  void set shape(String) native "HTMLAnchorElement_shape_Setter";

  String get target() native "HTMLAnchorElement_target_Getter";

  void set target(String) native "HTMLAnchorElement_target_Setter";

  String get type() native "HTMLAnchorElement_type_Getter";

  void set type(String) native "HTMLAnchorElement_type_Setter";

  String toString() {
    return _toString();
  }

  String _toString() native "HTMLAnchorElement_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLAppletElementDOMImpl extends _HTMLElementDOMImpl implements AppletElement {
  _HTMLAppletElementDOMImpl();
  String get typeName() => "HTMLAppletElement";

  String get align() native "HTMLAppletElement_align_Getter";

  void set align(String) native "HTMLAppletElement_align_Setter";

  String get alt() native "HTMLAppletElement_alt_Getter";

  void set alt(String) native "HTMLAppletElement_alt_Setter";

  String get archive() native "HTMLAppletElement_archive_Getter";

  void set archive(String) native "HTMLAppletElement_archive_Setter";

  String get code() native "HTMLAppletElement_code_Getter";

  void set code(String) native "HTMLAppletElement_code_Setter";

  String get codeBase() native "HTMLAppletElement_codeBase_Getter";

  void set codeBase(String) native "HTMLAppletElement_codeBase_Setter";

  String get height() native "HTMLAppletElement_height_Getter";

  void set height(String) native "HTMLAppletElement_height_Setter";

  String get hspace() native "HTMLAppletElement_hspace_Getter";

  void set hspace(String) native "HTMLAppletElement_hspace_Setter";

  String get name() native "HTMLAppletElement_name_Getter";

  void set name(String) native "HTMLAppletElement_name_Setter";

  String get object() native "HTMLAppletElement_object_Getter";

  void set object(String) native "HTMLAppletElement_object_Setter";

  String get vspace() native "HTMLAppletElement_vspace_Getter";

  void set vspace(String) native "HTMLAppletElement_vspace_Setter";

  String get width() native "HTMLAppletElement_width_Getter";

  void set width(String) native "HTMLAppletElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLAreaElementDOMImpl extends _HTMLElementDOMImpl implements AreaElement {
  _HTMLAreaElementDOMImpl();
  String get typeName() => "HTMLAreaElement";

  String get alt() native "HTMLAreaElement_alt_Getter";

  void set alt(String) native "HTMLAreaElement_alt_Setter";

  String get coords() native "HTMLAreaElement_coords_Getter";

  void set coords(String) native "HTMLAreaElement_coords_Setter";

  String get hash() native "HTMLAreaElement_hash_Getter";

  String get host() native "HTMLAreaElement_host_Getter";

  String get hostname() native "HTMLAreaElement_hostname_Getter";

  String get href() native "HTMLAreaElement_href_Getter";

  void set href(String) native "HTMLAreaElement_href_Setter";

  bool get noHref() native "HTMLAreaElement_noHref_Getter";

  void set noHref(bool) native "HTMLAreaElement_noHref_Setter";

  String get pathname() native "HTMLAreaElement_pathname_Getter";

  String get ping() native "HTMLAreaElement_ping_Getter";

  void set ping(String) native "HTMLAreaElement_ping_Setter";

  String get port() native "HTMLAreaElement_port_Getter";

  String get protocol() native "HTMLAreaElement_protocol_Getter";

  String get search() native "HTMLAreaElement_search_Getter";

  String get shape() native "HTMLAreaElement_shape_Getter";

  void set shape(String) native "HTMLAreaElement_shape_Setter";

  String get target() native "HTMLAreaElement_target_Getter";

  void set target(String) native "HTMLAreaElement_target_Setter";

}
class _HTMLAudioElementFactoryProviderImpl {
  static _HTMLAudioElementDOMImpl createHTMLAudioElement([String src = null])
      native "HTMLAudioElement_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLAudioElementDOMImpl extends _HTMLMediaElementDOMImpl implements AudioElement {
  _HTMLAudioElementDOMImpl();
  String get typeName() => "HTMLAudioElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLBRElementDOMImpl extends _HTMLElementDOMImpl implements BRElement {
  _HTMLBRElementDOMImpl();
  String get typeName() => "HTMLBRElement";

  String get clear() native "HTMLBRElement_clear_Getter";

  void set clear(String) native "HTMLBRElement_clear_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLBaseElementDOMImpl extends _HTMLElementDOMImpl implements BaseElement {
  _HTMLBaseElementDOMImpl();
  String get typeName() => "HTMLBaseElement";

  String get href() native "HTMLBaseElement_href_Getter";

  void set href(String) native "HTMLBaseElement_href_Setter";

  String get target() native "HTMLBaseElement_target_Getter";

  void set target(String) native "HTMLBaseElement_target_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLBaseFontElementDOMImpl extends _HTMLElementDOMImpl implements BaseFontElement {
  _HTMLBaseFontElementDOMImpl();
  String get typeName() => "HTMLBaseFontElement";

  String get color() native "HTMLBaseFontElement_color_Getter";

  void set color(String) native "HTMLBaseFontElement_color_Setter";

  String get face() native "HTMLBaseFontElement_face_Getter";

  void set face(String) native "HTMLBaseFontElement_face_Setter";

  int get size() native "HTMLBaseFontElement_size_Getter";

  void set size(int) native "HTMLBaseFontElement_size_Setter";

}

class _HTMLBodyElementEventsImpl extends _ElementEventsImpl implements BodyElementEvents {
  _HTMLBodyElementEventsImpl(_ptr) : super(_ptr);
  EventListenerList get beforeUnload() => _get('beforeunload');
  EventListenerList get blur() => _get('blur');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get hashChange() => _get('hashchange');
  EventListenerList get load() => _get('load');
  EventListenerList get message() => _get('message');
  EventListenerList get offline() => _get('offline');
  EventListenerList get online() => _get('online');
  EventListenerList get popState() => _get('popstate');
  EventListenerList get resize() => _get('resize');
  EventListenerList get storage() => _get('storage');
  EventListenerList get unload() => _get('unload');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLBodyElementDOMImpl extends _HTMLElementDOMImpl implements BodyElement {
  _HTMLBodyElementDOMImpl();
  String get typeName() => "HTMLBodyElement";

  _HTMLBodyElementEventsImpl get on() {
    if (_on === null) _on = new _HTMLBodyElementEventsImpl(this);
    return _on;
  }

  String get aLink() native "HTMLBodyElement_aLink_Getter";

  void set aLink(String) native "HTMLBodyElement_aLink_Setter";

  String get background() native "HTMLBodyElement_background_Getter";

  void set background(String) native "HTMLBodyElement_background_Setter";

  String get bgColor() native "HTMLBodyElement_bgColor_Getter";

  void set bgColor(String) native "HTMLBodyElement_bgColor_Setter";

  String get link() native "HTMLBodyElement_link_Getter";

  void set link(String) native "HTMLBodyElement_link_Setter";

  String get vLink() native "HTMLBodyElement_vLink_Getter";

  void set vLink(String) native "HTMLBodyElement_vLink_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLButtonElementDOMImpl extends _HTMLElementDOMImpl implements ButtonElement {
  _HTMLButtonElementDOMImpl();
  String get typeName() => "HTMLButtonElement";

  bool get autofocus() native "HTMLButtonElement_autofocus_Getter";

  void set autofocus(bool) native "HTMLButtonElement_autofocus_Setter";

  bool get disabled() native "HTMLButtonElement_disabled_Getter";

  void set disabled(bool) native "HTMLButtonElement_disabled_Setter";

  FormElement get form() native "HTMLButtonElement_form_Getter";

  String get formAction() native "HTMLButtonElement_formAction_Getter";

  void set formAction(String) native "HTMLButtonElement_formAction_Setter";

  String get formEnctype() native "HTMLButtonElement_formEnctype_Getter";

  void set formEnctype(String) native "HTMLButtonElement_formEnctype_Setter";

  String get formMethod() native "HTMLButtonElement_formMethod_Getter";

  void set formMethod(String) native "HTMLButtonElement_formMethod_Setter";

  bool get formNoValidate() native "HTMLButtonElement_formNoValidate_Getter";

  void set formNoValidate(bool) native "HTMLButtonElement_formNoValidate_Setter";

  String get formTarget() native "HTMLButtonElement_formTarget_Getter";

  void set formTarget(String) native "HTMLButtonElement_formTarget_Setter";

  NodeList get labels() native "HTMLButtonElement_labels_Getter";

  String get name() native "HTMLButtonElement_name_Getter";

  void set name(String) native "HTMLButtonElement_name_Setter";

  String get type() native "HTMLButtonElement_type_Getter";

  String get validationMessage() native "HTMLButtonElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLButtonElement_validity_Getter";

  String get value() native "HTMLButtonElement_value_Getter";

  void set value(String) native "HTMLButtonElement_value_Setter";

  bool get willValidate() native "HTMLButtonElement_willValidate_Getter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLButtonElement_checkValidity_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLButtonElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLCanvasElementDOMImpl extends _HTMLElementDOMImpl implements CanvasElement {
  _HTMLCanvasElementDOMImpl();
  String get typeName() => "HTMLCanvasElement";

  int get height() native "HTMLCanvasElement_height_Getter";

  void set height(int) native "HTMLCanvasElement_height_Setter";

  int get width() native "HTMLCanvasElement_width_Getter";

  void set width(int) native "HTMLCanvasElement_width_Setter";

  Object getContext(String contextId) native "HTMLCanvasElement_getContext_Callback";

  String toDataURL(String type) native "HTMLCanvasElement_toDataURL_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLCollectionDOMImpl extends _DOMWrapperBase implements HTMLCollection {
  _HTMLCollectionDOMImpl();
  String get typeName() => "HTMLCollection";

  int get length() native "HTMLCollection_length_Getter";

  Node operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Node element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Node element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Node last() {
    return this[length - 1];
  }

  void forEach(void f(Node element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Node element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Node> filter(bool f(Node element)) {
    return _Collections.filter(this, new List<Node>(), f);
  }

  bool every(bool f(Node element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Node element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Node> iterator() {
    return new _FixedSizeListIterator<Node>(this);
  }

  Node item(int index) {
    return _item(index);
  }

  Node _item(index) native "HTMLCollection_item_Callback";

  Node namedItem(String name) native "HTMLCollection_namedItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLContentElementDOMImpl extends _HTMLElementDOMImpl implements ContentElement {
  _HTMLContentElementDOMImpl();
  String get typeName() => "HTMLContentElement";

  String get select() native "HTMLContentElement_select_Getter";

  void set select(String) native "HTMLContentElement_select_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLDListElementDOMImpl extends _HTMLElementDOMImpl implements DListElement {
  _HTMLDListElementDOMImpl();
  String get typeName() => "HTMLDListElement";

  bool get compact() native "HTMLDListElement_compact_Getter";

  void set compact(bool) native "HTMLDListElement_compact_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLDetailsElementDOMImpl extends _HTMLElementDOMImpl implements DetailsElement {
  _HTMLDetailsElementDOMImpl();
  String get typeName() => "HTMLDetailsElement";

  bool get open() native "HTMLDetailsElement_open_Getter";

  void set open(bool) native "HTMLDetailsElement_open_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLDirectoryElementDOMImpl extends _HTMLElementDOMImpl implements DirectoryElement {
  _HTMLDirectoryElementDOMImpl();
  String get typeName() => "HTMLDirectoryElement";

  bool get compact() native "HTMLDirectoryElement_compact_Getter";

  void set compact(bool) native "HTMLDirectoryElement_compact_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLDivElementDOMImpl extends _HTMLElementDOMImpl implements DivElement {
  _HTMLDivElementDOMImpl();
  String get typeName() => "HTMLDivElement";

  String get align() native "HTMLDivElement_align_Getter";

  void set align(String) native "HTMLDivElement_align_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLDocumentDOMImpl extends _DocumentDOMImpl implements Document {
  _HTMLDocumentDOMImpl();
  String get typeName() => "HTMLDocument";

  Element get activeElement() native "HTMLDocument_activeElement_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLElementDOMImpl extends _ElementDOMImpl implements Element {
  _HTMLElementDOMImpl();
  String get typeName() => "HTMLElement";

  HTMLCollection get $dom_children() native "HTMLElement_children_Getter";

  String get $dom_className() native "HTMLElement_className_Getter";

  void set $dom_className(String) native "HTMLElement_className_Setter";

  String get contentEditable() native "HTMLElement_contentEditable_Getter";

  void set contentEditable(String) native "HTMLElement_contentEditable_Setter";

  String get dir() native "HTMLElement_dir_Getter";

  void set dir(String) native "HTMLElement_dir_Setter";

  bool get draggable() native "HTMLElement_draggable_Getter";

  void set draggable(bool) native "HTMLElement_draggable_Setter";

  bool get hidden() native "HTMLElement_hidden_Getter";

  void set hidden(bool) native "HTMLElement_hidden_Setter";

  String get id() native "HTMLElement_id_Getter";

  void set id(String) native "HTMLElement_id_Setter";

  String get innerHTML() native "HTMLElement_innerHTML_Getter";

  void set innerHTML(String) native "HTMLElement_innerHTML_Setter";

  bool get isContentEditable() native "HTMLElement_isContentEditable_Getter";

  String get lang() native "HTMLElement_lang_Getter";

  void set lang(String) native "HTMLElement_lang_Setter";

  String get outerHTML() native "HTMLElement_outerHTML_Getter";

  bool get spellcheck() native "HTMLElement_spellcheck_Getter";

  void set spellcheck(bool) native "HTMLElement_spellcheck_Setter";

  int get tabIndex() native "HTMLElement_tabIndex_Getter";

  void set tabIndex(int) native "HTMLElement_tabIndex_Setter";

  String get title() native "HTMLElement_title_Getter";

  void set title(String) native "HTMLElement_title_Setter";

  bool get translate() native "HTMLElement_translate_Getter";

  void set translate(bool) native "HTMLElement_translate_Setter";

  String get webkitdropzone() native "HTMLElement_webkitdropzone_Getter";

  void set webkitdropzone(String) native "HTMLElement_webkitdropzone_Setter";

  void click() {
    _click();
    return;
  }

  void _click() native "HTMLElement_click_Callback";

  Element insertAdjacentElement(String where, Element element) {
    return _insertAdjacentElement(where, element);
  }

  Element _insertAdjacentElement(where, element) native "HTMLElement_insertAdjacentElement_Callback";

  void insertAdjacentHTML(String where, String html) {
    _insertAdjacentHTML(where, html);
    return;
  }

  void _insertAdjacentHTML(where, html) native "HTMLElement_insertAdjacentHTML_Callback";

  void insertAdjacentText(String where, String text) {
    _insertAdjacentText(where, text);
    return;
  }

  void _insertAdjacentText(where, text) native "HTMLElement_insertAdjacentText_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLEmbedElementDOMImpl extends _HTMLElementDOMImpl implements EmbedElement {
  _HTMLEmbedElementDOMImpl();
  String get typeName() => "HTMLEmbedElement";

  String get align() native "HTMLEmbedElement_align_Getter";

  void set align(String) native "HTMLEmbedElement_align_Setter";

  String get height() native "HTMLEmbedElement_height_Getter";

  void set height(String) native "HTMLEmbedElement_height_Setter";

  String get name() native "HTMLEmbedElement_name_Getter";

  void set name(String) native "HTMLEmbedElement_name_Setter";

  String get src() native "HTMLEmbedElement_src_Getter";

  void set src(String) native "HTMLEmbedElement_src_Setter";

  String get type() native "HTMLEmbedElement_type_Getter";

  void set type(String) native "HTMLEmbedElement_type_Setter";

  String get width() native "HTMLEmbedElement_width_Getter";

  void set width(String) native "HTMLEmbedElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLFieldSetElementDOMImpl extends _HTMLElementDOMImpl implements FieldSetElement {
  _HTMLFieldSetElementDOMImpl();
  String get typeName() => "HTMLFieldSetElement";

  bool get disabled() native "HTMLFieldSetElement_disabled_Getter";

  void set disabled(bool) native "HTMLFieldSetElement_disabled_Setter";

  FormElement get form() native "HTMLFieldSetElement_form_Getter";

  String get name() native "HTMLFieldSetElement_name_Getter";

  void set name(String) native "HTMLFieldSetElement_name_Setter";

  String get type() native "HTMLFieldSetElement_type_Getter";

  String get validationMessage() native "HTMLFieldSetElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLFieldSetElement_validity_Getter";

  bool get willValidate() native "HTMLFieldSetElement_willValidate_Getter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLFieldSetElement_checkValidity_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLFieldSetElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLFontElementDOMImpl extends _HTMLElementDOMImpl implements FontElement {
  _HTMLFontElementDOMImpl();
  String get typeName() => "HTMLFontElement";

  String get color() native "HTMLFontElement_color_Getter";

  void set color(String) native "HTMLFontElement_color_Setter";

  String get face() native "HTMLFontElement_face_Getter";

  void set face(String) native "HTMLFontElement_face_Setter";

  String get size() native "HTMLFontElement_size_Getter";

  void set size(String) native "HTMLFontElement_size_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLFormElementDOMImpl extends _HTMLElementDOMImpl implements FormElement {
  _HTMLFormElementDOMImpl();
  String get typeName() => "HTMLFormElement";

  String get acceptCharset() native "HTMLFormElement_acceptCharset_Getter";

  void set acceptCharset(String) native "HTMLFormElement_acceptCharset_Setter";

  String get action() native "HTMLFormElement_action_Getter";

  void set action(String) native "HTMLFormElement_action_Setter";

  String get autocomplete() native "HTMLFormElement_autocomplete_Getter";

  void set autocomplete(String) native "HTMLFormElement_autocomplete_Setter";

  String get encoding() native "HTMLFormElement_encoding_Getter";

  void set encoding(String) native "HTMLFormElement_encoding_Setter";

  String get enctype() native "HTMLFormElement_enctype_Getter";

  void set enctype(String) native "HTMLFormElement_enctype_Setter";

  int get length() native "HTMLFormElement_length_Getter";

  String get method() native "HTMLFormElement_method_Getter";

  void set method(String) native "HTMLFormElement_method_Setter";

  String get name() native "HTMLFormElement_name_Getter";

  void set name(String) native "HTMLFormElement_name_Setter";

  bool get noValidate() native "HTMLFormElement_noValidate_Getter";

  void set noValidate(bool) native "HTMLFormElement_noValidate_Setter";

  String get target() native "HTMLFormElement_target_Getter";

  void set target(String) native "HTMLFormElement_target_Setter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLFormElement_checkValidity_Callback";

  void reset() {
    _reset();
    return;
  }

  void _reset() native "HTMLFormElement_reset_Callback";

  void submit() {
    _submit();
    return;
  }

  void _submit() native "HTMLFormElement_submit_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLFrameElementDOMImpl extends _HTMLElementDOMImpl implements FrameElement {
  _HTMLFrameElementDOMImpl();
  String get typeName() => "HTMLFrameElement";

  Window get contentWindow() native "HTMLFrameElement_contentWindow_Getter";

  String get frameBorder() native "HTMLFrameElement_frameBorder_Getter";

  void set frameBorder(String) native "HTMLFrameElement_frameBorder_Setter";

  int get height() native "HTMLFrameElement_height_Getter";

  String get location() native "HTMLFrameElement_location_Getter";

  void set location(String) native "HTMLFrameElement_location_Setter";

  String get longDesc() native "HTMLFrameElement_longDesc_Getter";

  void set longDesc(String) native "HTMLFrameElement_longDesc_Setter";

  String get marginHeight() native "HTMLFrameElement_marginHeight_Getter";

  void set marginHeight(String) native "HTMLFrameElement_marginHeight_Setter";

  String get marginWidth() native "HTMLFrameElement_marginWidth_Getter";

  void set marginWidth(String) native "HTMLFrameElement_marginWidth_Setter";

  String get name() native "HTMLFrameElement_name_Getter";

  void set name(String) native "HTMLFrameElement_name_Setter";

  bool get noResize() native "HTMLFrameElement_noResize_Getter";

  void set noResize(bool) native "HTMLFrameElement_noResize_Setter";

  String get scrolling() native "HTMLFrameElement_scrolling_Getter";

  void set scrolling(String) native "HTMLFrameElement_scrolling_Setter";

  String get src() native "HTMLFrameElement_src_Getter";

  void set src(String) native "HTMLFrameElement_src_Setter";

  int get width() native "HTMLFrameElement_width_Getter";

}

class _HTMLFrameSetElementEventsImpl extends _ElementEventsImpl implements FrameSetElementEvents {
  _HTMLFrameSetElementEventsImpl(_ptr) : super(_ptr);
  EventListenerList get beforeUnload() => _get('beforeunload');
  EventListenerList get blur() => _get('blur');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get hashChange() => _get('hashchange');
  EventListenerList get load() => _get('load');
  EventListenerList get message() => _get('message');
  EventListenerList get offline() => _get('offline');
  EventListenerList get online() => _get('online');
  EventListenerList get popState() => _get('popstate');
  EventListenerList get resize() => _get('resize');
  EventListenerList get storage() => _get('storage');
  EventListenerList get unload() => _get('unload');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLFrameSetElementDOMImpl extends _HTMLElementDOMImpl implements FrameSetElement {
  _HTMLFrameSetElementDOMImpl();
  String get typeName() => "HTMLFrameSetElement";

  _HTMLFrameSetElementEventsImpl get on() {
    if (_on === null) _on = new _HTMLFrameSetElementEventsImpl(this);
    return _on;
  }

  String get cols() native "HTMLFrameSetElement_cols_Getter";

  void set cols(String) native "HTMLFrameSetElement_cols_Setter";

  String get rows() native "HTMLFrameSetElement_rows_Getter";

  void set rows(String) native "HTMLFrameSetElement_rows_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLHRElementDOMImpl extends _HTMLElementDOMImpl implements HRElement {
  _HTMLHRElementDOMImpl();
  String get typeName() => "HTMLHRElement";

  String get align() native "HTMLHRElement_align_Getter";

  void set align(String) native "HTMLHRElement_align_Setter";

  bool get noShade() native "HTMLHRElement_noShade_Getter";

  void set noShade(bool) native "HTMLHRElement_noShade_Setter";

  String get size() native "HTMLHRElement_size_Getter";

  void set size(String) native "HTMLHRElement_size_Setter";

  String get width() native "HTMLHRElement_width_Getter";

  void set width(String) native "HTMLHRElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLHeadElementDOMImpl extends _HTMLElementDOMImpl implements HeadElement {
  _HTMLHeadElementDOMImpl();
  String get typeName() => "HTMLHeadElement";

  String get profile() native "HTMLHeadElement_profile_Getter";

  void set profile(String) native "HTMLHeadElement_profile_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLHeadingElementDOMImpl extends _HTMLElementDOMImpl implements HeadingElement {
  _HTMLHeadingElementDOMImpl();
  String get typeName() => "HTMLHeadingElement";

  String get align() native "HTMLHeadingElement_align_Getter";

  void set align(String) native "HTMLHeadingElement_align_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLHtmlElementDOMImpl extends _HTMLElementDOMImpl implements HtmlElement {
  _HTMLHtmlElementDOMImpl();
  String get typeName() => "HTMLHtmlElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLIFrameElementDOMImpl extends _HTMLElementDOMImpl implements IFrameElement {
  _HTMLIFrameElementDOMImpl();
  String get typeName() => "HTMLIFrameElement";

  String get align() native "HTMLIFrameElement_align_Getter";

  void set align(String) native "HTMLIFrameElement_align_Setter";

  Window get contentWindow() native "HTMLIFrameElement_contentWindow_Getter";

  String get frameBorder() native "HTMLIFrameElement_frameBorder_Getter";

  void set frameBorder(String) native "HTMLIFrameElement_frameBorder_Setter";

  String get height() native "HTMLIFrameElement_height_Getter";

  void set height(String) native "HTMLIFrameElement_height_Setter";

  String get longDesc() native "HTMLIFrameElement_longDesc_Getter";

  void set longDesc(String) native "HTMLIFrameElement_longDesc_Setter";

  String get marginHeight() native "HTMLIFrameElement_marginHeight_Getter";

  void set marginHeight(String) native "HTMLIFrameElement_marginHeight_Setter";

  String get marginWidth() native "HTMLIFrameElement_marginWidth_Getter";

  void set marginWidth(String) native "HTMLIFrameElement_marginWidth_Setter";

  String get name() native "HTMLIFrameElement_name_Getter";

  void set name(String) native "HTMLIFrameElement_name_Setter";

  String get sandbox() native "HTMLIFrameElement_sandbox_Getter";

  void set sandbox(String) native "HTMLIFrameElement_sandbox_Setter";

  String get scrolling() native "HTMLIFrameElement_scrolling_Getter";

  void set scrolling(String) native "HTMLIFrameElement_scrolling_Setter";

  String get src() native "HTMLIFrameElement_src_Getter";

  void set src(String) native "HTMLIFrameElement_src_Setter";

  String get srcdoc() native "HTMLIFrameElement_srcdoc_Getter";

  void set srcdoc(String) native "HTMLIFrameElement_srcdoc_Setter";

  String get width() native "HTMLIFrameElement_width_Getter";

  void set width(String) native "HTMLIFrameElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLImageElementDOMImpl extends _HTMLElementDOMImpl implements ImageElement {
  _HTMLImageElementDOMImpl();
  String get typeName() => "HTMLImageElement";

  String get align() native "HTMLImageElement_align_Getter";

  void set align(String) native "HTMLImageElement_align_Setter";

  String get alt() native "HTMLImageElement_alt_Getter";

  void set alt(String) native "HTMLImageElement_alt_Setter";

  String get border() native "HTMLImageElement_border_Getter";

  void set border(String) native "HTMLImageElement_border_Setter";

  bool get complete() native "HTMLImageElement_complete_Getter";

  String get crossOrigin() native "HTMLImageElement_crossOrigin_Getter";

  void set crossOrigin(String) native "HTMLImageElement_crossOrigin_Setter";

  int get height() native "HTMLImageElement_height_Getter";

  void set height(int) native "HTMLImageElement_height_Setter";

  int get hspace() native "HTMLImageElement_hspace_Getter";

  void set hspace(int) native "HTMLImageElement_hspace_Setter";

  bool get isMap() native "HTMLImageElement_isMap_Getter";

  void set isMap(bool) native "HTMLImageElement_isMap_Setter";

  String get longDesc() native "HTMLImageElement_longDesc_Getter";

  void set longDesc(String) native "HTMLImageElement_longDesc_Setter";

  String get lowsrc() native "HTMLImageElement_lowsrc_Getter";

  void set lowsrc(String) native "HTMLImageElement_lowsrc_Setter";

  String get name() native "HTMLImageElement_name_Getter";

  void set name(String) native "HTMLImageElement_name_Setter";

  int get naturalHeight() native "HTMLImageElement_naturalHeight_Getter";

  int get naturalWidth() native "HTMLImageElement_naturalWidth_Getter";

  String get src() native "HTMLImageElement_src_Getter";

  void set src(String) native "HTMLImageElement_src_Setter";

  String get useMap() native "HTMLImageElement_useMap_Getter";

  void set useMap(String) native "HTMLImageElement_useMap_Setter";

  int get vspace() native "HTMLImageElement_vspace_Getter";

  void set vspace(int) native "HTMLImageElement_vspace_Setter";

  int get width() native "HTMLImageElement_width_Getter";

  void set width(int) native "HTMLImageElement_width_Setter";

  int get x() native "HTMLImageElement_x_Getter";

  int get y() native "HTMLImageElement_y_Getter";

}

class _HTMLInputElementEventsImpl extends _ElementEventsImpl implements InputElementEvents {
  _HTMLInputElementEventsImpl(_ptr) : super(_ptr);
  EventListenerList get speechChange() => _get('webkitSpeechChange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLInputElementDOMImpl extends _HTMLElementDOMImpl implements InputElement {
  _HTMLInputElementDOMImpl();
  String get typeName() => "HTMLInputElement";

  _HTMLInputElementEventsImpl get on() {
    if (_on === null) _on = new _HTMLInputElementEventsImpl(this);
    return _on;
  }

  String get accept() native "HTMLInputElement_accept_Getter";

  void set accept(String) native "HTMLInputElement_accept_Setter";

  String get align() native "HTMLInputElement_align_Getter";

  void set align(String) native "HTMLInputElement_align_Setter";

  String get alt() native "HTMLInputElement_alt_Getter";

  void set alt(String) native "HTMLInputElement_alt_Setter";

  String get autocomplete() native "HTMLInputElement_autocomplete_Getter";

  void set autocomplete(String) native "HTMLInputElement_autocomplete_Setter";

  bool get autofocus() native "HTMLInputElement_autofocus_Getter";

  void set autofocus(bool) native "HTMLInputElement_autofocus_Setter";

  bool get checked() native "HTMLInputElement_checked_Getter";

  void set checked(bool) native "HTMLInputElement_checked_Setter";

  bool get defaultChecked() native "HTMLInputElement_defaultChecked_Getter";

  void set defaultChecked(bool) native "HTMLInputElement_defaultChecked_Setter";

  String get defaultValue() native "HTMLInputElement_defaultValue_Getter";

  void set defaultValue(String) native "HTMLInputElement_defaultValue_Setter";

  bool get disabled() native "HTMLInputElement_disabled_Getter";

  void set disabled(bool) native "HTMLInputElement_disabled_Setter";

  FileList get files() native "HTMLInputElement_files_Getter";

  FormElement get form() native "HTMLInputElement_form_Getter";

  String get formAction() native "HTMLInputElement_formAction_Getter";

  void set formAction(String) native "HTMLInputElement_formAction_Setter";

  String get formEnctype() native "HTMLInputElement_formEnctype_Getter";

  void set formEnctype(String) native "HTMLInputElement_formEnctype_Setter";

  String get formMethod() native "HTMLInputElement_formMethod_Getter";

  void set formMethod(String) native "HTMLInputElement_formMethod_Setter";

  bool get formNoValidate() native "HTMLInputElement_formNoValidate_Getter";

  void set formNoValidate(bool) native "HTMLInputElement_formNoValidate_Setter";

  String get formTarget() native "HTMLInputElement_formTarget_Getter";

  void set formTarget(String) native "HTMLInputElement_formTarget_Setter";

  int get height() native "HTMLInputElement_height_Getter";

  void set height(int) native "HTMLInputElement_height_Setter";

  bool get incremental() native "HTMLInputElement_incremental_Getter";

  void set incremental(bool) native "HTMLInputElement_incremental_Setter";

  bool get indeterminate() native "HTMLInputElement_indeterminate_Getter";

  void set indeterminate(bool) native "HTMLInputElement_indeterminate_Setter";

  NodeList get labels() native "HTMLInputElement_labels_Getter";

  String get max() native "HTMLInputElement_max_Getter";

  void set max(String) native "HTMLInputElement_max_Setter";

  int get maxLength() native "HTMLInputElement_maxLength_Getter";

  void set maxLength(int) native "HTMLInputElement_maxLength_Setter";

  String get min() native "HTMLInputElement_min_Getter";

  void set min(String) native "HTMLInputElement_min_Setter";

  bool get multiple() native "HTMLInputElement_multiple_Getter";

  void set multiple(bool) native "HTMLInputElement_multiple_Setter";

  String get name() native "HTMLInputElement_name_Getter";

  void set name(String) native "HTMLInputElement_name_Setter";

  String get pattern() native "HTMLInputElement_pattern_Getter";

  void set pattern(String) native "HTMLInputElement_pattern_Setter";

  String get placeholder() native "HTMLInputElement_placeholder_Getter";

  void set placeholder(String) native "HTMLInputElement_placeholder_Setter";

  bool get readOnly() native "HTMLInputElement_readOnly_Getter";

  void set readOnly(bool) native "HTMLInputElement_readOnly_Setter";

  bool get required() native "HTMLInputElement_required_Getter";

  void set required(bool) native "HTMLInputElement_required_Setter";

  String get selectionDirection() native "HTMLInputElement_selectionDirection_Getter";

  void set selectionDirection(String) native "HTMLInputElement_selectionDirection_Setter";

  int get selectionEnd() native "HTMLInputElement_selectionEnd_Getter";

  void set selectionEnd(int) native "HTMLInputElement_selectionEnd_Setter";

  int get selectionStart() native "HTMLInputElement_selectionStart_Getter";

  void set selectionStart(int) native "HTMLInputElement_selectionStart_Setter";

  int get size() native "HTMLInputElement_size_Getter";

  void set size(int) native "HTMLInputElement_size_Setter";

  String get src() native "HTMLInputElement_src_Getter";

  void set src(String) native "HTMLInputElement_src_Setter";

  String get step() native "HTMLInputElement_step_Getter";

  void set step(String) native "HTMLInputElement_step_Setter";

  String get type() native "HTMLInputElement_type_Getter";

  void set type(String) native "HTMLInputElement_type_Setter";

  String get useMap() native "HTMLInputElement_useMap_Getter";

  void set useMap(String) native "HTMLInputElement_useMap_Setter";

  String get validationMessage() native "HTMLInputElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLInputElement_validity_Getter";

  String get value() native "HTMLInputElement_value_Getter";

  void set value(String) native "HTMLInputElement_value_Setter";

  Date get valueAsDate() native "HTMLInputElement_valueAsDate_Getter";

  void set valueAsDate(Date) native "HTMLInputElement_valueAsDate_Setter";

  num get valueAsNumber() native "HTMLInputElement_valueAsNumber_Getter";

  void set valueAsNumber(num) native "HTMLInputElement_valueAsNumber_Setter";

  bool get webkitGrammar() native "HTMLInputElement_webkitGrammar_Getter";

  void set webkitGrammar(bool) native "HTMLInputElement_webkitGrammar_Setter";

  bool get webkitSpeech() native "HTMLInputElement_webkitSpeech_Getter";

  void set webkitSpeech(bool) native "HTMLInputElement_webkitSpeech_Setter";

  bool get webkitdirectory() native "HTMLInputElement_webkitdirectory_Getter";

  void set webkitdirectory(bool) native "HTMLInputElement_webkitdirectory_Setter";

  int get width() native "HTMLInputElement_width_Getter";

  void set width(int) native "HTMLInputElement_width_Setter";

  bool get willValidate() native "HTMLInputElement_willValidate_Getter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLInputElement_checkValidity_Callback";

  void select() {
    _select();
    return;
  }

  void _select() native "HTMLInputElement_select_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLInputElement_setCustomValidity_Callback";

  void setSelectionRange(int start, int end, [String direction = null]) native "HTMLInputElement_setSelectionRange_Callback";

  void stepDown([int n = null]) {
    //
    // stepDown()
    // stepDown([Optional] int n)
    //
    // -- reduced:
    // stepDown([Optional] int n)
    //
    _stepDown(n);
    return;
  }

  void _stepDown(n) native "HTMLInputElement_stepDown_Callback";

  void stepUp([int n = null]) {
    //
    // stepUp()
    // stepUp([Optional] int n)
    //
    // -- reduced:
    // stepUp([Optional] int n)
    //
    _stepUp(n);
    return;
  }

  void _stepUp(n) native "HTMLInputElement_stepUp_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLKeygenElementDOMImpl extends _HTMLElementDOMImpl implements KeygenElement {
  _HTMLKeygenElementDOMImpl();
  String get typeName() => "HTMLKeygenElement";

  bool get autofocus() native "HTMLKeygenElement_autofocus_Getter";

  void set autofocus(bool) native "HTMLKeygenElement_autofocus_Setter";

  String get challenge() native "HTMLKeygenElement_challenge_Getter";

  void set challenge(String) native "HTMLKeygenElement_challenge_Setter";

  bool get disabled() native "HTMLKeygenElement_disabled_Getter";

  void set disabled(bool) native "HTMLKeygenElement_disabled_Setter";

  FormElement get form() native "HTMLKeygenElement_form_Getter";

  String get keytype() native "HTMLKeygenElement_keytype_Getter";

  void set keytype(String) native "HTMLKeygenElement_keytype_Setter";

  NodeList get labels() native "HTMLKeygenElement_labels_Getter";

  String get name() native "HTMLKeygenElement_name_Getter";

  void set name(String) native "HTMLKeygenElement_name_Setter";

  String get type() native "HTMLKeygenElement_type_Getter";

  String get validationMessage() native "HTMLKeygenElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLKeygenElement_validity_Getter";

  bool get willValidate() native "HTMLKeygenElement_willValidate_Getter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLKeygenElement_checkValidity_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLKeygenElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLLIElementDOMImpl extends _HTMLElementDOMImpl implements LIElement {
  _HTMLLIElementDOMImpl();
  String get typeName() => "HTMLLIElement";

  String get type() native "HTMLLIElement_type_Getter";

  void set type(String) native "HTMLLIElement_type_Setter";

  int get value() native "HTMLLIElement_value_Getter";

  void set value(int) native "HTMLLIElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLLabelElementDOMImpl extends _HTMLElementDOMImpl implements LabelElement {
  _HTMLLabelElementDOMImpl();
  String get typeName() => "HTMLLabelElement";

  Element get control() native "HTMLLabelElement_control_Getter";

  FormElement get form() native "HTMLLabelElement_form_Getter";

  String get htmlFor() native "HTMLLabelElement_htmlFor_Getter";

  void set htmlFor(String) native "HTMLLabelElement_htmlFor_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLLegendElementDOMImpl extends _HTMLElementDOMImpl implements LegendElement {
  _HTMLLegendElementDOMImpl();
  String get typeName() => "HTMLLegendElement";

  String get align() native "HTMLLegendElement_align_Getter";

  void set align(String) native "HTMLLegendElement_align_Setter";

  FormElement get form() native "HTMLLegendElement_form_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLLinkElementDOMImpl extends _HTMLElementDOMImpl implements LinkElement {
  _HTMLLinkElementDOMImpl();
  String get typeName() => "HTMLLinkElement";

  String get charset() native "HTMLLinkElement_charset_Getter";

  void set charset(String) native "HTMLLinkElement_charset_Setter";

  bool get disabled() native "HTMLLinkElement_disabled_Getter";

  void set disabled(bool) native "HTMLLinkElement_disabled_Setter";

  String get href() native "HTMLLinkElement_href_Getter";

  void set href(String) native "HTMLLinkElement_href_Setter";

  String get hreflang() native "HTMLLinkElement_hreflang_Getter";

  void set hreflang(String) native "HTMLLinkElement_hreflang_Setter";

  String get media() native "HTMLLinkElement_media_Getter";

  void set media(String) native "HTMLLinkElement_media_Setter";

  String get rel() native "HTMLLinkElement_rel_Getter";

  void set rel(String) native "HTMLLinkElement_rel_Setter";

  String get rev() native "HTMLLinkElement_rev_Getter";

  void set rev(String) native "HTMLLinkElement_rev_Setter";

  StyleSheet get sheet() native "HTMLLinkElement_sheet_Getter";

  DOMSettableTokenList get sizes() native "HTMLLinkElement_sizes_Getter";

  void set sizes(DOMSettableTokenList) native "HTMLLinkElement_sizes_Setter";

  String get target() native "HTMLLinkElement_target_Getter";

  void set target(String) native "HTMLLinkElement_target_Setter";

  String get type() native "HTMLLinkElement_type_Getter";

  void set type(String) native "HTMLLinkElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLMapElementDOMImpl extends _HTMLElementDOMImpl implements MapElement {
  _HTMLMapElementDOMImpl();
  String get typeName() => "HTMLMapElement";

  HTMLCollection get areas() native "HTMLMapElement_areas_Getter";

  String get name() native "HTMLMapElement_name_Getter";

  void set name(String) native "HTMLMapElement_name_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLMarqueeElementDOMImpl extends _HTMLElementDOMImpl implements MarqueeElement {
  _HTMLMarqueeElementDOMImpl();
  String get typeName() => "HTMLMarqueeElement";

  String get behavior() native "HTMLMarqueeElement_behavior_Getter";

  void set behavior(String) native "HTMLMarqueeElement_behavior_Setter";

  String get bgColor() native "HTMLMarqueeElement_bgColor_Getter";

  void set bgColor(String) native "HTMLMarqueeElement_bgColor_Setter";

  String get direction() native "HTMLMarqueeElement_direction_Getter";

  void set direction(String) native "HTMLMarqueeElement_direction_Setter";

  String get height() native "HTMLMarqueeElement_height_Getter";

  void set height(String) native "HTMLMarqueeElement_height_Setter";

  int get hspace() native "HTMLMarqueeElement_hspace_Getter";

  void set hspace(int) native "HTMLMarqueeElement_hspace_Setter";

  int get loop() native "HTMLMarqueeElement_loop_Getter";

  void set loop(int) native "HTMLMarqueeElement_loop_Setter";

  int get scrollAmount() native "HTMLMarqueeElement_scrollAmount_Getter";

  void set scrollAmount(int) native "HTMLMarqueeElement_scrollAmount_Setter";

  int get scrollDelay() native "HTMLMarqueeElement_scrollDelay_Getter";

  void set scrollDelay(int) native "HTMLMarqueeElement_scrollDelay_Setter";

  bool get trueSpeed() native "HTMLMarqueeElement_trueSpeed_Getter";

  void set trueSpeed(bool) native "HTMLMarqueeElement_trueSpeed_Setter";

  int get vspace() native "HTMLMarqueeElement_vspace_Getter";

  void set vspace(int) native "HTMLMarqueeElement_vspace_Setter";

  String get width() native "HTMLMarqueeElement_width_Getter";

  void set width(String) native "HTMLMarqueeElement_width_Setter";

  void start() {
    _start();
    return;
  }

  void _start() native "HTMLMarqueeElement_start_Callback";

  void stop() {
    _stop();
    return;
  }

  void _stop() native "HTMLMarqueeElement_stop_Callback";

}

class _HTMLMediaElementEventsImpl extends _ElementEventsImpl implements MediaElementEvents {
  _HTMLMediaElementEventsImpl(_ptr) : super(_ptr);
  EventListenerList get keyAdded() => _get('webkitkeyadded');
  EventListenerList get keyError() => _get('webkitkeyerror');
  EventListenerList get keyMessage() => _get('webkitkeymessage');
  EventListenerList get needKey() => _get('webkitneedkey');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLMediaElementDOMImpl extends _HTMLElementDOMImpl implements MediaElement {
  _HTMLMediaElementDOMImpl();
  String get typeName() => "HTMLMediaElement";

  _HTMLMediaElementEventsImpl get on() {
    if (_on === null) _on = new _HTMLMediaElementEventsImpl(this);
    return _on;
  }

  bool get autoplay() native "HTMLMediaElement_autoplay_Getter";

  void set autoplay(bool) native "HTMLMediaElement_autoplay_Setter";

  TimeRanges get buffered() native "HTMLMediaElement_buffered_Getter";

  MediaController get controller() native "HTMLMediaElement_controller_Getter";

  void set controller(MediaController) native "HTMLMediaElement_controller_Setter";

  bool get controls() native "HTMLMediaElement_controls_Getter";

  void set controls(bool) native "HTMLMediaElement_controls_Setter";

  String get currentSrc() native "HTMLMediaElement_currentSrc_Getter";

  num get currentTime() native "HTMLMediaElement_currentTime_Getter";

  void set currentTime(num) native "HTMLMediaElement_currentTime_Setter";

  bool get defaultMuted() native "HTMLMediaElement_defaultMuted_Getter";

  void set defaultMuted(bool) native "HTMLMediaElement_defaultMuted_Setter";

  num get defaultPlaybackRate() native "HTMLMediaElement_defaultPlaybackRate_Getter";

  void set defaultPlaybackRate(num) native "HTMLMediaElement_defaultPlaybackRate_Setter";

  num get duration() native "HTMLMediaElement_duration_Getter";

  bool get ended() native "HTMLMediaElement_ended_Getter";

  MediaError get error() native "HTMLMediaElement_error_Getter";

  num get initialTime() native "HTMLMediaElement_initialTime_Getter";

  bool get loop() native "HTMLMediaElement_loop_Getter";

  void set loop(bool) native "HTMLMediaElement_loop_Setter";

  String get mediaGroup() native "HTMLMediaElement_mediaGroup_Getter";

  void set mediaGroup(String) native "HTMLMediaElement_mediaGroup_Setter";

  bool get muted() native "HTMLMediaElement_muted_Getter";

  void set muted(bool) native "HTMLMediaElement_muted_Setter";

  int get networkState() native "HTMLMediaElement_networkState_Getter";

  bool get paused() native "HTMLMediaElement_paused_Getter";

  num get playbackRate() native "HTMLMediaElement_playbackRate_Getter";

  void set playbackRate(num) native "HTMLMediaElement_playbackRate_Setter";

  TimeRanges get played() native "HTMLMediaElement_played_Getter";

  String get preload() native "HTMLMediaElement_preload_Getter";

  void set preload(String) native "HTMLMediaElement_preload_Setter";

  int get readyState() native "HTMLMediaElement_readyState_Getter";

  TimeRanges get seekable() native "HTMLMediaElement_seekable_Getter";

  bool get seeking() native "HTMLMediaElement_seeking_Getter";

  String get src() native "HTMLMediaElement_src_Getter";

  void set src(String) native "HTMLMediaElement_src_Setter";

  num get startTime() native "HTMLMediaElement_startTime_Getter";

  TextTrackList get textTracks() native "HTMLMediaElement_textTracks_Getter";

  num get volume() native "HTMLMediaElement_volume_Getter";

  void set volume(num) native "HTMLMediaElement_volume_Setter";

  int get webkitAudioDecodedByteCount() native "HTMLMediaElement_webkitAudioDecodedByteCount_Getter";

  bool get webkitClosedCaptionsVisible() native "HTMLMediaElement_webkitClosedCaptionsVisible_Getter";

  void set webkitClosedCaptionsVisible(bool) native "HTMLMediaElement_webkitClosedCaptionsVisible_Setter";

  bool get webkitHasClosedCaptions() native "HTMLMediaElement_webkitHasClosedCaptions_Getter";

  String get webkitMediaSourceURL() native "HTMLMediaElement_webkitMediaSourceURL_Getter";

  bool get webkitPreservesPitch() native "HTMLMediaElement_webkitPreservesPitch_Getter";

  void set webkitPreservesPitch(bool) native "HTMLMediaElement_webkitPreservesPitch_Setter";

  int get webkitSourceState() native "HTMLMediaElement_webkitSourceState_Getter";

  int get webkitVideoDecodedByteCount() native "HTMLMediaElement_webkitVideoDecodedByteCount_Getter";

  TextTrack addTextTrack(String kind, [String label = null, String language = null]) {
    //
    // addTextTrack(String kind)
    // addTextTrack(String kind, [Optional] String label)
    // addTextTrack(String kind, [Optional] String label, [Optional] String language)
    //
    // -- reduced:
    // addTextTrack(String kind, [Optional] String label, [Optional] String language)
    //
    return _addTextTrack(kind, label, language);
  }

  TextTrack _addTextTrack(kind, label, language) native "HTMLMediaElement_addTextTrack_Callback";

  String canPlayType(String type, String keySystem) {
    return _canPlayType(type, keySystem);
  }

  String _canPlayType(type, keySystem) native "HTMLMediaElement_canPlayType_Callback";

  void load() {
    _load();
    return;
  }

  void _load() native "HTMLMediaElement_load_Callback";

  void pause() {
    _pause();
    return;
  }

  void _pause() native "HTMLMediaElement_pause_Callback";

  void play() {
    _play();
    return;
  }

  void _play() native "HTMLMediaElement_play_Callback";

  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData = null, String sessionId = null]) {
    //
    // webkitAddKey(String keySystem, Uint8Array key)
    // webkitAddKey(String keySystem, Uint8Array key, [Optional] Uint8Array initData, String sessionId)
    //
    if (initData === null && sessionId === null) {
      _webkitAddKey(keySystem, key);
      return;
    }
    _webkitAddKey_2(keySystem, key, initData, sessionId);
    return;
  }

  void _webkitAddKey(keySystem, key) native "HTMLMediaElement_webkitAddKey_Callback";

  void _webkitAddKey_2(keySystem, key, initData, sessionId) native "HTMLMediaElement_webkitAddKey_2_Callback";

  void webkitCancelKeyRequest(String keySystem, String sessionId) {
    _webkitCancelKeyRequest(keySystem, sessionId);
    return;
  }

  void _webkitCancelKeyRequest(keySystem, sessionId) native "HTMLMediaElement_webkitCancelKeyRequest_Callback";

  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData = null]) {
    //
    // webkitGenerateKeyRequest(String keySystem)
    // webkitGenerateKeyRequest(String keySystem, [Optional] Uint8Array initData)
    //
    if (initData === null) {
      _webkitGenerateKeyRequest(keySystem);
      return;
    }
    _webkitGenerateKeyRequest_2(keySystem, initData);
    return;
  }

  void _webkitGenerateKeyRequest(keySystem) native "HTMLMediaElement_webkitGenerateKeyRequest_Callback";

  void _webkitGenerateKeyRequest_2(keySystem, initData) native "HTMLMediaElement_webkitGenerateKeyRequest_2_Callback";

  void webkitSourceAppend(Uint8Array data) {
    _webkitSourceAppend(data);
    return;
  }

  void _webkitSourceAppend(data) native "HTMLMediaElement_webkitSourceAppend_Callback";

  void webkitSourceEndOfStream(int status) {
    _webkitSourceEndOfStream(status);
    return;
  }

  void _webkitSourceEndOfStream(status) native "HTMLMediaElement_webkitSourceEndOfStream_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLMenuElementDOMImpl extends _HTMLElementDOMImpl implements MenuElement {
  _HTMLMenuElementDOMImpl();
  String get typeName() => "HTMLMenuElement";

  bool get compact() native "HTMLMenuElement_compact_Getter";

  void set compact(bool) native "HTMLMenuElement_compact_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLMetaElementDOMImpl extends _HTMLElementDOMImpl implements MetaElement {
  _HTMLMetaElementDOMImpl();
  String get typeName() => "HTMLMetaElement";

  String get content() native "HTMLMetaElement_content_Getter";

  void set content(String) native "HTMLMetaElement_content_Setter";

  String get httpEquiv() native "HTMLMetaElement_httpEquiv_Getter";

  void set httpEquiv(String) native "HTMLMetaElement_httpEquiv_Setter";

  String get name() native "HTMLMetaElement_name_Getter";

  void set name(String) native "HTMLMetaElement_name_Setter";

  String get scheme() native "HTMLMetaElement_scheme_Getter";

  void set scheme(String) native "HTMLMetaElement_scheme_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLMeterElementDOMImpl extends _HTMLElementDOMImpl implements MeterElement {
  _HTMLMeterElementDOMImpl();
  String get typeName() => "HTMLMeterElement";

  num get high() native "HTMLMeterElement_high_Getter";

  void set high(num) native "HTMLMeterElement_high_Setter";

  NodeList get labels() native "HTMLMeterElement_labels_Getter";

  num get low() native "HTMLMeterElement_low_Getter";

  void set low(num) native "HTMLMeterElement_low_Setter";

  num get max() native "HTMLMeterElement_max_Getter";

  void set max(num) native "HTMLMeterElement_max_Setter";

  num get min() native "HTMLMeterElement_min_Getter";

  void set min(num) native "HTMLMeterElement_min_Setter";

  num get optimum() native "HTMLMeterElement_optimum_Getter";

  void set optimum(num) native "HTMLMeterElement_optimum_Setter";

  num get value() native "HTMLMeterElement_value_Getter";

  void set value(num) native "HTMLMeterElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLModElementDOMImpl extends _HTMLElementDOMImpl implements ModElement {
  _HTMLModElementDOMImpl();
  String get typeName() => "HTMLModElement";

  String get cite() native "HTMLModElement_cite_Getter";

  void set cite(String) native "HTMLModElement_cite_Setter";

  String get dateTime() native "HTMLModElement_dateTime_Getter";

  void set dateTime(String) native "HTMLModElement_dateTime_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLOListElementDOMImpl extends _HTMLElementDOMImpl implements OListElement {
  _HTMLOListElementDOMImpl();
  String get typeName() => "HTMLOListElement";

  bool get compact() native "HTMLOListElement_compact_Getter";

  void set compact(bool) native "HTMLOListElement_compact_Setter";

  bool get reversed() native "HTMLOListElement_reversed_Getter";

  void set reversed(bool) native "HTMLOListElement_reversed_Setter";

  int get start() native "HTMLOListElement_start_Getter";

  void set start(int) native "HTMLOListElement_start_Setter";

  String get type() native "HTMLOListElement_type_Getter";

  void set type(String) native "HTMLOListElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLObjectElementDOMImpl extends _HTMLElementDOMImpl implements ObjectElement {
  _HTMLObjectElementDOMImpl();
  String get typeName() => "HTMLObjectElement";

  String get align() native "HTMLObjectElement_align_Getter";

  void set align(String) native "HTMLObjectElement_align_Setter";

  String get archive() native "HTMLObjectElement_archive_Getter";

  void set archive(String) native "HTMLObjectElement_archive_Setter";

  String get border() native "HTMLObjectElement_border_Getter";

  void set border(String) native "HTMLObjectElement_border_Setter";

  String get code() native "HTMLObjectElement_code_Getter";

  void set code(String) native "HTMLObjectElement_code_Setter";

  String get codeBase() native "HTMLObjectElement_codeBase_Getter";

  void set codeBase(String) native "HTMLObjectElement_codeBase_Setter";

  String get codeType() native "HTMLObjectElement_codeType_Getter";

  void set codeType(String) native "HTMLObjectElement_codeType_Setter";

  String get data() native "HTMLObjectElement_data_Getter";

  void set data(String) native "HTMLObjectElement_data_Setter";

  bool get declare() native "HTMLObjectElement_declare_Getter";

  void set declare(bool) native "HTMLObjectElement_declare_Setter";

  FormElement get form() native "HTMLObjectElement_form_Getter";

  String get height() native "HTMLObjectElement_height_Getter";

  void set height(String) native "HTMLObjectElement_height_Setter";

  int get hspace() native "HTMLObjectElement_hspace_Getter";

  void set hspace(int) native "HTMLObjectElement_hspace_Setter";

  String get name() native "HTMLObjectElement_name_Getter";

  void set name(String) native "HTMLObjectElement_name_Setter";

  String get standby() native "HTMLObjectElement_standby_Getter";

  void set standby(String) native "HTMLObjectElement_standby_Setter";

  String get type() native "HTMLObjectElement_type_Getter";

  void set type(String) native "HTMLObjectElement_type_Setter";

  String get useMap() native "HTMLObjectElement_useMap_Getter";

  void set useMap(String) native "HTMLObjectElement_useMap_Setter";

  String get validationMessage() native "HTMLObjectElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLObjectElement_validity_Getter";

  int get vspace() native "HTMLObjectElement_vspace_Getter";

  void set vspace(int) native "HTMLObjectElement_vspace_Setter";

  String get width() native "HTMLObjectElement_width_Getter";

  void set width(String) native "HTMLObjectElement_width_Setter";

  bool get willValidate() native "HTMLObjectElement_willValidate_Getter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLObjectElement_checkValidity_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLObjectElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLOptGroupElementDOMImpl extends _HTMLElementDOMImpl implements OptGroupElement {
  _HTMLOptGroupElementDOMImpl();
  String get typeName() => "HTMLOptGroupElement";

  bool get disabled() native "HTMLOptGroupElement_disabled_Getter";

  void set disabled(bool) native "HTMLOptGroupElement_disabled_Setter";

  String get label() native "HTMLOptGroupElement_label_Getter";

  void set label(String) native "HTMLOptGroupElement_label_Setter";

}
class _HTMLOptionElementFactoryProviderImpl {
  static _HTMLOptionElementDOMImpl createHTMLOptionElement([String data = null, String value = null, bool defaultSelected = null, bool selected = null])
      native "HTMLOptionElement_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLOptionElementDOMImpl extends _HTMLElementDOMImpl implements OptionElement {
  _HTMLOptionElementDOMImpl();
  String get typeName() => "HTMLOptionElement";

  bool get defaultSelected() native "HTMLOptionElement_defaultSelected_Getter";

  void set defaultSelected(bool) native "HTMLOptionElement_defaultSelected_Setter";

  bool get disabled() native "HTMLOptionElement_disabled_Getter";

  void set disabled(bool) native "HTMLOptionElement_disabled_Setter";

  FormElement get form() native "HTMLOptionElement_form_Getter";

  int get index() native "HTMLOptionElement_index_Getter";

  String get label() native "HTMLOptionElement_label_Getter";

  void set label(String) native "HTMLOptionElement_label_Setter";

  bool get selected() native "HTMLOptionElement_selected_Getter";

  void set selected(bool) native "HTMLOptionElement_selected_Setter";

  String get value() native "HTMLOptionElement_value_Getter";

  void set value(String) native "HTMLOptionElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLOptionsCollectionDOMImpl extends _HTMLCollectionDOMImpl implements HTMLOptionsCollection {
  _HTMLOptionsCollectionDOMImpl();
  String get typeName() => "HTMLOptionsCollection";

  int get length() native "HTMLOptionsCollection_length_Getter";

  void set length(int) native "HTMLOptionsCollection_length_Setter";

  int get selectedIndex() native "HTMLOptionsCollection_selectedIndex_Getter";

  void set selectedIndex(int) native "HTMLOptionsCollection_selectedIndex_Setter";

  void operator[]=(int index, Node value) native "HTMLOptionsCollection_numericIndexSetter_Callback";

  void remove(int index) native "HTMLOptionsCollection_remove_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLOutputElementDOMImpl extends _HTMLElementDOMImpl implements OutputElement {
  _HTMLOutputElementDOMImpl();
  String get typeName() => "HTMLOutputElement";

  String get defaultValue() native "HTMLOutputElement_defaultValue_Getter";

  void set defaultValue(String) native "HTMLOutputElement_defaultValue_Setter";

  FormElement get form() native "HTMLOutputElement_form_Getter";

  DOMSettableTokenList get htmlFor() native "HTMLOutputElement_htmlFor_Getter";

  void set htmlFor(DOMSettableTokenList) native "HTMLOutputElement_htmlFor_Setter";

  NodeList get labels() native "HTMLOutputElement_labels_Getter";

  String get name() native "HTMLOutputElement_name_Getter";

  void set name(String) native "HTMLOutputElement_name_Setter";

  String get type() native "HTMLOutputElement_type_Getter";

  String get validationMessage() native "HTMLOutputElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLOutputElement_validity_Getter";

  String get value() native "HTMLOutputElement_value_Getter";

  void set value(String) native "HTMLOutputElement_value_Setter";

  bool get willValidate() native "HTMLOutputElement_willValidate_Getter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLOutputElement_checkValidity_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLOutputElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLParagraphElementDOMImpl extends _HTMLElementDOMImpl implements ParagraphElement {
  _HTMLParagraphElementDOMImpl();
  String get typeName() => "HTMLParagraphElement";

  String get align() native "HTMLParagraphElement_align_Getter";

  void set align(String) native "HTMLParagraphElement_align_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLParamElementDOMImpl extends _HTMLElementDOMImpl implements ParamElement {
  _HTMLParamElementDOMImpl();
  String get typeName() => "HTMLParamElement";

  String get name() native "HTMLParamElement_name_Getter";

  void set name(String) native "HTMLParamElement_name_Setter";

  String get type() native "HTMLParamElement_type_Getter";

  void set type(String) native "HTMLParamElement_type_Setter";

  String get value() native "HTMLParamElement_value_Getter";

  void set value(String) native "HTMLParamElement_value_Setter";

  String get valueType() native "HTMLParamElement_valueType_Getter";

  void set valueType(String) native "HTMLParamElement_valueType_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLPreElementDOMImpl extends _HTMLElementDOMImpl implements PreElement {
  _HTMLPreElementDOMImpl();
  String get typeName() => "HTMLPreElement";

  int get width() native "HTMLPreElement_width_Getter";

  void set width(int) native "HTMLPreElement_width_Setter";

  bool get wrap() native "HTMLPreElement_wrap_Getter";

  void set wrap(bool) native "HTMLPreElement_wrap_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLProgressElementDOMImpl extends _HTMLElementDOMImpl implements ProgressElement {
  _HTMLProgressElementDOMImpl();
  String get typeName() => "HTMLProgressElement";

  NodeList get labels() native "HTMLProgressElement_labels_Getter";

  num get max() native "HTMLProgressElement_max_Getter";

  void set max(num) native "HTMLProgressElement_max_Setter";

  num get position() native "HTMLProgressElement_position_Getter";

  num get value() native "HTMLProgressElement_value_Getter";

  void set value(num) native "HTMLProgressElement_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLQuoteElementDOMImpl extends _HTMLElementDOMImpl implements QuoteElement {
  _HTMLQuoteElementDOMImpl();
  String get typeName() => "HTMLQuoteElement";

  String get cite() native "HTMLQuoteElement_cite_Getter";

  void set cite(String) native "HTMLQuoteElement_cite_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLScriptElementDOMImpl extends _HTMLElementDOMImpl implements ScriptElement {
  _HTMLScriptElementDOMImpl();
  String get typeName() => "HTMLScriptElement";

  bool get async() native "HTMLScriptElement_async_Getter";

  void set async(bool) native "HTMLScriptElement_async_Setter";

  String get charset() native "HTMLScriptElement_charset_Getter";

  void set charset(String) native "HTMLScriptElement_charset_Setter";

  String get crossOrigin() native "HTMLScriptElement_crossOrigin_Getter";

  void set crossOrigin(String) native "HTMLScriptElement_crossOrigin_Setter";

  bool get defer() native "HTMLScriptElement_defer_Getter";

  void set defer(bool) native "HTMLScriptElement_defer_Setter";

  String get event() native "HTMLScriptElement_event_Getter";

  void set event(String) native "HTMLScriptElement_event_Setter";

  String get htmlFor() native "HTMLScriptElement_htmlFor_Getter";

  void set htmlFor(String) native "HTMLScriptElement_htmlFor_Setter";

  String get src() native "HTMLScriptElement_src_Getter";

  void set src(String) native "HTMLScriptElement_src_Setter";

  String get type() native "HTMLScriptElement_type_Getter";

  void set type(String) native "HTMLScriptElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLSelectElementDOMImpl extends _HTMLElementDOMImpl implements SelectElement {
  _HTMLSelectElementDOMImpl();
  String get typeName() => "HTMLSelectElement";

  bool get autofocus() native "HTMLSelectElement_autofocus_Getter";

  void set autofocus(bool) native "HTMLSelectElement_autofocus_Setter";

  bool get disabled() native "HTMLSelectElement_disabled_Getter";

  void set disabled(bool) native "HTMLSelectElement_disabled_Setter";

  FormElement get form() native "HTMLSelectElement_form_Getter";

  NodeList get labels() native "HTMLSelectElement_labels_Getter";

  int get length() native "HTMLSelectElement_length_Getter";

  void set length(int) native "HTMLSelectElement_length_Setter";

  bool get multiple() native "HTMLSelectElement_multiple_Getter";

  void set multiple(bool) native "HTMLSelectElement_multiple_Setter";

  String get name() native "HTMLSelectElement_name_Getter";

  void set name(String) native "HTMLSelectElement_name_Setter";

  HTMLOptionsCollection get options() native "HTMLSelectElement_options_Getter";

  bool get required() native "HTMLSelectElement_required_Getter";

  void set required(bool) native "HTMLSelectElement_required_Setter";

  int get selectedIndex() native "HTMLSelectElement_selectedIndex_Getter";

  void set selectedIndex(int) native "HTMLSelectElement_selectedIndex_Setter";

  HTMLCollection get selectedOptions() native "HTMLSelectElement_selectedOptions_Getter";

  int get size() native "HTMLSelectElement_size_Getter";

  void set size(int) native "HTMLSelectElement_size_Setter";

  String get type() native "HTMLSelectElement_type_Getter";

  String get validationMessage() native "HTMLSelectElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLSelectElement_validity_Getter";

  String get value() native "HTMLSelectElement_value_Getter";

  void set value(String) native "HTMLSelectElement_value_Setter";

  bool get willValidate() native "HTMLSelectElement_willValidate_Getter";

  void add(Element element, Element before) {
    if ((element === null || element is Element) &&
        (before === null || before is Element)) {
      _add(element, before);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _add(element, before) native "HTMLSelectElement_add_Callback";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLSelectElement_checkValidity_Callback";

  Node item(int index) {
    return _item(index);
  }

  Node _item(index) native "HTMLSelectElement_item_Callback";

  Node namedItem(String name) {
    return _namedItem(name);
  }

  Node _namedItem(name) native "HTMLSelectElement_namedItem_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLSelectElement_setCustomValidity_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLShadowElementDOMImpl extends _HTMLElementDOMImpl implements ShadowElement {
  _HTMLShadowElementDOMImpl();
  String get typeName() => "HTMLShadowElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLSourceElementDOMImpl extends _HTMLElementDOMImpl implements SourceElement {
  _HTMLSourceElementDOMImpl();
  String get typeName() => "HTMLSourceElement";

  String get media() native "HTMLSourceElement_media_Getter";

  void set media(String) native "HTMLSourceElement_media_Setter";

  String get src() native "HTMLSourceElement_src_Getter";

  void set src(String) native "HTMLSourceElement_src_Setter";

  String get type() native "HTMLSourceElement_type_Getter";

  void set type(String) native "HTMLSourceElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLSpanElementDOMImpl extends _HTMLElementDOMImpl implements SpanElement {
  _HTMLSpanElementDOMImpl();
  String get typeName() => "HTMLSpanElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLStyleElementDOMImpl extends _HTMLElementDOMImpl implements StyleElement {
  _HTMLStyleElementDOMImpl();
  String get typeName() => "HTMLStyleElement";

  bool get disabled() native "HTMLStyleElement_disabled_Getter";

  void set disabled(bool) native "HTMLStyleElement_disabled_Setter";

  String get media() native "HTMLStyleElement_media_Getter";

  void set media(String) native "HTMLStyleElement_media_Setter";

  bool get scoped() native "HTMLStyleElement_scoped_Getter";

  void set scoped(bool) native "HTMLStyleElement_scoped_Setter";

  StyleSheet get sheet() native "HTMLStyleElement_sheet_Getter";

  String get type() native "HTMLStyleElement_type_Getter";

  void set type(String) native "HTMLStyleElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTableCaptionElementDOMImpl extends _HTMLElementDOMImpl implements TableCaptionElement {
  _HTMLTableCaptionElementDOMImpl();
  String get typeName() => "HTMLTableCaptionElement";

  String get align() native "HTMLTableCaptionElement_align_Getter";

  void set align(String) native "HTMLTableCaptionElement_align_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTableCellElementDOMImpl extends _HTMLElementDOMImpl implements TableCellElement {
  _HTMLTableCellElementDOMImpl();
  String get typeName() => "HTMLTableCellElement";

  String get abbr() native "HTMLTableCellElement_abbr_Getter";

  void set abbr(String) native "HTMLTableCellElement_abbr_Setter";

  String get align() native "HTMLTableCellElement_align_Getter";

  void set align(String) native "HTMLTableCellElement_align_Setter";

  String get axis() native "HTMLTableCellElement_axis_Getter";

  void set axis(String) native "HTMLTableCellElement_axis_Setter";

  String get bgColor() native "HTMLTableCellElement_bgColor_Getter";

  void set bgColor(String) native "HTMLTableCellElement_bgColor_Setter";

  int get cellIndex() native "HTMLTableCellElement_cellIndex_Getter";

  String get ch() native "HTMLTableCellElement_ch_Getter";

  void set ch(String) native "HTMLTableCellElement_ch_Setter";

  String get chOff() native "HTMLTableCellElement_chOff_Getter";

  void set chOff(String) native "HTMLTableCellElement_chOff_Setter";

  int get colSpan() native "HTMLTableCellElement_colSpan_Getter";

  void set colSpan(int) native "HTMLTableCellElement_colSpan_Setter";

  String get headers() native "HTMLTableCellElement_headers_Getter";

  void set headers(String) native "HTMLTableCellElement_headers_Setter";

  String get height() native "HTMLTableCellElement_height_Getter";

  void set height(String) native "HTMLTableCellElement_height_Setter";

  bool get noWrap() native "HTMLTableCellElement_noWrap_Getter";

  void set noWrap(bool) native "HTMLTableCellElement_noWrap_Setter";

  int get rowSpan() native "HTMLTableCellElement_rowSpan_Getter";

  void set rowSpan(int) native "HTMLTableCellElement_rowSpan_Setter";

  String get scope() native "HTMLTableCellElement_scope_Getter";

  void set scope(String) native "HTMLTableCellElement_scope_Setter";

  String get vAlign() native "HTMLTableCellElement_vAlign_Getter";

  void set vAlign(String) native "HTMLTableCellElement_vAlign_Setter";

  String get width() native "HTMLTableCellElement_width_Getter";

  void set width(String) native "HTMLTableCellElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTableColElementDOMImpl extends _HTMLElementDOMImpl implements TableColElement {
  _HTMLTableColElementDOMImpl();
  String get typeName() => "HTMLTableColElement";

  String get align() native "HTMLTableColElement_align_Getter";

  void set align(String) native "HTMLTableColElement_align_Setter";

  String get ch() native "HTMLTableColElement_ch_Getter";

  void set ch(String) native "HTMLTableColElement_ch_Setter";

  String get chOff() native "HTMLTableColElement_chOff_Getter";

  void set chOff(String) native "HTMLTableColElement_chOff_Setter";

  int get span() native "HTMLTableColElement_span_Getter";

  void set span(int) native "HTMLTableColElement_span_Setter";

  String get vAlign() native "HTMLTableColElement_vAlign_Getter";

  void set vAlign(String) native "HTMLTableColElement_vAlign_Setter";

  String get width() native "HTMLTableColElement_width_Getter";

  void set width(String) native "HTMLTableColElement_width_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTableElementDOMImpl extends _HTMLElementDOMImpl implements TableElement {
  _HTMLTableElementDOMImpl();
  String get typeName() => "HTMLTableElement";

  String get align() native "HTMLTableElement_align_Getter";

  void set align(String) native "HTMLTableElement_align_Setter";

  String get bgColor() native "HTMLTableElement_bgColor_Getter";

  void set bgColor(String) native "HTMLTableElement_bgColor_Setter";

  String get border() native "HTMLTableElement_border_Getter";

  void set border(String) native "HTMLTableElement_border_Setter";

  TableCaptionElement get caption() native "HTMLTableElement_caption_Getter";

  void set caption(TableCaptionElement) native "HTMLTableElement_caption_Setter";

  String get cellPadding() native "HTMLTableElement_cellPadding_Getter";

  void set cellPadding(String) native "HTMLTableElement_cellPadding_Setter";

  String get cellSpacing() native "HTMLTableElement_cellSpacing_Getter";

  void set cellSpacing(String) native "HTMLTableElement_cellSpacing_Setter";

  String get frame() native "HTMLTableElement_frame_Getter";

  void set frame(String) native "HTMLTableElement_frame_Setter";

  HTMLCollection get rows() native "HTMLTableElement_rows_Getter";

  String get rules() native "HTMLTableElement_rules_Getter";

  void set rules(String) native "HTMLTableElement_rules_Setter";

  String get summary() native "HTMLTableElement_summary_Getter";

  void set summary(String) native "HTMLTableElement_summary_Setter";

  HTMLCollection get tBodies() native "HTMLTableElement_tBodies_Getter";

  TableSectionElement get tFoot() native "HTMLTableElement_tFoot_Getter";

  void set tFoot(TableSectionElement) native "HTMLTableElement_tFoot_Setter";

  TableSectionElement get tHead() native "HTMLTableElement_tHead_Getter";

  void set tHead(TableSectionElement) native "HTMLTableElement_tHead_Setter";

  String get width() native "HTMLTableElement_width_Getter";

  void set width(String) native "HTMLTableElement_width_Setter";

  Element createCaption() {
    return _createCaption();
  }

  Element _createCaption() native "HTMLTableElement_createCaption_Callback";

  Element createTBody() {
    return _createTBody();
  }

  Element _createTBody() native "HTMLTableElement_createTBody_Callback";

  Element createTFoot() {
    return _createTFoot();
  }

  Element _createTFoot() native "HTMLTableElement_createTFoot_Callback";

  Element createTHead() {
    return _createTHead();
  }

  Element _createTHead() native "HTMLTableElement_createTHead_Callback";

  void deleteCaption() {
    _deleteCaption();
    return;
  }

  void _deleteCaption() native "HTMLTableElement_deleteCaption_Callback";

  void deleteRow(int index) {
    _deleteRow(index);
    return;
  }

  void _deleteRow(index) native "HTMLTableElement_deleteRow_Callback";

  void deleteTFoot() {
    _deleteTFoot();
    return;
  }

  void _deleteTFoot() native "HTMLTableElement_deleteTFoot_Callback";

  void deleteTHead() {
    _deleteTHead();
    return;
  }

  void _deleteTHead() native "HTMLTableElement_deleteTHead_Callback";

  Element insertRow(int index) {
    return _insertRow(index);
  }

  Element _insertRow(index) native "HTMLTableElement_insertRow_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTableRowElementDOMImpl extends _HTMLElementDOMImpl implements TableRowElement {
  _HTMLTableRowElementDOMImpl();
  String get typeName() => "HTMLTableRowElement";

  String get align() native "HTMLTableRowElement_align_Getter";

  void set align(String) native "HTMLTableRowElement_align_Setter";

  String get bgColor() native "HTMLTableRowElement_bgColor_Getter";

  void set bgColor(String) native "HTMLTableRowElement_bgColor_Setter";

  HTMLCollection get cells() native "HTMLTableRowElement_cells_Getter";

  String get ch() native "HTMLTableRowElement_ch_Getter";

  void set ch(String) native "HTMLTableRowElement_ch_Setter";

  String get chOff() native "HTMLTableRowElement_chOff_Getter";

  void set chOff(String) native "HTMLTableRowElement_chOff_Setter";

  int get rowIndex() native "HTMLTableRowElement_rowIndex_Getter";

  int get sectionRowIndex() native "HTMLTableRowElement_sectionRowIndex_Getter";

  String get vAlign() native "HTMLTableRowElement_vAlign_Getter";

  void set vAlign(String) native "HTMLTableRowElement_vAlign_Setter";

  void deleteCell(int index) {
    _deleteCell(index);
    return;
  }

  void _deleteCell(index) native "HTMLTableRowElement_deleteCell_Callback";

  Element insertCell(int index) {
    return _insertCell(index);
  }

  Element _insertCell(index) native "HTMLTableRowElement_insertCell_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTableSectionElementDOMImpl extends _HTMLElementDOMImpl implements TableSectionElement {
  _HTMLTableSectionElementDOMImpl();
  String get typeName() => "HTMLTableSectionElement";

  String get align() native "HTMLTableSectionElement_align_Getter";

  void set align(String) native "HTMLTableSectionElement_align_Setter";

  String get ch() native "HTMLTableSectionElement_ch_Getter";

  void set ch(String) native "HTMLTableSectionElement_ch_Setter";

  String get chOff() native "HTMLTableSectionElement_chOff_Getter";

  void set chOff(String) native "HTMLTableSectionElement_chOff_Setter";

  HTMLCollection get rows() native "HTMLTableSectionElement_rows_Getter";

  String get vAlign() native "HTMLTableSectionElement_vAlign_Getter";

  void set vAlign(String) native "HTMLTableSectionElement_vAlign_Setter";

  void deleteRow(int index) {
    _deleteRow(index);
    return;
  }

  void _deleteRow(index) native "HTMLTableSectionElement_deleteRow_Callback";

  Element insertRow(int index) {
    return _insertRow(index);
  }

  Element _insertRow(index) native "HTMLTableSectionElement_insertRow_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTextAreaElementDOMImpl extends _HTMLElementDOMImpl implements TextAreaElement {
  _HTMLTextAreaElementDOMImpl();
  String get typeName() => "HTMLTextAreaElement";

  bool get autofocus() native "HTMLTextAreaElement_autofocus_Getter";

  void set autofocus(bool) native "HTMLTextAreaElement_autofocus_Setter";

  int get cols() native "HTMLTextAreaElement_cols_Getter";

  void set cols(int) native "HTMLTextAreaElement_cols_Setter";

  String get defaultValue() native "HTMLTextAreaElement_defaultValue_Getter";

  void set defaultValue(String) native "HTMLTextAreaElement_defaultValue_Setter";

  bool get disabled() native "HTMLTextAreaElement_disabled_Getter";

  void set disabled(bool) native "HTMLTextAreaElement_disabled_Setter";

  FormElement get form() native "HTMLTextAreaElement_form_Getter";

  NodeList get labels() native "HTMLTextAreaElement_labels_Getter";

  int get maxLength() native "HTMLTextAreaElement_maxLength_Getter";

  void set maxLength(int) native "HTMLTextAreaElement_maxLength_Setter";

  String get name() native "HTMLTextAreaElement_name_Getter";

  void set name(String) native "HTMLTextAreaElement_name_Setter";

  String get placeholder() native "HTMLTextAreaElement_placeholder_Getter";

  void set placeholder(String) native "HTMLTextAreaElement_placeholder_Setter";

  bool get readOnly() native "HTMLTextAreaElement_readOnly_Getter";

  void set readOnly(bool) native "HTMLTextAreaElement_readOnly_Setter";

  bool get required() native "HTMLTextAreaElement_required_Getter";

  void set required(bool) native "HTMLTextAreaElement_required_Setter";

  int get rows() native "HTMLTextAreaElement_rows_Getter";

  void set rows(int) native "HTMLTextAreaElement_rows_Setter";

  String get selectionDirection() native "HTMLTextAreaElement_selectionDirection_Getter";

  void set selectionDirection(String) native "HTMLTextAreaElement_selectionDirection_Setter";

  int get selectionEnd() native "HTMLTextAreaElement_selectionEnd_Getter";

  void set selectionEnd(int) native "HTMLTextAreaElement_selectionEnd_Setter";

  int get selectionStart() native "HTMLTextAreaElement_selectionStart_Getter";

  void set selectionStart(int) native "HTMLTextAreaElement_selectionStart_Setter";

  int get textLength() native "HTMLTextAreaElement_textLength_Getter";

  String get type() native "HTMLTextAreaElement_type_Getter";

  String get validationMessage() native "HTMLTextAreaElement_validationMessage_Getter";

  ValidityState get validity() native "HTMLTextAreaElement_validity_Getter";

  String get value() native "HTMLTextAreaElement_value_Getter";

  void set value(String) native "HTMLTextAreaElement_value_Setter";

  bool get willValidate() native "HTMLTextAreaElement_willValidate_Getter";

  String get wrap() native "HTMLTextAreaElement_wrap_Getter";

  void set wrap(String) native "HTMLTextAreaElement_wrap_Setter";

  bool checkValidity() {
    return _checkValidity();
  }

  bool _checkValidity() native "HTMLTextAreaElement_checkValidity_Callback";

  void select() {
    _select();
    return;
  }

  void _select() native "HTMLTextAreaElement_select_Callback";

  void setCustomValidity(String error) {
    _setCustomValidity(error);
    return;
  }

  void _setCustomValidity(error) native "HTMLTextAreaElement_setCustomValidity_Callback";

  void setSelectionRange(int start, int end, [String direction = null]) {
    //
    // setSelectionRange(int start, int end)
    // setSelectionRange(int start, int end, [Optional] String direction)
    //
    // -- reduced:
    // setSelectionRange(int start, int end, [Optional] String direction)
    //
    _setSelectionRange(start, end, direction);
    return;
  }

  void _setSelectionRange(start, end, direction) native "HTMLTextAreaElement_setSelectionRange_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTitleElementDOMImpl extends _HTMLElementDOMImpl implements TitleElement {
  _HTMLTitleElementDOMImpl();
  String get typeName() => "HTMLTitleElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLTrackElementDOMImpl extends _HTMLElementDOMImpl implements TrackElement {
  _HTMLTrackElementDOMImpl();
  String get typeName() => "HTMLTrackElement";

  bool get defaultValue() native "HTMLTrackElement_default_Getter";

  void set defaultValue(bool) native "HTMLTrackElement_default_Setter";

  String get kind() native "HTMLTrackElement_kind_Getter";

  void set kind(String) native "HTMLTrackElement_kind_Setter";

  String get label() native "HTMLTrackElement_label_Getter";

  void set label(String) native "HTMLTrackElement_label_Setter";

  int get readyState() native "HTMLTrackElement_readyState_Getter";

  String get src() native "HTMLTrackElement_src_Getter";

  void set src(String) native "HTMLTrackElement_src_Setter";

  String get srclang() native "HTMLTrackElement_srclang_Getter";

  void set srclang(String) native "HTMLTrackElement_srclang_Setter";

  TextTrack get track() native "HTMLTrackElement_track_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLUListElementDOMImpl extends _HTMLElementDOMImpl implements UListElement {
  _HTMLUListElementDOMImpl();
  String get typeName() => "HTMLUListElement";

  bool get compact() native "HTMLUListElement_compact_Getter";

  void set compact(bool) native "HTMLUListElement_compact_Setter";

  String get type() native "HTMLUListElement_type_Getter";

  void set type(String) native "HTMLUListElement_type_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLUnknownElementDOMImpl extends _HTMLElementDOMImpl implements UnknownElement {
  _HTMLUnknownElementDOMImpl();
  String get typeName() => "HTMLUnknownElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HTMLVideoElementDOMImpl extends _HTMLMediaElementDOMImpl implements VideoElement {
  _HTMLVideoElementDOMImpl();
  String get typeName() => "HTMLVideoElement";

  int get height() native "HTMLVideoElement_height_Getter";

  void set height(int) native "HTMLVideoElement_height_Setter";

  String get poster() native "HTMLVideoElement_poster_Getter";

  void set poster(String) native "HTMLVideoElement_poster_Setter";

  int get videoHeight() native "HTMLVideoElement_videoHeight_Getter";

  int get videoWidth() native "HTMLVideoElement_videoWidth_Getter";

  int get webkitDecodedFrameCount() native "HTMLVideoElement_webkitDecodedFrameCount_Getter";

  bool get webkitDisplayingFullscreen() native "HTMLVideoElement_webkitDisplayingFullscreen_Getter";

  int get webkitDroppedFrameCount() native "HTMLVideoElement_webkitDroppedFrameCount_Getter";

  bool get webkitSupportsFullscreen() native "HTMLVideoElement_webkitSupportsFullscreen_Getter";

  int get width() native "HTMLVideoElement_width_Getter";

  void set width(int) native "HTMLVideoElement_width_Setter";

  void webkitEnterFullScreen() {
    _webkitEnterFullScreen();
    return;
  }

  void _webkitEnterFullScreen() native "HTMLVideoElement_webkitEnterFullScreen_Callback";

  void webkitEnterFullscreen() {
    _webkitEnterFullscreen();
    return;
  }

  void _webkitEnterFullscreen() native "HTMLVideoElement_webkitEnterFullscreen_Callback";

  void webkitExitFullScreen() {
    _webkitExitFullScreen();
    return;
  }

  void _webkitExitFullScreen() native "HTMLVideoElement_webkitExitFullScreen_Callback";

  void webkitExitFullscreen() {
    _webkitExitFullscreen();
    return;
  }

  void _webkitExitFullscreen() native "HTMLVideoElement_webkitExitFullscreen_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HashChangeEventDOMImpl extends _EventDOMImpl implements HashChangeEvent {
  _HashChangeEventDOMImpl();
  String get typeName() => "HashChangeEvent";

  String get newURL() native "HashChangeEvent_newURL_Getter";

  String get oldURL() native "HashChangeEvent_oldURL_Getter";

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) {
    _initHashChangeEvent(type, canBubble, cancelable, oldURL, newURL);
    return;
  }

  void _initHashChangeEvent(type, canBubble, cancelable, oldURL, newURL) native "HashChangeEvent_initHashChangeEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _HistoryDOMImpl extends _DOMWrapperBase implements History {
  _HistoryDOMImpl();
  String get typeName() => "History";

  int get length() native "History_length_Getter";

  Dynamic get state() native "History_state_Getter";

  void back() {
    _back();
    return;
  }

  void _back() native "History_back_Callback";

  void forward() {
    _forward();
    return;
  }

  void _forward() native "History_forward_Callback";

  void go(int distance) {
    _go(distance);
    return;
  }

  void _go(distance) native "History_go_Callback";

  void pushState(Object data, String title, [String url = null]) native "History_pushState_Callback";

  void replaceState(Object data, String title, [String url = null]) native "History_replaceState_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBAnyDOMImpl extends _DOMWrapperBase implements IDBAny {
  _IDBAnyDOMImpl();
  String get typeName() => "IDBAny";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBCursorDOMImpl extends _DOMWrapperBase implements IDBCursor {
  _IDBCursorDOMImpl();
  String get typeName() => "IDBCursor";

  String get direction() native "IDBCursor_direction_Getter";

  Dynamic get key() native "IDBCursor_key_Getter";

  Dynamic get primaryKey() native "IDBCursor_primaryKey_Getter";

  Dynamic get source() native "IDBCursor_source_Getter";

  void advance(int count) {
    _advance(count);
    return;
  }

  void _advance(count) native "IDBCursor_advance_Callback";

  void continueFunction([key = null]) {
    //
    // continueFunction()
    // continueFunction([Optional] Dynamic key)
    //
    if (key === null) {
      _continueFunction();
      return;
    }
    _continueFunction_2(key);
    return;
  }

  void _continueFunction() native "IDBCursor_continueFunction_Callback";

  void _continueFunction_2(key) native "IDBCursor_continueFunction_2_Callback";

  IDBRequest delete() {
    return _delete();
  }

  IDBRequest _delete() native "IDBCursor_delete_Callback";

  IDBRequest update(value) {
    return _update(value);
  }

  IDBRequest _update(value) native "IDBCursor_update_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBCursorWithValueDOMImpl extends _IDBCursorDOMImpl implements IDBCursorWithValue {
  _IDBCursorWithValueDOMImpl();
  String get typeName() => "IDBCursorWithValue";

  Dynamic get value() native "IDBCursorWithValue_value_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBDatabaseExceptionDOMImpl extends _DOMWrapperBase implements IDBDatabaseException {
  _IDBDatabaseExceptionDOMImpl();
  String get typeName() => "IDBDatabaseException";

  int get code() native "IDBDatabaseException_code_Getter";

  String get message() native "IDBDatabaseException_message_Getter";

  String get name() native "IDBDatabaseException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "IDBDatabaseException_toString_Callback";

}

class _IDBDatabaseEventsImpl extends _EventsImpl implements IDBDatabaseEvents {
  _IDBDatabaseEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get versionChange() => _get('versionchange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBDatabaseDOMImpl extends _DOMWrapperBase implements IDBDatabase {
  _IDBDatabaseDOMImpl();
  String get typeName() => "IDBDatabase";
  _EventsImpl _on;

  _IDBDatabaseEventsImpl get on() {
    if (_on === null) _on = new _IDBDatabaseEventsImpl(this);
    return _on;
  }

  String get name() native "IDBDatabase_name_Getter";

  List<String> get objectStoreNames() native "IDBDatabase_objectStoreNames_Getter";

  String get version() native "IDBDatabase_version_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "IDBDatabase_addEventListener_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "IDBDatabase_close_Callback";

  IDBObjectStore createObjectStore(String name, [Map options = null]) {
    //
    // createObjectStore(String name)
    // createObjectStore(String name, [Optional] Map options)
    //
    if (options === null) {
      return _createObjectStore(name);
    }
    return _createObjectStore_2(name, options);
  }

  IDBObjectStore _createObjectStore(name) native "IDBDatabase_createObjectStore_Callback";

  IDBObjectStore _createObjectStore_2(name, options) native "IDBDatabase_createObjectStore_2_Callback";

  void deleteObjectStore(String name) {
    _deleteObjectStore(name);
    return;
  }

  void _deleteObjectStore(name) native "IDBDatabase_deleteObjectStore_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "IDBDatabase_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "IDBDatabase_removeEventListener_Callback";

  IDBVersionChangeRequest setVersion(String version) {
    return _setVersion(version);
  }

  IDBVersionChangeRequest _setVersion(version) native "IDBDatabase_setVersion_Callback";

  IDBTransaction transaction(storeName_OR_storeNames, mode) {
    //
    // transaction(List<String> storeNames, String mode)
    // transaction(String storeName, String mode)
    // transaction(List<String> storeNames, int mode)
    // transaction(String storeName, int mode)
    //
    if ((storeName_OR_storeNames === null || storeName_OR_storeNames is List<String>) &&
        (mode === null || mode is String)) {
      return _transaction(storeName_OR_storeNames, mode);
    }
    if ((storeName_OR_storeNames === null || storeName_OR_storeNames is String) &&
        (mode === null || mode is String)) {
      return _transaction_2(storeName_OR_storeNames, mode);
    }
    if ((storeName_OR_storeNames === null || storeName_OR_storeNames is List<String>) &&
        (mode === null || mode is int)) {
      return _transaction_3(storeName_OR_storeNames, mode);
    }
    if ((storeName_OR_storeNames === null || storeName_OR_storeNames is String) &&
        (mode === null || mode is int)) {
      return _transaction_4(storeName_OR_storeNames, mode);
    }
    throw "Incorrect number or type of arguments";
  }

  IDBTransaction _transaction(storeName_OR_storeNames, mode) native "IDBDatabase_transaction_Callback";

  IDBTransaction _transaction_2(storeName_OR_storeNames, mode) native "IDBDatabase_transaction_2_Callback";

  IDBTransaction _transaction_3(storeName_OR_storeNames, mode) native "IDBDatabase_transaction_3_Callback";

  IDBTransaction _transaction_4(storeName_OR_storeNames, mode) native "IDBDatabase_transaction_4_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBFactoryDOMImpl extends _DOMWrapperBase implements IDBFactory {
  _IDBFactoryDOMImpl();
  String get typeName() => "IDBFactory";

  int cmp(first, second) {
    return _cmp(first, second);
  }

  int _cmp(first, second) native "IDBFactory_cmp_Callback";

  IDBVersionChangeRequest deleteDatabase(String name) {
    return _deleteDatabase(name);
  }

  IDBVersionChangeRequest _deleteDatabase(name) native "IDBFactory_deleteDatabase_Callback";

  IDBRequest getDatabaseNames() {
    return _getDatabaseNames();
  }

  IDBRequest _getDatabaseNames() native "IDBFactory_getDatabaseNames_Callback";

  IDBRequest open(String name) {
    return _open(name);
  }

  IDBRequest _open(name) native "IDBFactory_open_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBIndexDOMImpl extends _DOMWrapperBase implements IDBIndex {
  _IDBIndexDOMImpl();
  String get typeName() => "IDBIndex";

  String get keyPath() native "IDBIndex_keyPath_Getter";

  bool get multiEntry() native "IDBIndex_multiEntry_Getter";

  String get name() native "IDBIndex_name_Getter";

  IDBObjectStore get objectStore() native "IDBIndex_objectStore_Getter";

  bool get unique() native "IDBIndex_unique_Getter";

  IDBRequest count([key_OR_range = null]) {
    //
    // count()
    // count([Optional] IDBKeyRange range)
    // count(Dynamic key)
    //
    // -- reduced:
    // count([Optional] IDBKeyRange range)
    // count(Dynamic key)
    //
    if ((key_OR_range === null || key_OR_range is IDBKeyRange)) {
      return _count(key_OR_range);
    }
    return _count_2(key_OR_range);
  }

  IDBRequest _count(key_OR_range) native "IDBIndex_count_Callback";

  IDBRequest _count_2(key_OR_range) native "IDBIndex_count_2_Callback";

  IDBRequest get(key) {
    //
    // get(IDBKeyRange key)
    // get(Dynamic key)
    //
    if ((key === null || key is IDBKeyRange)) {
      return _get(key);
    }
    return _get_2(key);
  }

  IDBRequest _get(key) native "IDBIndex_get_Callback";

  IDBRequest _get_2(key) native "IDBIndex_get_2_Callback";

  IDBRequest getKey(key) {
    //
    // getKey(IDBKeyRange key)
    // getKey(Dynamic key)
    //
    if ((key === null || key is IDBKeyRange)) {
      return _getKey(key);
    }
    return _getKey_2(key);
  }

  IDBRequest _getKey(key) native "IDBIndex_getKey_Callback";

  IDBRequest _getKey_2(key) native "IDBIndex_getKey_2_Callback";

  IDBRequest openCursor([key_OR_range = null, direction = null]) {
    //
    // openCursor()
    // openCursor([Optional] IDBKeyRange range)
    // openCursor([Optional] IDBKeyRange range, [Optional] String direction)
    // openCursor(Dynamic key)
    // openCursor(Dynamic key, [Optional] String direction)
    // openCursor(IDBKeyRange range, int direction)
    // openCursor(Dynamic key, int direction)
    //
    // -- reduced:
    // openCursor([Optional] IDBKeyRange range, [Optional] String direction)
    // openCursor(Dynamic key, [Optional] String direction)
    // openCursor(IDBKeyRange range, int direction)
    // openCursor(Dynamic key, int direction)
    //
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        (direction === null || direction is String)) {
      return _openCursor(key_OR_range, direction);
    }
    if ((direction === null || direction is String)) {
      return _openCursor_2(key_OR_range, direction);
    }
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        (direction === null || direction is int)) {
      return _openCursor_3(key_OR_range, direction);
    }
    if ((direction === null || direction is int)) {
      return _openCursor_4(key_OR_range, direction);
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest _openCursor(key_OR_range, direction) native "IDBIndex_openCursor_Callback";

  IDBRequest _openCursor_2(key_OR_range, direction) native "IDBIndex_openCursor_2_Callback";

  IDBRequest _openCursor_3(key_OR_range, direction) native "IDBIndex_openCursor_3_Callback";

  IDBRequest _openCursor_4(key_OR_range, direction) native "IDBIndex_openCursor_4_Callback";

  IDBRequest openKeyCursor([key_OR_range = null, direction = null]) {
    //
    // openKeyCursor()
    // openKeyCursor([Optional] IDBKeyRange range)
    // openKeyCursor([Optional] IDBKeyRange range, [Optional] String direction)
    // openKeyCursor(Dynamic key)
    // openKeyCursor(Dynamic key, [Optional] String direction)
    // openKeyCursor(IDBKeyRange range, int direction)
    // openKeyCursor(Dynamic key, int direction)
    //
    // -- reduced:
    // openKeyCursor([Optional] IDBKeyRange range, [Optional] String direction)
    // openKeyCursor(Dynamic key, [Optional] String direction)
    // openKeyCursor(IDBKeyRange range, int direction)
    // openKeyCursor(Dynamic key, int direction)
    //
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        (direction === null || direction is String)) {
      return _openKeyCursor(key_OR_range, direction);
    }
    if ((direction === null || direction is String)) {
      return _openKeyCursor_2(key_OR_range, direction);
    }
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        (direction === null || direction is int)) {
      return _openKeyCursor_3(key_OR_range, direction);
    }
    if ((direction === null || direction is int)) {
      return _openKeyCursor_4(key_OR_range, direction);
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest _openKeyCursor(key_OR_range, direction) native "IDBIndex_openKeyCursor_Callback";

  IDBRequest _openKeyCursor_2(key_OR_range, direction) native "IDBIndex_openKeyCursor_2_Callback";

  IDBRequest _openKeyCursor_3(key_OR_range, direction) native "IDBIndex_openKeyCursor_3_Callback";

  IDBRequest _openKeyCursor_4(key_OR_range, direction) native "IDBIndex_openKeyCursor_4_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBKeyDOMImpl extends _DOMWrapperBase implements IDBKey {
  _IDBKeyDOMImpl();
  String get typeName() => "IDBKey";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBKeyRangeDOMImpl extends _DOMWrapperBase implements IDBKeyRange {
  _IDBKeyRangeDOMImpl();
  String get typeName() => "IDBKeyRange";

  Dynamic get lower() native "IDBKeyRange_lower_Getter";

  bool get lowerOpen() native "IDBKeyRange_lowerOpen_Getter";

  Dynamic get upper() native "IDBKeyRange_upper_Getter";

  bool get upperOpen() native "IDBKeyRange_upperOpen_Getter";

  static IDBKeyRange bound(lower, upper, [bool lowerOpen = null, bool upperOpen = null]) {
    //
    // bound(Dynamic lower, Dynamic upper)
    // bound(Dynamic lower, Dynamic upper, [Optional] bool lowerOpen)
    // bound(Dynamic lower, Dynamic upper, [Optional] bool lowerOpen, [Optional] bool upperOpen)
    //
    // -- reduced:
    // bound(Dynamic lower, Dynamic upper, [Optional] bool lowerOpen, [Optional] bool upperOpen)
    //
    return _bound(lower, upper, lowerOpen, upperOpen);
  }

  static IDBKeyRange _bound(lower, upper, lowerOpen, upperOpen) native "IDBKeyRange_bound_Callback";

  static IDBKeyRange lowerBound(bound, [bool open = null]) {
    //
    // lowerBound(Dynamic bound)
    // lowerBound(Dynamic bound, [Optional] bool open)
    //
    // -- reduced:
    // lowerBound(Dynamic bound, [Optional] bool open)
    //
    return _lowerBound(bound, open);
  }

  static IDBKeyRange _lowerBound(bound, open) native "IDBKeyRange_lowerBound_Callback";

  static IDBKeyRange only(value) {
    return _only(value);
  }

  static IDBKeyRange _only(value) native "IDBKeyRange_only_Callback";

  static IDBKeyRange upperBound(bound, [bool open = null]) {
    //
    // upperBound(Dynamic bound)
    // upperBound(Dynamic bound, [Optional] bool open)
    //
    // -- reduced:
    // upperBound(Dynamic bound, [Optional] bool open)
    //
    return _upperBound(bound, open);
  }

  static IDBKeyRange _upperBound(bound, open) native "IDBKeyRange_upperBound_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBObjectStoreDOMImpl extends _DOMWrapperBase implements IDBObjectStore {
  _IDBObjectStoreDOMImpl();
  String get typeName() => "IDBObjectStore";

  List<String> get indexNames() native "IDBObjectStore_indexNames_Getter";

  String get keyPath() native "IDBObjectStore_keyPath_Getter";

  String get name() native "IDBObjectStore_name_Getter";

  IDBTransaction get transaction() native "IDBObjectStore_transaction_Getter";

  IDBRequest add(value, [key = null]) {
    //
    // add(Dynamic value)
    // add(Dynamic value, [Optional] Dynamic key)
    //
    if (key === null) {
      return _add(value);
    }
    return _add_2(value, key);
  }

  IDBRequest _add(value) native "IDBObjectStore_add_Callback";

  IDBRequest _add_2(value, key) native "IDBObjectStore_add_2_Callback";

  IDBRequest clear() {
    return _clear();
  }

  IDBRequest _clear() native "IDBObjectStore_clear_Callback";

  IDBRequest count([key_OR_range = null]) {
    //
    // count()
    // count([Optional] IDBKeyRange range)
    // count(Dynamic key)
    //
    // -- reduced:
    // count([Optional] IDBKeyRange range)
    // count(Dynamic key)
    //
    if ((key_OR_range === null || key_OR_range is IDBKeyRange)) {
      return _count(key_OR_range);
    }
    return _count_2(key_OR_range);
  }

  IDBRequest _count(key_OR_range) native "IDBObjectStore_count_Callback";

  IDBRequest _count_2(key_OR_range) native "IDBObjectStore_count_2_Callback";

  IDBIndex createIndex(String name, String keyPath, [Map options = null]) {
    //
    // createIndex(String name, String keyPath)
    // createIndex(String name, String keyPath, [Optional] Map options)
    //
    if (options === null) {
      return _createIndex(name, keyPath);
    }
    return _createIndex_2(name, keyPath, options);
  }

  IDBIndex _createIndex(name, keyPath) native "IDBObjectStore_createIndex_Callback";

  IDBIndex _createIndex_2(name, keyPath, options) native "IDBObjectStore_createIndex_2_Callback";

  IDBRequest delete(key_OR_keyRange) {
    //
    // delete(IDBKeyRange keyRange)
    // delete(Dynamic key)
    //
    if ((key_OR_keyRange === null || key_OR_keyRange is IDBKeyRange)) {
      return _delete(key_OR_keyRange);
    }
    return _delete_2(key_OR_keyRange);
  }

  IDBRequest _delete(key_OR_keyRange) native "IDBObjectStore_delete_Callback";

  IDBRequest _delete_2(key_OR_keyRange) native "IDBObjectStore_delete_2_Callback";

  void deleteIndex(String name) {
    _deleteIndex(name);
    return;
  }

  void _deleteIndex(name) native "IDBObjectStore_deleteIndex_Callback";

  IDBRequest getObject(key) {
    //
    // getObject(IDBKeyRange key)
    // getObject(Dynamic key)
    //
    if ((key === null || key is IDBKeyRange)) {
      return _getObject(key);
    }
    return _getObject_2(key);
  }

  IDBRequest _getObject(key) native "IDBObjectStore_getObject_Callback";

  IDBRequest _getObject_2(key) native "IDBObjectStore_getObject_2_Callback";

  IDBIndex index(String name) {
    return _index(name);
  }

  IDBIndex _index(name) native "IDBObjectStore_index_Callback";

  IDBRequest openCursor([key_OR_range = null, direction = null]) {
    //
    // openCursor([Optional] IDBKeyRange range)
    // openCursor([Optional] IDBKeyRange range, [Optional] String direction)
    // openCursor(Dynamic key)
    // openCursor(Dynamic key, [Optional] String direction)
    // openCursor(IDBKeyRange range, int direction)
    // openCursor(Dynamic key, int direction)
    //
    // -- reduced:
    // openCursor([Optional] IDBKeyRange range)
    // openCursor([Optional] IDBKeyRange range, [Optional] String direction)
    // openCursor(Dynamic key, [Optional] String direction)
    // openCursor(IDBKeyRange range, int direction)
    // openCursor(Dynamic key, int direction)
    //
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        direction === null) {
      return _openCursor(key_OR_range);
    }
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        (direction === null || direction is String)) {
      return _openCursor_2(key_OR_range, direction);
    }
    if ((direction === null || direction is String)) {
      return _openCursor_3(key_OR_range, direction);
    }
    if ((key_OR_range === null || key_OR_range is IDBKeyRange) &&
        (direction === null || direction is int)) {
      return _openCursor_4(key_OR_range, direction);
    }
    if ((direction === null || direction is int)) {
      return _openCursor_5(key_OR_range, direction);
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest _openCursor(key_OR_range) native "IDBObjectStore_openCursor_Callback";

  IDBRequest _openCursor_2(key_OR_range, direction) native "IDBObjectStore_openCursor_2_Callback";

  IDBRequest _openCursor_3(key_OR_range, direction) native "IDBObjectStore_openCursor_3_Callback";

  IDBRequest _openCursor_4(key_OR_range, direction) native "IDBObjectStore_openCursor_4_Callback";

  IDBRequest _openCursor_5(key_OR_range, direction) native "IDBObjectStore_openCursor_5_Callback";

  IDBRequest put(value, [key = null]) {
    //
    // put(Dynamic value)
    // put(Dynamic value, [Optional] Dynamic key)
    //
    if (key === null) {
      return _put(value);
    }
    return _put_2(value, key);
  }

  IDBRequest _put(value) native "IDBObjectStore_put_Callback";

  IDBRequest _put_2(value, key) native "IDBObjectStore_put_2_Callback";

}

class _IDBRequestEventsImpl extends _EventsImpl implements IDBRequestEvents {
  _IDBRequestEventsImpl(_ptr) : super(_ptr);
  EventListenerList get error() => _get('error');
  EventListenerList get success() => _get('success');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBRequestDOMImpl extends _DOMWrapperBase implements IDBRequest {
  _IDBRequestDOMImpl();
  String get typeName() => "IDBRequest";
  _EventsImpl _on;

  _IDBRequestEventsImpl get on() {
    if (_on === null) _on = new _IDBRequestEventsImpl(this);
    return _on;
  }

  int get errorCode() native "IDBRequest_errorCode_Getter";

  String get readyState() native "IDBRequest_readyState_Getter";

  Dynamic get result() native "IDBRequest_result_Getter";

  Dynamic get source() native "IDBRequest_source_Getter";

  IDBTransaction get transaction() native "IDBRequest_transaction_Getter";

  String get webkitErrorMessage() native "IDBRequest_webkitErrorMessage_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "IDBRequest_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "IDBRequest_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "IDBRequest_removeEventListener_Callback";

}

class _IDBTransactionEventsImpl extends _EventsImpl implements IDBTransactionEvents {
  _IDBTransactionEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get complete() => _get('complete');
  EventListenerList get error() => _get('error');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBTransactionDOMImpl extends _DOMWrapperBase implements IDBTransaction {
  _IDBTransactionDOMImpl();
  String get typeName() => "IDBTransaction";
  _EventsImpl _on;

  _IDBTransactionEventsImpl get on() {
    if (_on === null) _on = new _IDBTransactionEventsImpl(this);
    return _on;
  }

  IDBDatabase get db() native "IDBTransaction_db_Getter";

  String get mode() native "IDBTransaction_mode_Getter";

  void abort() {
    _abort();
    return;
  }

  void _abort() native "IDBTransaction_abort_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "IDBTransaction_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "IDBTransaction_dispatchEvent_Callback";

  IDBObjectStore objectStore(String name) {
    return _objectStore(name);
  }

  IDBObjectStore _objectStore(name) native "IDBTransaction_objectStore_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "IDBTransaction_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBVersionChangeEventDOMImpl extends _EventDOMImpl implements IDBVersionChangeEvent {
  _IDBVersionChangeEventDOMImpl();
  String get typeName() => "IDBVersionChangeEvent";

  String get version() native "IDBVersionChangeEvent_version_Getter";

}

class _IDBVersionChangeRequestEventsImpl extends _IDBRequestEventsImpl implements IDBVersionChangeRequestEvents {
  _IDBVersionChangeRequestEventsImpl(_ptr) : super(_ptr);
  EventListenerList get blocked() => _get('blocked');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IDBVersionChangeRequestDOMImpl extends _IDBRequestDOMImpl implements IDBVersionChangeRequest {
  _IDBVersionChangeRequestDOMImpl();
  String get typeName() => "IDBVersionChangeRequest";

  _IDBVersionChangeRequestEventsImpl get on() {
    if (_on === null) _on = new _IDBVersionChangeRequestEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "IDBVersionChangeRequest_addEventListener_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "IDBVersionChangeRequest_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "IDBVersionChangeRequest_removeEventListener_Callback";

}
class _IceCandidateFactoryProviderImpl {
  static _IceCandidateDOMImpl createIceCandidate(String label, String candidateLine)
      native "IceCandidate_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _IceCandidateDOMImpl extends _DOMWrapperBase implements IceCandidate {
  _IceCandidateDOMImpl();
  String get typeName() => "IceCandidate";

  String get label() native "IceCandidate_label_Getter";

  String toSdp() {
    return _toSdp();
  }

  String _toSdp() native "IceCandidate_toSdp_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ImageDataDOMImpl extends _DOMWrapperBase implements ImageData {
  _ImageDataDOMImpl();
  String get typeName() => "ImageData";

  Uint8ClampedArray get data() native "ImageData_data_Getter";

  int get height() native "ImageData_height_Getter";

  int get width() native "ImageData_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Int16ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Int16Array {
  _Int16ArrayDOMImpl();
  String get typeName() => "Int16Array";

  int get length() native "Int16Array_length_Getter";

  int operator[](int index) native "Int16Array_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Int16Array_numericIndexSetter_Callback";

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) native "Int16Array_setElements_Callback";

  Int16Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Int16Array _subarray(start, end) native "Int16Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Int32ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Int32Array {
  _Int32ArrayDOMImpl();
  String get typeName() => "Int32Array";

  int get length() native "Int32Array_length_Getter";

  int operator[](int index) native "Int32Array_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Int32Array_numericIndexSetter_Callback";

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) native "Int32Array_setElements_Callback";

  Int32Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Int32Array _subarray(start, end) native "Int32Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Int8ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Int8Array {
  _Int8ArrayDOMImpl();
  String get typeName() => "Int8Array";

  int get length() native "Int8Array_length_Getter";

  int operator[](int index) native "Int8Array_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Int8Array_numericIndexSetter_Callback";

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) native "Int8Array_setElements_Callback";

  Int8Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Int8Array _subarray(start, end) native "Int8Array_subarray_Callback";

}

class _JavaScriptAudioNodeEventsImpl extends _EventsImpl implements JavaScriptAudioNodeEvents {
  _JavaScriptAudioNodeEventsImpl(_ptr) : super(_ptr);
  EventListenerList get audioProcess() => _get('audioprocess');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _JavaScriptAudioNodeDOMImpl extends _AudioNodeDOMImpl implements JavaScriptAudioNode {
  _JavaScriptAudioNodeDOMImpl();
  String get typeName() => "JavaScriptAudioNode";
  _EventsImpl _on;

  _JavaScriptAudioNodeEventsImpl get on() {
    if (_on === null) _on = new _JavaScriptAudioNodeEventsImpl(this);
    return _on;
  }

  int get bufferSize() native "JavaScriptAudioNode_bufferSize_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "JavaScriptAudioNode_addEventListener_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "JavaScriptAudioNode_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "JavaScriptAudioNode_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _JavaScriptCallFrameDOMImpl extends _DOMWrapperBase implements JavaScriptCallFrame {
  _JavaScriptCallFrameDOMImpl();
  String get typeName() => "JavaScriptCallFrame";

  JavaScriptCallFrame get caller() native "JavaScriptCallFrame_caller_Getter";

  int get column() native "JavaScriptCallFrame_column_Getter";

  String get functionName() native "JavaScriptCallFrame_functionName_Getter";

  int get line() native "JavaScriptCallFrame_line_Getter";

  List get scopeChain() native "JavaScriptCallFrame_scopeChain_Getter";

  int get sourceID() native "JavaScriptCallFrame_sourceID_Getter";

  Object get thisObject() native "JavaScriptCallFrame_thisObject_Getter";

  String get type() native "JavaScriptCallFrame_type_Getter";

  void evaluate(String script) native "JavaScriptCallFrame_evaluate_Callback";

  int scopeType(int scopeIndex) native "JavaScriptCallFrame_scopeType_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _KeyboardEventDOMImpl extends _UIEventDOMImpl implements KeyboardEvent {
  _KeyboardEventDOMImpl();
  String get typeName() => "KeyboardEvent";

  bool get altGraphKey() native "KeyboardEvent_altGraphKey_Getter";

  bool get altKey() native "KeyboardEvent_altKey_Getter";

  bool get ctrlKey() native "KeyboardEvent_ctrlKey_Getter";

  String get keyIdentifier() native "KeyboardEvent_keyIdentifier_Getter";

  int get keyLocation() native "KeyboardEvent_keyLocation_Getter";

  bool get metaKey() native "KeyboardEvent_metaKey_Getter";

  bool get shiftKey() native "KeyboardEvent_shiftKey_Getter";

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) {
    if ((view === null || view is Window)) {
      _initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey, altGraphKey) native "KeyboardEvent_initKeyboardEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _LocalMediaStreamDOMImpl extends _MediaStreamDOMImpl implements LocalMediaStream {
  _LocalMediaStreamDOMImpl();
  String get typeName() => "LocalMediaStream";

  void stop() {
    _stop();
    return;
  }

  void _stop() native "LocalMediaStream_stop_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _LocationDOMImpl extends _DOMWrapperBase implements Location {
  _LocationDOMImpl();
  String get typeName() => "Location";

  List<String> get ancestorOrigins() native "Location_ancestorOrigins_Getter";

  String get hash() native "Location_hash_Getter";

  void set hash(String) native "Location_hash_Setter";

  String get host() native "Location_host_Getter";

  void set host(String) native "Location_host_Setter";

  String get hostname() native "Location_hostname_Getter";

  void set hostname(String) native "Location_hostname_Setter";

  String get href() native "Location_href_Getter";

  void set href(String) native "Location_href_Setter";

  String get origin() native "Location_origin_Getter";

  String get pathname() native "Location_pathname_Getter";

  void set pathname(String) native "Location_pathname_Setter";

  String get port() native "Location_port_Getter";

  void set port(String) native "Location_port_Setter";

  String get protocol() native "Location_protocol_Getter";

  void set protocol(String) native "Location_protocol_Setter";

  String get search() native "Location_search_Getter";

  void set search(String) native "Location_search_Setter";

  void assign(String url) native "Location_assign_Callback";

  void reload() native "Location_reload_Callback";

  void replace(String url) native "Location_replace_Callback";

  String toString() native "Location_toString_Callback";

}
class _MediaControllerFactoryProviderImpl {
  static _MediaControllerDOMImpl createMediaController()
      native "MediaController_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaControllerDOMImpl extends _DOMWrapperBase implements MediaController {
  _MediaControllerDOMImpl();
  String get typeName() => "MediaController";
  _EventsImpl _on;

  _EventsImpl get on() {
    if (_on === null) _on = new _EventsImpl(this);
    return _on;
  }

  TimeRanges get buffered() native "MediaController_buffered_Getter";

  num get currentTime() native "MediaController_currentTime_Getter";

  void set currentTime(num) native "MediaController_currentTime_Setter";

  num get defaultPlaybackRate() native "MediaController_defaultPlaybackRate_Getter";

  void set defaultPlaybackRate(num) native "MediaController_defaultPlaybackRate_Setter";

  num get duration() native "MediaController_duration_Getter";

  bool get muted() native "MediaController_muted_Getter";

  void set muted(bool) native "MediaController_muted_Setter";

  bool get paused() native "MediaController_paused_Getter";

  num get playbackRate() native "MediaController_playbackRate_Getter";

  void set playbackRate(num) native "MediaController_playbackRate_Setter";

  TimeRanges get played() native "MediaController_played_Getter";

  TimeRanges get seekable() native "MediaController_seekable_Getter";

  num get volume() native "MediaController_volume_Getter";

  void set volume(num) native "MediaController_volume_Setter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "MediaController_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "MediaController_dispatchEvent_Callback";

  void pause() {
    _pause();
    return;
  }

  void _pause() native "MediaController_pause_Callback";

  void play() {
    _play();
    return;
  }

  void _play() native "MediaController_play_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "MediaController_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaElementAudioSourceNodeDOMImpl extends _AudioSourceNodeDOMImpl implements MediaElementAudioSourceNode {
  _MediaElementAudioSourceNodeDOMImpl();
  String get typeName() => "MediaElementAudioSourceNode";

  MediaElement get mediaElement() native "MediaElementAudioSourceNode_mediaElement_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaErrorDOMImpl extends _DOMWrapperBase implements MediaError {
  _MediaErrorDOMImpl();
  String get typeName() => "MediaError";

  int get code() native "MediaError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaKeyErrorDOMImpl extends _DOMWrapperBase implements MediaKeyError {
  _MediaKeyErrorDOMImpl();
  String get typeName() => "MediaKeyError";

  int get code() native "MediaKeyError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaKeyEventDOMImpl extends _EventDOMImpl implements MediaKeyEvent {
  _MediaKeyEventDOMImpl();
  String get typeName() => "MediaKeyEvent";

  String get defaultURL() native "MediaKeyEvent_defaultURL_Getter";

  MediaKeyError get errorCode() native "MediaKeyEvent_errorCode_Getter";

  Uint8Array get initData() native "MediaKeyEvent_initData_Getter";

  String get keySystem() native "MediaKeyEvent_keySystem_Getter";

  Uint8Array get message() native "MediaKeyEvent_message_Getter";

  String get sessionId() native "MediaKeyEvent_sessionId_Getter";

  int get systemCode() native "MediaKeyEvent_systemCode_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaListDOMImpl extends _DOMWrapperBase implements MediaList {
  _MediaListDOMImpl();
  String get typeName() => "MediaList";

  int get length() native "MediaList_length_Getter";

  String get mediaText() native "MediaList_mediaText_Getter";

  void set mediaText(String) native "MediaList_mediaText_Setter";

  String operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(String element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(String element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  String last() {
    return this[length - 1];
  }

  void forEach(void f(String element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(String element)) {
    return _Collections.map(this, [], f);
  }

  Collection<String> filter(bool f(String element)) {
    return _Collections.filter(this, new List<String>(), f);
  }

  bool every(bool f(String element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(String element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<String> iterator() {
    return new _FixedSizeListIterator<String>(this);
  }

  void appendMedium(String newMedium) {
    _appendMedium(newMedium);
    return;
  }

  void _appendMedium(newMedium) native "MediaList_appendMedium_Callback";

  void deleteMedium(String oldMedium) {
    _deleteMedium(oldMedium);
    return;
  }

  void _deleteMedium(oldMedium) native "MediaList_deleteMedium_Callback";

  String item(int index) {
    return _item(index);
  }

  String _item(index) native "MediaList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaQueryListDOMImpl extends _DOMWrapperBase implements MediaQueryList {
  _MediaQueryListDOMImpl();
  String get typeName() => "MediaQueryList";

  bool get matches() native "MediaQueryList_matches_Getter";

  String get media() native "MediaQueryList_media_Getter";

  void addListener(MediaQueryListListener listener) {
    _addListener(listener);
    return;
  }

  void _addListener(listener) native "MediaQueryList_addListener_Callback";

  void removeListener(MediaQueryListListener listener) {
    _removeListener(listener);
    return;
  }

  void _removeListener(listener) native "MediaQueryList_removeListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaStreamEventDOMImpl extends _EventDOMImpl implements MediaStreamEvent {
  _MediaStreamEventDOMImpl();
  String get typeName() => "MediaStreamEvent";

  MediaStream get stream() native "MediaStreamEvent_stream_Getter";

}
class _MediaStreamFactoryProviderImpl {
  static _MediaStreamDOMImpl createMediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks)
      native "MediaStream_constructor_Callback";
}
class _MediaStreamEventsImpl extends _EventsImpl implements MediaStreamEvents {
  _MediaStreamEventsImpl(_ptr) : super(_ptr);
  EventListenerList get ended() => _get('ended');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaStreamDOMImpl extends _DOMWrapperBase implements MediaStream {
  _MediaStreamDOMImpl();
  String get typeName() => "MediaStream";
  _EventsImpl _on;

  _MediaStreamEventsImpl get on() {
    if (_on === null) _on = new _MediaStreamEventsImpl(this);
    return _on;
  }

  MediaStreamTrackList get audioTracks() native "MediaStream_audioTracks_Getter";

  String get label() native "MediaStream_label_Getter";

  int get readyState() native "MediaStream_readyState_Getter";

  MediaStreamTrackList get videoTracks() native "MediaStream_videoTracks_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "MediaStream_addEventListener_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "MediaStream_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "MediaStream_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaStreamListDOMImpl extends _DOMWrapperBase implements MediaStreamList {
  _MediaStreamListDOMImpl();
  String get typeName() => "MediaStreamList";

  int get length() native "MediaStreamList_length_Getter";

  MediaStream item(int index) {
    return _item(index);
  }

  MediaStream _item(index) native "MediaStreamList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaStreamTrackDOMImpl extends _DOMWrapperBase implements MediaStreamTrack {
  _MediaStreamTrackDOMImpl();
  String get typeName() => "MediaStreamTrack";

  bool get enabled() native "MediaStreamTrack_enabled_Getter";

  void set enabled(bool) native "MediaStreamTrack_enabled_Setter";

  String get kind() native "MediaStreamTrack_kind_Getter";

  String get label() native "MediaStreamTrack_label_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MediaStreamTrackListDOMImpl extends _DOMWrapperBase implements MediaStreamTrackList {
  _MediaStreamTrackListDOMImpl();
  String get typeName() => "MediaStreamTrackList";

  int get length() native "MediaStreamTrackList_length_Getter";

  MediaStreamTrack item(int index) {
    return _item(index);
  }

  MediaStreamTrack _item(index) native "MediaStreamTrackList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MemoryInfoDOMImpl extends _DOMWrapperBase implements MemoryInfo {
  _MemoryInfoDOMImpl();
  String get typeName() => "MemoryInfo";

  int get jsHeapSizeLimit() native "MemoryInfo_jsHeapSizeLimit_Getter";

  int get totalJSHeapSize() native "MemoryInfo_totalJSHeapSize_Getter";

  int get usedJSHeapSize() native "MemoryInfo_usedJSHeapSize_Getter";

}
class _MessageChannelFactoryProviderImpl {
  static _MessageChannelDOMImpl createMessageChannel()
      native "MessageChannel_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MessageChannelDOMImpl extends _DOMWrapperBase implements MessageChannel {
  _MessageChannelDOMImpl();
  String get typeName() => "MessageChannel";

  MessagePort get port1() native "MessageChannel_port1_Getter";

  MessagePort get port2() native "MessageChannel_port2_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MessageEventDOMImpl extends _EventDOMImpl implements MessageEvent {
  _MessageEventDOMImpl();
  String get typeName() => "MessageEvent";

  Object get data() native "MessageEvent_data_Getter";

  String get lastEventId() native "MessageEvent_lastEventId_Getter";

  String get origin() native "MessageEvent_origin_Getter";

  List get ports() native "MessageEvent_ports_Getter";

  Window get source() native "MessageEvent_source_Getter";

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts) native "MessageEvent_initMessageEvent_Callback";

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables) native "MessageEvent_webkitInitMessageEvent_Callback";

}

class _MessagePortEventsImpl extends _EventsImpl implements MessagePortEvents {
  _MessagePortEventsImpl(_ptr) : super(_ptr);
  EventListenerList get message() => _get('message');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MessagePortDOMImpl extends _DOMWrapperBase implements MessagePort {
  _MessagePortDOMImpl();
  String get typeName() => "MessagePort";
  _EventsImpl _on;

  _MessagePortEventsImpl get on() {
    if (_on === null) _on = new _MessagePortEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "MessagePort_addEventListener_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "MessagePort_close_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "MessagePort_dispatchEvent_Callback";

  void postMessage(String message, [List messagePorts = null]) native "MessagePort_postMessage_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "MessagePort_removeEventListener_Callback";

  void start() {
    _start();
    return;
  }

  void _start() native "MessagePort_start_Callback";

  void webkitPostMessage(String message, [List transfer = null]) native "MessagePort_webkitPostMessage_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MetadataDOMImpl extends _DOMWrapperBase implements Metadata {
  _MetadataDOMImpl();
  String get typeName() => "Metadata";

  Date get modificationTime() native "Metadata_modificationTime_Getter";

  int get size() native "Metadata_size_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MouseEventDOMImpl extends _UIEventDOMImpl implements MouseEvent {
  _MouseEventDOMImpl();
  String get typeName() => "MouseEvent";

  bool get altKey() native "MouseEvent_altKey_Getter";

  int get button() native "MouseEvent_button_Getter";

  int get clientX() native "MouseEvent_clientX_Getter";

  int get clientY() native "MouseEvent_clientY_Getter";

  bool get ctrlKey() native "MouseEvent_ctrlKey_Getter";

  Clipboard get dataTransfer() native "MouseEvent_dataTransfer_Getter";

  Node get fromElement() native "MouseEvent_fromElement_Getter";

  bool get metaKey() native "MouseEvent_metaKey_Getter";

  int get offsetX() native "MouseEvent_offsetX_Getter";

  int get offsetY() native "MouseEvent_offsetY_Getter";

  EventTarget get relatedTarget() native "MouseEvent_relatedTarget_Getter";

  int get screenX() native "MouseEvent_screenX_Getter";

  int get screenY() native "MouseEvent_screenY_Getter";

  bool get shiftKey() native "MouseEvent_shiftKey_Getter";

  Node get toElement() native "MouseEvent_toElement_Getter";

  int get webkitMovementX() native "MouseEvent_webkitMovementX_Getter";

  int get webkitMovementY() native "MouseEvent_webkitMovementY_Getter";

  int get x() native "MouseEvent_x_Getter";

  int get y() native "MouseEvent_y_Getter";

  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) {
    if ((view === null || view is Window)) {
      _initMouseEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initMouseEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) native "MouseEvent_initMouseEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MutationCallbackDOMImpl extends _DOMWrapperBase implements MutationCallback {
  _MutationCallbackDOMImpl();
  String get typeName() => "MutationCallback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MutationEventDOMImpl extends _EventDOMImpl implements MutationEvent {
  _MutationEventDOMImpl();
  String get typeName() => "MutationEvent";

  int get attrChange() native "MutationEvent_attrChange_Getter";

  String get attrName() native "MutationEvent_attrName_Getter";

  String get newValue() native "MutationEvent_newValue_Getter";

  String get prevValue() native "MutationEvent_prevValue_Getter";

  Node get relatedNode() native "MutationEvent_relatedNode_Getter";

  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) {
    _initMutationEvent(type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange);
    return;
  }

  void _initMutationEvent(type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) native "MutationEvent_initMutationEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _MutationRecordDOMImpl extends _DOMWrapperBase implements MutationRecord {
  _MutationRecordDOMImpl();
  String get typeName() => "MutationRecord";

  NodeList get addedNodes() native "MutationRecord_addedNodes_Getter";

  String get attributeName() native "MutationRecord_attributeName_Getter";

  String get attributeNamespace() native "MutationRecord_attributeNamespace_Getter";

  Node get nextSibling() native "MutationRecord_nextSibling_Getter";

  String get oldValue() native "MutationRecord_oldValue_Getter";

  Node get previousSibling() native "MutationRecord_previousSibling_Getter";

  NodeList get removedNodes() native "MutationRecord_removedNodes_Getter";

  Node get target() native "MutationRecord_target_Getter";

  String get type() native "MutationRecord_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NamedNodeMapDOMImpl extends _DOMWrapperBase implements NamedNodeMap {
  _NamedNodeMapDOMImpl();
  String get typeName() => "NamedNodeMap";

  int get length() native "NamedNodeMap_length_Getter";

  Node operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Node element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Node element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Node last() {
    return this[length - 1];
  }

  void forEach(void f(Node element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Node element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Node> filter(bool f(Node element)) {
    return _Collections.filter(this, new List<Node>(), f);
  }

  bool every(bool f(Node element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Node element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Node> iterator() {
    return new _FixedSizeListIterator<Node>(this);
  }

  Node getNamedItem(String name) {
    return _getNamedItem(name);
  }

  Node _getNamedItem(name) native "NamedNodeMap_getNamedItem_Callback";

  Node getNamedItemNS(String namespaceURI, String localName) {
    return _getNamedItemNS(namespaceURI, localName);
  }

  Node _getNamedItemNS(namespaceURI, localName) native "NamedNodeMap_getNamedItemNS_Callback";

  Node item(int index) {
    return _item(index);
  }

  Node _item(index) native "NamedNodeMap_item_Callback";

  Node removeNamedItem(String name) {
    return _removeNamedItem(name);
  }

  Node _removeNamedItem(name) native "NamedNodeMap_removeNamedItem_Callback";

  Node removeNamedItemNS(String namespaceURI, String localName) {
    return _removeNamedItemNS(namespaceURI, localName);
  }

  Node _removeNamedItemNS(namespaceURI, localName) native "NamedNodeMap_removeNamedItemNS_Callback";

  Node setNamedItem(Node node) {
    return _setNamedItem(node);
  }

  Node _setNamedItem(node) native "NamedNodeMap_setNamedItem_Callback";

  Node setNamedItemNS(Node node) {
    return _setNamedItemNS(node);
  }

  Node _setNamedItemNS(node) native "NamedNodeMap_setNamedItemNS_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NavigatorDOMImpl extends _DOMWrapperBase implements Navigator {
  _NavigatorDOMImpl();
  String get typeName() => "Navigator";

  String get appCodeName() native "Navigator_appCodeName_Getter";

  String get appName() native "Navigator_appName_Getter";

  String get appVersion() native "Navigator_appVersion_Getter";

  bool get cookieEnabled() native "Navigator_cookieEnabled_Getter";

  Geolocation get geolocation() native "Navigator_geolocation_Getter";

  String get language() native "Navigator_language_Getter";

  DOMMimeTypeArray get mimeTypes() native "Navigator_mimeTypes_Getter";

  bool get onLine() native "Navigator_onLine_Getter";

  String get platform() native "Navigator_platform_Getter";

  DOMPluginArray get plugins() native "Navigator_plugins_Getter";

  String get product() native "Navigator_product_Getter";

  String get productSub() native "Navigator_productSub_Getter";

  String get userAgent() native "Navigator_userAgent_Getter";

  String get vendor() native "Navigator_vendor_Getter";

  String get vendorSub() native "Navigator_vendorSub_Getter";

  BatteryManager get webkitBattery() native "Navigator_webkitBattery_Getter";

  PointerLock get webkitPointer() native "Navigator_webkitPointer_Getter";

  void getStorageUpdates() {
    _getStorageUpdates();
    return;
  }

  void _getStorageUpdates() native "Navigator_getStorageUpdates_Callback";

  bool javaEnabled() {
    return _javaEnabled();
  }

  bool _javaEnabled() native "Navigator_javaEnabled_Callback";

  void registerProtocolHandler(String scheme, String url, String title) {
    _registerProtocolHandler(scheme, url, title);
    return;
  }

  void _registerProtocolHandler(scheme, url, title) native "Navigator_registerProtocolHandler_Callback";

  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback = null]) {
    _webkitGetUserMedia(options, successCallback, errorCallback);
    return;
  }

  void _webkitGetUserMedia(options, successCallback, errorCallback) native "Navigator_webkitGetUserMedia_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NavigatorUserMediaErrorDOMImpl extends _DOMWrapperBase implements NavigatorUserMediaError {
  _NavigatorUserMediaErrorDOMImpl();
  String get typeName() => "NavigatorUserMediaError";

  int get code() native "NavigatorUserMediaError_code_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NodeFilterDOMImpl extends _DOMWrapperBase implements NodeFilter {
  _NodeFilterDOMImpl();
  String get typeName() => "NodeFilter";

  int acceptNode(Node n) {
    return _acceptNode(n);
  }

  int _acceptNode(n) native "NodeFilter_acceptNode_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NodeDOMImpl extends _DOMWrapperBase implements Node {
  _NodeDOMImpl();
  String get typeName() => "Node";
  _EventsImpl _on;

  _EventsImpl get on() {
    if (_on === null) _on = new _EventsImpl(this);
    return _on;
  }

  NamedNodeMap get $dom_attributes() native "Node_attributes_Getter";

  NodeList get $dom_childNodes() native "Node_childNodes_Getter";

  Node get $dom_firstChild() native "Node_firstChild_Getter";

  Node get $dom_lastChild() native "Node_lastChild_Getter";

  Node get nextNode() native "Node_nextSibling_Getter";

  int get $dom_nodeType() native "Node_nodeType_Getter";

  Document get document() native "Node_ownerDocument_Getter";

  Node get parent() native "Node_parentNode_Getter";

  Node get previousNode() native "Node_previousSibling_Getter";

  String get text() native "Node_textContent_Getter";

  void set text(String) native "Node_textContent_Setter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "Node_addEventListener_Callback";

  Node $dom_appendChild(Node newChild) native "Node_appendChild_Callback";

  Node clone(bool deep) {
    return _cloneNode(deep);
  }

  Node _cloneNode(deep) native "Node_cloneNode_Callback";

  bool contains(Node other) {
    return _contains(other);
  }

  bool _contains(other) native "Node_contains_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "Node_dispatchEvent_Callback";

  bool hasChildNodes() {
    return _hasChildNodes();
  }

  bool _hasChildNodes() native "Node_hasChildNodes_Callback";

  Node insertBefore(Node newChild, Node refChild) native "Node_insertBefore_Callback";

  Node $dom_removeChild(Node oldChild) native "Node_removeChild_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "Node_removeEventListener_Callback";

  Node $dom_replaceChild(Node newChild, Node oldChild) native "Node_replaceChild_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NodeIteratorDOMImpl extends _DOMWrapperBase implements NodeIterator {
  _NodeIteratorDOMImpl();
  String get typeName() => "NodeIterator";

  bool get expandEntityReferences() native "NodeIterator_expandEntityReferences_Getter";

  NodeFilter get filter() native "NodeIterator_filter_Getter";

  bool get pointerBeforeReferenceNode() native "NodeIterator_pointerBeforeReferenceNode_Getter";

  Node get referenceNode() native "NodeIterator_referenceNode_Getter";

  Node get root() native "NodeIterator_root_Getter";

  int get whatToShow() native "NodeIterator_whatToShow_Getter";

  void detach() {
    _detach();
    return;
  }

  void _detach() native "NodeIterator_detach_Callback";

  Node nextNode() {
    return _nextNode();
  }

  Node _nextNode() native "NodeIterator_nextNode_Callback";

  Node previousNode() {
    return _previousNode();
  }

  Node _previousNode() native "NodeIterator_previousNode_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NodeListDOMImpl extends _DOMWrapperBase implements NodeList {
  _NodeListDOMImpl();
  String get typeName() => "NodeList";

  int get length() native "NodeList_length_Getter";

  Node operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Node element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Node element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Node last() {
    return this[length - 1];
  }

  void forEach(void f(Node element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Node element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Node> filter(bool f(Node element)) {
    return _Collections.filter(this, new List<Node>(), f);
  }

  bool every(bool f(Node element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Node element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Node> iterator() {
    return new _FixedSizeListIterator<Node>(this);
  }

  Node item(int index) {
    return _item(index);
  }

  Node _item(index) native "NodeList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NotationDOMImpl extends _NodeDOMImpl implements Notation {
  _NotationDOMImpl();
  String get typeName() => "Notation";

  String get publicId() native "Notation_publicId_Getter";

  String get systemId() native "Notation_systemId_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NotificationCenterDOMImpl extends _DOMWrapperBase implements NotificationCenter {
  _NotificationCenterDOMImpl();
  String get typeName() => "NotificationCenter";

  int checkPermission() {
    return _checkPermission();
  }

  int _checkPermission() native "NotificationCenter_checkPermission_Callback";

  Notification createHTMLNotification(String url) {
    return _createHTMLNotification(url);
  }

  Notification _createHTMLNotification(url) native "NotificationCenter_createHTMLNotification_Callback";

  Notification createNotification(String iconUrl, String title, String body) {
    return _createNotification(iconUrl, title, body);
  }

  Notification _createNotification(iconUrl, title, body) native "NotificationCenter_createNotification_Callback";

  void requestPermission(VoidCallback callback) native "NotificationCenter_requestPermission_Callback";

}
class _NotificationFactoryProviderImpl {
  static _NotificationDOMImpl createNotification(String title, [Map options = null])
      native "Notification_constructor_Callback";
}
class _NotificationEventsImpl extends _EventsImpl implements NotificationEvents {
  _NotificationEventsImpl(_ptr) : super(_ptr);
  EventListenerList get click() => _get('click');
  EventListenerList get close() => _get('close');
  EventListenerList get display() => _get('display');
  EventListenerList get error() => _get('error');
  EventListenerList get show() => _get('show');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _NotificationDOMImpl extends _DOMWrapperBase implements Notification {
  _NotificationDOMImpl();
  String get typeName() => "Notification";
  _EventsImpl _on;

  _NotificationEventsImpl get on() {
    if (_on === null) _on = new _NotificationEventsImpl(this);
    return _on;
  }

  String get dir() native "Notification_dir_Getter";

  void set dir(String) native "Notification_dir_Setter";

  String get replaceId() native "Notification_replaceId_Getter";

  void set replaceId(String) native "Notification_replaceId_Setter";

  String get tag() native "Notification_tag_Getter";

  void set tag(String) native "Notification_tag_Setter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "Notification_addEventListener_Callback";

  void cancel() {
    _cancel();
    return;
  }

  void _cancel() native "Notification_cancel_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "Notification_close_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "Notification_dispatchEvent_Callback";

  static String permissionLevel() {
    return _permissionLevel();
  }

  static String _permissionLevel() native "Notification_permissionLevel_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "Notification_removeEventListener_Callback";

  static void requestPermission(NotificationPermissionCallback callback) native "Notification_requestPermission_Callback";

  void show() {
    _show();
    return;
  }

  void _show() native "Notification_show_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OESStandardDerivativesDOMImpl extends _DOMWrapperBase implements OESStandardDerivatives {
  _OESStandardDerivativesDOMImpl();
  String get typeName() => "OESStandardDerivatives";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OESTextureFloatDOMImpl extends _DOMWrapperBase implements OESTextureFloat {
  _OESTextureFloatDOMImpl();
  String get typeName() => "OESTextureFloat";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OESVertexArrayObjectDOMImpl extends _DOMWrapperBase implements OESVertexArrayObject {
  _OESVertexArrayObjectDOMImpl();
  String get typeName() => "OESVertexArrayObject";

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _bindVertexArrayOES(arrayObject);
    return;
  }

  void _bindVertexArrayOES(arrayObject) native "OESVertexArrayObject_bindVertexArrayOES_Callback";

  WebGLVertexArrayObjectOES createVertexArrayOES() {
    return _createVertexArrayOES();
  }

  WebGLVertexArrayObjectOES _createVertexArrayOES() native "OESVertexArrayObject_createVertexArrayOES_Callback";

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _deleteVertexArrayOES(arrayObject);
    return;
  }

  void _deleteVertexArrayOES(arrayObject) native "OESVertexArrayObject_deleteVertexArrayOES_Callback";

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    return _isVertexArrayOES(arrayObject);
  }

  bool _isVertexArrayOES(arrayObject) native "OESVertexArrayObject_isVertexArrayOES_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OfflineAudioCompletionEventDOMImpl extends _EventDOMImpl implements OfflineAudioCompletionEvent {
  _OfflineAudioCompletionEventDOMImpl();
  String get typeName() => "OfflineAudioCompletionEvent";

  AudioBuffer get renderedBuffer() native "OfflineAudioCompletionEvent_renderedBuffer_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OperationNotAllowedExceptionDOMImpl extends _DOMWrapperBase implements OperationNotAllowedException {
  _OperationNotAllowedExceptionDOMImpl();
  String get typeName() => "OperationNotAllowedException";

  int get code() native "OperationNotAllowedException_code_Getter";

  String get message() native "OperationNotAllowedException_message_Getter";

  String get name() native "OperationNotAllowedException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "OperationNotAllowedException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OscillatorDOMImpl extends _AudioSourceNodeDOMImpl implements Oscillator {
  _OscillatorDOMImpl();
  String get typeName() => "Oscillator";

  AudioParam get detune() native "Oscillator_detune_Getter";

  AudioParam get frequency() native "Oscillator_frequency_Getter";

  int get playbackState() native "Oscillator_playbackState_Getter";

  int get type() native "Oscillator_type_Getter";

  void set type(int) native "Oscillator_type_Setter";

  void noteOff(num when) {
    _noteOff(when);
    return;
  }

  void _noteOff(when) native "Oscillator_noteOff_Callback";

  void noteOn(num when) {
    _noteOn(when);
    return;
  }

  void _noteOn(when) native "Oscillator_noteOn_Callback";

  void setWaveTable(WaveTable waveTable) {
    _setWaveTable(waveTable);
    return;
  }

  void _setWaveTable(waveTable) native "Oscillator_setWaveTable_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _OverflowEventDOMImpl extends _EventDOMImpl implements OverflowEvent {
  _OverflowEventDOMImpl();
  String get typeName() => "OverflowEvent";

  bool get horizontalOverflow() native "OverflowEvent_horizontalOverflow_Getter";

  int get orient() native "OverflowEvent_orient_Getter";

  bool get verticalOverflow() native "OverflowEvent_verticalOverflow_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PageTransitionEventDOMImpl extends _EventDOMImpl implements PageTransitionEvent {
  _PageTransitionEventDOMImpl();
  String get typeName() => "PageTransitionEvent";

  bool get persisted() native "PageTransitionEvent_persisted_Getter";

}
class _PeerConnection00FactoryProviderImpl {
  static _PeerConnection00DOMImpl createPeerConnection00(String serverConfiguration, IceCallback iceCallback)
      native "PeerConnection00_constructor_Callback";
}
class _PeerConnection00EventsImpl extends _EventsImpl implements PeerConnection00Events {
  _PeerConnection00EventsImpl(_ptr) : super(_ptr);
  EventListenerList get addStream() => _get('addstream');
  EventListenerList get connecting() => _get('connecting');
  EventListenerList get open() => _get('open');
  EventListenerList get removeStream() => _get('removestream');
  EventListenerList get stateChange() => _get('statechange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PeerConnection00DOMImpl extends _DOMWrapperBase implements PeerConnection00 {
  _PeerConnection00DOMImpl();
  String get typeName() => "PeerConnection00";
  _EventsImpl _on;

  _PeerConnection00EventsImpl get on() {
    if (_on === null) _on = new _PeerConnection00EventsImpl(this);
    return _on;
  }

  int get iceState() native "PeerConnection00_iceState_Getter";

  SessionDescription get localDescription() native "PeerConnection00_localDescription_Getter";

  MediaStreamList get localStreams() native "PeerConnection00_localStreams_Getter";

  int get readyState() native "PeerConnection00_readyState_Getter";

  SessionDescription get remoteDescription() native "PeerConnection00_remoteDescription_Getter";

  MediaStreamList get remoteStreams() native "PeerConnection00_remoteStreams_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "PeerConnection00_addEventListener_Callback";

  void addStream(MediaStream stream, [Map mediaStreamHints = null]) {
    //
    // addStream(MediaStream stream)
    // addStream(MediaStream stream, [Optional] Map mediaStreamHints)
    //
    if (mediaStreamHints === null) {
      _addStream(stream);
      return;
    }
    _addStream_2(stream, mediaStreamHints);
    return;
  }

  void _addStream(stream) native "PeerConnection00_addStream_Callback";

  void _addStream_2(stream, mediaStreamHints) native "PeerConnection00_addStream_2_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "PeerConnection00_close_Callback";

  SessionDescription createAnswer(String offer, [Map mediaHints = null]) {
    //
    // createAnswer(String offer)
    // createAnswer(String offer, [Optional] Map mediaHints)
    //
    if (mediaHints === null) {
      return _createAnswer(offer);
    }
    return _createAnswer_2(offer, mediaHints);
  }

  SessionDescription _createAnswer(offer) native "PeerConnection00_createAnswer_Callback";

  SessionDescription _createAnswer_2(offer, mediaHints) native "PeerConnection00_createAnswer_2_Callback";

  SessionDescription createOffer([Map mediaHints = null]) {
    //
    // createOffer()
    // createOffer([Optional] Map mediaHints)
    //
    if (mediaHints === null) {
      return _createOffer();
    }
    return _createOffer_2(mediaHints);
  }

  SessionDescription _createOffer() native "PeerConnection00_createOffer_Callback";

  SessionDescription _createOffer_2(mediaHints) native "PeerConnection00_createOffer_2_Callback";

  bool $dom_dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "PeerConnection00_dispatchEvent_Callback";

  void processIceMessage(IceCandidate candidate) {
    _processIceMessage(candidate);
    return;
  }

  void _processIceMessage(candidate) native "PeerConnection00_processIceMessage_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "PeerConnection00_removeEventListener_Callback";

  void removeStream(MediaStream stream) {
    _removeStream(stream);
    return;
  }

  void _removeStream(stream) native "PeerConnection00_removeStream_Callback";

  void setLocalDescription(int action, SessionDescription desc) {
    _setLocalDescription(action, desc);
    return;
  }

  void _setLocalDescription(action, desc) native "PeerConnection00_setLocalDescription_Callback";

  void setRemoteDescription(int action, SessionDescription desc) {
    _setRemoteDescription(action, desc);
    return;
  }

  void _setRemoteDescription(action, desc) native "PeerConnection00_setRemoteDescription_Callback";

  void startIce([Map iceOptions = null]) {
    //
    // startIce()
    // startIce([Optional] Map iceOptions)
    //
    if (iceOptions === null) {
      _startIce();
      return;
    }
    _startIce_2(iceOptions);
    return;
  }

  void _startIce() native "PeerConnection00_startIce_Callback";

  void _startIce_2(iceOptions) native "PeerConnection00_startIce_2_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PerformanceDOMImpl extends _DOMWrapperBase implements Performance {
  _PerformanceDOMImpl();
  String get typeName() => "Performance";

  MemoryInfo get memory() native "Performance_memory_Getter";

  PerformanceNavigation get navigation() native "Performance_navigation_Getter";

  PerformanceTiming get timing() native "Performance_timing_Getter";

  num webkitNow() {
    return _webkitNow();
  }

  num _webkitNow() native "Performance_webkitNow_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PerformanceNavigationDOMImpl extends _DOMWrapperBase implements PerformanceNavigation {
  _PerformanceNavigationDOMImpl();
  String get typeName() => "PerformanceNavigation";

  int get redirectCount() native "PerformanceNavigation_redirectCount_Getter";

  int get type() native "PerformanceNavigation_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PerformanceTimingDOMImpl extends _DOMWrapperBase implements PerformanceTiming {
  _PerformanceTimingDOMImpl();
  String get typeName() => "PerformanceTiming";

  int get connectEnd() native "PerformanceTiming_connectEnd_Getter";

  int get connectStart() native "PerformanceTiming_connectStart_Getter";

  int get domComplete() native "PerformanceTiming_domComplete_Getter";

  int get domContentLoadedEventEnd() native "PerformanceTiming_domContentLoadedEventEnd_Getter";

  int get domContentLoadedEventStart() native "PerformanceTiming_domContentLoadedEventStart_Getter";

  int get domInteractive() native "PerformanceTiming_domInteractive_Getter";

  int get domLoading() native "PerformanceTiming_domLoading_Getter";

  int get domainLookupEnd() native "PerformanceTiming_domainLookupEnd_Getter";

  int get domainLookupStart() native "PerformanceTiming_domainLookupStart_Getter";

  int get fetchStart() native "PerformanceTiming_fetchStart_Getter";

  int get loadEventEnd() native "PerformanceTiming_loadEventEnd_Getter";

  int get loadEventStart() native "PerformanceTiming_loadEventStart_Getter";

  int get navigationStart() native "PerformanceTiming_navigationStart_Getter";

  int get redirectEnd() native "PerformanceTiming_redirectEnd_Getter";

  int get redirectStart() native "PerformanceTiming_redirectStart_Getter";

  int get requestStart() native "PerformanceTiming_requestStart_Getter";

  int get responseEnd() native "PerformanceTiming_responseEnd_Getter";

  int get responseStart() native "PerformanceTiming_responseStart_Getter";

  int get secureConnectionStart() native "PerformanceTiming_secureConnectionStart_Getter";

  int get unloadEventEnd() native "PerformanceTiming_unloadEventEnd_Getter";

  int get unloadEventStart() native "PerformanceTiming_unloadEventStart_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PointerLockDOMImpl extends _DOMWrapperBase implements PointerLock {
  _PointerLockDOMImpl();
  String get typeName() => "PointerLock";

  bool get isLocked() native "PointerLock_isLocked_Getter";

  void lock(Element target, [VoidCallback successCallback = null, VoidCallback failureCallback = null]) {
    _lock(target, successCallback, failureCallback);
    return;
  }

  void _lock(target, successCallback, failureCallback) native "PointerLock_lock_Callback";

  void unlock() {
    _unlock();
    return;
  }

  void _unlock() native "PointerLock_unlock_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PopStateEventDOMImpl extends _EventDOMImpl implements PopStateEvent {
  _PopStateEventDOMImpl();
  String get typeName() => "PopStateEvent";

  Object get state() native "PopStateEvent_state_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _PositionErrorDOMImpl extends _DOMWrapperBase implements PositionError {
  _PositionErrorDOMImpl();
  String get typeName() => "PositionError";

  int get code() native "PositionError_code_Getter";

  String get message() native "PositionError_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ProcessingInstructionDOMImpl extends _NodeDOMImpl implements ProcessingInstruction {
  _ProcessingInstructionDOMImpl();
  String get typeName() => "ProcessingInstruction";

  String get data() native "ProcessingInstruction_data_Getter";

  void set data(String) native "ProcessingInstruction_data_Setter";

  StyleSheet get sheet() native "ProcessingInstruction_sheet_Getter";

  String get target() native "ProcessingInstruction_target_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ProgressEventDOMImpl extends _EventDOMImpl implements ProgressEvent {
  _ProgressEventDOMImpl();
  String get typeName() => "ProgressEvent";

  bool get lengthComputable() native "ProgressEvent_lengthComputable_Getter";

  int get loaded() native "ProgressEvent_loaded_Getter";

  int get total() native "ProgressEvent_total_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _RGBColorDOMImpl extends _DOMWrapperBase implements RGBColor {
  _RGBColorDOMImpl();
  String get typeName() => "RGBColor";

  CSSPrimitiveValue get blue() native "RGBColor_blue_Getter";

  CSSPrimitiveValue get green() native "RGBColor_green_Getter";

  CSSPrimitiveValue get red() native "RGBColor_red_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _RadioNodeListDOMImpl extends _NodeListDOMImpl implements RadioNodeList {
  _RadioNodeListDOMImpl();
  String get typeName() => "RadioNodeList";

  String get value() native "RadioNodeList_value_Getter";

  void set value(String) native "RadioNodeList_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _RangeExceptionDOMImpl extends _DOMWrapperBase implements RangeException {
  _RangeExceptionDOMImpl();
  String get typeName() => "RangeException";

  int get code() native "RangeException_code_Getter";

  String get message() native "RangeException_message_Getter";

  String get name() native "RangeException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "RangeException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _RangeDOMImpl extends _DOMWrapperBase implements Range {
  _RangeDOMImpl();
  String get typeName() => "Range";

  bool get collapsed() native "Range_collapsed_Getter";

  Node get commonAncestorContainer() native "Range_commonAncestorContainer_Getter";

  Node get endContainer() native "Range_endContainer_Getter";

  int get endOffset() native "Range_endOffset_Getter";

  Node get startContainer() native "Range_startContainer_Getter";

  int get startOffset() native "Range_startOffset_Getter";

  DocumentFragment cloneContents() {
    return _cloneContents();
  }

  DocumentFragment _cloneContents() native "Range_cloneContents_Callback";

  Range cloneRange() {
    return _cloneRange();
  }

  Range _cloneRange() native "Range_cloneRange_Callback";

  void collapse(bool toStart) {
    _collapse(toStart);
    return;
  }

  void _collapse(toStart) native "Range_collapse_Callback";

  int compareNode(Node refNode) {
    return _compareNode(refNode);
  }

  int _compareNode(refNode) native "Range_compareNode_Callback";

  int comparePoint(Node refNode, int offset) {
    return _comparePoint(refNode, offset);
  }

  int _comparePoint(refNode, offset) native "Range_comparePoint_Callback";

  DocumentFragment createContextualFragment(String html) {
    return _createContextualFragment(html);
  }

  DocumentFragment _createContextualFragment(html) native "Range_createContextualFragment_Callback";

  void deleteContents() {
    _deleteContents();
    return;
  }

  void _deleteContents() native "Range_deleteContents_Callback";

  void detach() {
    _detach();
    return;
  }

  void _detach() native "Range_detach_Callback";

  void expand(String unit) {
    _expand(unit);
    return;
  }

  void _expand(unit) native "Range_expand_Callback";

  DocumentFragment extractContents() {
    return _extractContents();
  }

  DocumentFragment _extractContents() native "Range_extractContents_Callback";

  ClientRect getBoundingClientRect() {
    return _getBoundingClientRect();
  }

  ClientRect _getBoundingClientRect() native "Range_getBoundingClientRect_Callback";

  ClientRectList getClientRects() {
    return _getClientRects();
  }

  ClientRectList _getClientRects() native "Range_getClientRects_Callback";

  void insertNode(Node newNode) {
    _insertNode(newNode);
    return;
  }

  void _insertNode(newNode) native "Range_insertNode_Callback";

  bool intersectsNode(Node refNode) {
    return _intersectsNode(refNode);
  }

  bool _intersectsNode(refNode) native "Range_intersectsNode_Callback";

  bool isPointInRange(Node refNode, int offset) {
    return _isPointInRange(refNode, offset);
  }

  bool _isPointInRange(refNode, offset) native "Range_isPointInRange_Callback";

  void selectNode(Node refNode) {
    _selectNode(refNode);
    return;
  }

  void _selectNode(refNode) native "Range_selectNode_Callback";

  void selectNodeContents(Node refNode) {
    _selectNodeContents(refNode);
    return;
  }

  void _selectNodeContents(refNode) native "Range_selectNodeContents_Callback";

  void setEnd(Node refNode, int offset) {
    _setEnd(refNode, offset);
    return;
  }

  void _setEnd(refNode, offset) native "Range_setEnd_Callback";

  void setEndAfter(Node refNode) {
    _setEndAfter(refNode);
    return;
  }

  void _setEndAfter(refNode) native "Range_setEndAfter_Callback";

  void setEndBefore(Node refNode) {
    _setEndBefore(refNode);
    return;
  }

  void _setEndBefore(refNode) native "Range_setEndBefore_Callback";

  void setStart(Node refNode, int offset) {
    _setStart(refNode, offset);
    return;
  }

  void _setStart(refNode, offset) native "Range_setStart_Callback";

  void setStartAfter(Node refNode) {
    _setStartAfter(refNode);
    return;
  }

  void _setStartAfter(refNode) native "Range_setStartAfter_Callback";

  void setStartBefore(Node refNode) {
    _setStartBefore(refNode);
    return;
  }

  void _setStartBefore(refNode) native "Range_setStartBefore_Callback";

  void surroundContents(Node newParent) {
    _surroundContents(newParent);
    return;
  }

  void _surroundContents(newParent) native "Range_surroundContents_Callback";

  String toString() {
    return _toString();
  }

  String _toString() native "Range_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _RealtimeAnalyserNodeDOMImpl extends _AudioNodeDOMImpl implements RealtimeAnalyserNode {
  _RealtimeAnalyserNodeDOMImpl();
  String get typeName() => "RealtimeAnalyserNode";

  int get fftSize() native "RealtimeAnalyserNode_fftSize_Getter";

  void set fftSize(int) native "RealtimeAnalyserNode_fftSize_Setter";

  int get frequencyBinCount() native "RealtimeAnalyserNode_frequencyBinCount_Getter";

  num get maxDecibels() native "RealtimeAnalyserNode_maxDecibels_Getter";

  void set maxDecibels(num) native "RealtimeAnalyserNode_maxDecibels_Setter";

  num get minDecibels() native "RealtimeAnalyserNode_minDecibels_Getter";

  void set minDecibels(num) native "RealtimeAnalyserNode_minDecibels_Setter";

  num get smoothingTimeConstant() native "RealtimeAnalyserNode_smoothingTimeConstant_Getter";

  void set smoothingTimeConstant(num) native "RealtimeAnalyserNode_smoothingTimeConstant_Setter";

  void getByteFrequencyData(Uint8Array array) {
    _getByteFrequencyData(array);
    return;
  }

  void _getByteFrequencyData(array) native "RealtimeAnalyserNode_getByteFrequencyData_Callback";

  void getByteTimeDomainData(Uint8Array array) {
    _getByteTimeDomainData(array);
    return;
  }

  void _getByteTimeDomainData(array) native "RealtimeAnalyserNode_getByteTimeDomainData_Callback";

  void getFloatFrequencyData(Float32Array array) {
    _getFloatFrequencyData(array);
    return;
  }

  void _getFloatFrequencyData(array) native "RealtimeAnalyserNode_getFloatFrequencyData_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _RectDOMImpl extends _DOMWrapperBase implements Rect {
  _RectDOMImpl();
  String get typeName() => "Rect";

  CSSPrimitiveValue get bottom() native "Rect_bottom_Getter";

  CSSPrimitiveValue get left() native "Rect_left_Getter";

  CSSPrimitiveValue get right() native "Rect_right_Getter";

  CSSPrimitiveValue get top() native "Rect_top_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SQLErrorDOMImpl extends _DOMWrapperBase implements SQLError {
  _SQLErrorDOMImpl();
  String get typeName() => "SQLError";

  int get code() native "SQLError_code_Getter";

  String get message() native "SQLError_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SQLExceptionDOMImpl extends _DOMWrapperBase implements SQLException {
  _SQLExceptionDOMImpl();
  String get typeName() => "SQLException";

  int get code() native "SQLException_code_Getter";

  String get message() native "SQLException_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SQLResultSetDOMImpl extends _DOMWrapperBase implements SQLResultSet {
  _SQLResultSetDOMImpl();
  String get typeName() => "SQLResultSet";

  int get insertId() native "SQLResultSet_insertId_Getter";

  SQLResultSetRowList get rows() native "SQLResultSet_rows_Getter";

  int get rowsAffected() native "SQLResultSet_rowsAffected_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SQLResultSetRowListDOMImpl extends _DOMWrapperBase implements SQLResultSetRowList {
  _SQLResultSetRowListDOMImpl();
  String get typeName() => "SQLResultSetRowList";

  int get length() native "SQLResultSetRowList_length_Getter";

  Object item(int index) native "SQLResultSetRowList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SQLTransactionDOMImpl extends _DOMWrapperBase implements SQLTransaction {
  _SQLTransactionDOMImpl();
  String get typeName() => "SQLTransaction";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SQLTransactionSyncDOMImpl extends _DOMWrapperBase implements SQLTransactionSync {
  _SQLTransactionSyncDOMImpl();
  String get typeName() => "SQLTransactionSync";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAElementDOMImpl extends _SVGElementDOMImpl implements SVGAElement {
  _SVGAElementDOMImpl();
  String get typeName() => "SVGAElement";

  SVGAnimatedString get target() native "SVGAElement_target_Getter";

  SVGAnimatedString get href() native "SVGAElement_href_Getter";

  SVGStringList get requiredExtensions() native "SVGAElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGAElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGAElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGAElement_hasExtension_Callback";

  String get xmllang() native "SVGAElement_xmllang_Getter";

  void set xmllang(String) native "SVGAElement_xmllang_Setter";

  String get xmlspace() native "SVGAElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGAElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGAElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGAElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGAElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGAElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGAElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGAElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGAElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGAElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGAElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGAElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGAElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAltGlyphDefElementDOMImpl extends _SVGElementDOMImpl implements SVGAltGlyphDefElement {
  _SVGAltGlyphDefElementDOMImpl();
  String get typeName() => "SVGAltGlyphDefElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAltGlyphElementDOMImpl extends _SVGTextPositioningElementDOMImpl implements SVGAltGlyphElement {
  _SVGAltGlyphElementDOMImpl();
  String get typeName() => "SVGAltGlyphElement";

  String get format() native "SVGAltGlyphElement_format_Getter";

  void set format(String) native "SVGAltGlyphElement_format_Setter";

  String get glyphRef() native "SVGAltGlyphElement_glyphRef_Getter";

  void set glyphRef(String) native "SVGAltGlyphElement_glyphRef_Setter";

  SVGAnimatedString get href() native "SVGAltGlyphElement_href_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAltGlyphItemElementDOMImpl extends _SVGElementDOMImpl implements SVGAltGlyphItemElement {
  _SVGAltGlyphItemElementDOMImpl();
  String get typeName() => "SVGAltGlyphItemElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAngleDOMImpl extends _DOMWrapperBase implements SVGAngle {
  _SVGAngleDOMImpl();
  String get typeName() => "SVGAngle";

  int get unitType() native "SVGAngle_unitType_Getter";

  num get value() native "SVGAngle_value_Getter";

  void set value(num) native "SVGAngle_value_Setter";

  String get valueAsString() native "SVGAngle_valueAsString_Getter";

  void set valueAsString(String) native "SVGAngle_valueAsString_Setter";

  num get valueInSpecifiedUnits() native "SVGAngle_valueInSpecifiedUnits_Getter";

  void set valueInSpecifiedUnits(num) native "SVGAngle_valueInSpecifiedUnits_Setter";

  void convertToSpecifiedUnits(int unitType) {
    _convertToSpecifiedUnits(unitType);
    return;
  }

  void _convertToSpecifiedUnits(unitType) native "SVGAngle_convertToSpecifiedUnits_Callback";

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    return;
  }

  void _newValueSpecifiedUnits(unitType, valueInSpecifiedUnits) native "SVGAngle_newValueSpecifiedUnits_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimateColorElementDOMImpl extends _SVGAnimationElementDOMImpl implements SVGAnimateColorElement {
  _SVGAnimateColorElementDOMImpl();
  String get typeName() => "SVGAnimateColorElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimateElementDOMImpl extends _SVGAnimationElementDOMImpl implements SVGAnimateElement {
  _SVGAnimateElementDOMImpl();
  String get typeName() => "SVGAnimateElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimateMotionElementDOMImpl extends _SVGAnimationElementDOMImpl implements SVGAnimateMotionElement {
  _SVGAnimateMotionElementDOMImpl();
  String get typeName() => "SVGAnimateMotionElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimateTransformElementDOMImpl extends _SVGAnimationElementDOMImpl implements SVGAnimateTransformElement {
  _SVGAnimateTransformElementDOMImpl();
  String get typeName() => "SVGAnimateTransformElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedAngleDOMImpl extends _DOMWrapperBase implements SVGAnimatedAngle {
  _SVGAnimatedAngleDOMImpl();
  String get typeName() => "SVGAnimatedAngle";

  SVGAngle get animVal() native "SVGAnimatedAngle_animVal_Getter";

  SVGAngle get baseVal() native "SVGAnimatedAngle_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedBooleanDOMImpl extends _DOMWrapperBase implements SVGAnimatedBoolean {
  _SVGAnimatedBooleanDOMImpl();
  String get typeName() => "SVGAnimatedBoolean";

  bool get animVal() native "SVGAnimatedBoolean_animVal_Getter";

  bool get baseVal() native "SVGAnimatedBoolean_baseVal_Getter";

  void set baseVal(bool) native "SVGAnimatedBoolean_baseVal_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedEnumerationDOMImpl extends _DOMWrapperBase implements SVGAnimatedEnumeration {
  _SVGAnimatedEnumerationDOMImpl();
  String get typeName() => "SVGAnimatedEnumeration";

  int get animVal() native "SVGAnimatedEnumeration_animVal_Getter";

  int get baseVal() native "SVGAnimatedEnumeration_baseVal_Getter";

  void set baseVal(int) native "SVGAnimatedEnumeration_baseVal_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedIntegerDOMImpl extends _DOMWrapperBase implements SVGAnimatedInteger {
  _SVGAnimatedIntegerDOMImpl();
  String get typeName() => "SVGAnimatedInteger";

  int get animVal() native "SVGAnimatedInteger_animVal_Getter";

  int get baseVal() native "SVGAnimatedInteger_baseVal_Getter";

  void set baseVal(int) native "SVGAnimatedInteger_baseVal_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedLengthDOMImpl extends _DOMWrapperBase implements SVGAnimatedLength {
  _SVGAnimatedLengthDOMImpl();
  String get typeName() => "SVGAnimatedLength";

  SVGLength get animVal() native "SVGAnimatedLength_animVal_Getter";

  SVGLength get baseVal() native "SVGAnimatedLength_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedLengthListDOMImpl extends _DOMWrapperBase implements SVGAnimatedLengthList {
  _SVGAnimatedLengthListDOMImpl();
  String get typeName() => "SVGAnimatedLengthList";

  SVGLengthList get animVal() native "SVGAnimatedLengthList_animVal_Getter";

  SVGLengthList get baseVal() native "SVGAnimatedLengthList_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedNumberDOMImpl extends _DOMWrapperBase implements SVGAnimatedNumber {
  _SVGAnimatedNumberDOMImpl();
  String get typeName() => "SVGAnimatedNumber";

  num get animVal() native "SVGAnimatedNumber_animVal_Getter";

  num get baseVal() native "SVGAnimatedNumber_baseVal_Getter";

  void set baseVal(num) native "SVGAnimatedNumber_baseVal_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedNumberListDOMImpl extends _DOMWrapperBase implements SVGAnimatedNumberList {
  _SVGAnimatedNumberListDOMImpl();
  String get typeName() => "SVGAnimatedNumberList";

  SVGNumberList get animVal() native "SVGAnimatedNumberList_animVal_Getter";

  SVGNumberList get baseVal() native "SVGAnimatedNumberList_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedPreserveAspectRatioDOMImpl extends _DOMWrapperBase implements SVGAnimatedPreserveAspectRatio {
  _SVGAnimatedPreserveAspectRatioDOMImpl();
  String get typeName() => "SVGAnimatedPreserveAspectRatio";

  SVGPreserveAspectRatio get animVal() native "SVGAnimatedPreserveAspectRatio_animVal_Getter";

  SVGPreserveAspectRatio get baseVal() native "SVGAnimatedPreserveAspectRatio_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedRectDOMImpl extends _DOMWrapperBase implements SVGAnimatedRect {
  _SVGAnimatedRectDOMImpl();
  String get typeName() => "SVGAnimatedRect";

  SVGRect get animVal() native "SVGAnimatedRect_animVal_Getter";

  SVGRect get baseVal() native "SVGAnimatedRect_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedStringDOMImpl extends _DOMWrapperBase implements SVGAnimatedString {
  _SVGAnimatedStringDOMImpl();
  String get typeName() => "SVGAnimatedString";

  String get animVal() native "SVGAnimatedString_animVal_Getter";

  String get baseVal() native "SVGAnimatedString_baseVal_Getter";

  void set baseVal(String) native "SVGAnimatedString_baseVal_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimatedTransformListDOMImpl extends _DOMWrapperBase implements SVGAnimatedTransformList {
  _SVGAnimatedTransformListDOMImpl();
  String get typeName() => "SVGAnimatedTransformList";

  SVGTransformList get animVal() native "SVGAnimatedTransformList_animVal_Getter";

  SVGTransformList get baseVal() native "SVGAnimatedTransformList_baseVal_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGAnimationElementDOMImpl extends _SVGElementDOMImpl implements SVGAnimationElement {
  _SVGAnimationElementDOMImpl();
  String get typeName() => "SVGAnimationElement";

  SVGElement get targetElement() native "SVGAnimationElement_targetElement_Getter";

  num getCurrentTime() {
    return _getCurrentTime();
  }

  num _getCurrentTime() native "SVGAnimationElement_getCurrentTime_Callback";

  num getSimpleDuration() {
    return _getSimpleDuration();
  }

  num _getSimpleDuration() native "SVGAnimationElement_getSimpleDuration_Callback";

  num getStartTime() {
    return _getStartTime();
  }

  num _getStartTime() native "SVGAnimationElement_getStartTime_Callback";

  SVGStringList get requiredExtensions() native "SVGAnimationElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGAnimationElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGAnimationElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGAnimationElement_hasExtension_Callback";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGAnimationElement_externalResourcesRequired_Getter";

  void beginElement() {
    _beginElement();
    return;
  }

  void _beginElement() native "SVGAnimationElement_beginElement_Callback";

  void beginElementAt(num offset) {
    _beginElementAt(offset);
    return;
  }

  void _beginElementAt(offset) native "SVGAnimationElement_beginElementAt_Callback";

  void endElement() {
    _endElement();
    return;
  }

  void _endElement() native "SVGAnimationElement_endElement_Callback";

  void endElementAt(num offset) {
    _endElementAt(offset);
    return;
  }

  void _endElementAt(offset) native "SVGAnimationElement_endElementAt_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGCircleElementDOMImpl extends _SVGElementDOMImpl implements SVGCircleElement {
  _SVGCircleElementDOMImpl();
  String get typeName() => "SVGCircleElement";

  SVGAnimatedLength get cx() native "SVGCircleElement_cx_Getter";

  SVGAnimatedLength get cy() native "SVGCircleElement_cy_Getter";

  SVGAnimatedLength get r() native "SVGCircleElement_r_Getter";

  SVGStringList get requiredExtensions() native "SVGCircleElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGCircleElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGCircleElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGCircleElement_hasExtension_Callback";

  String get xmllang() native "SVGCircleElement_xmllang_Getter";

  void set xmllang(String) native "SVGCircleElement_xmllang_Setter";

  String get xmlspace() native "SVGCircleElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGCircleElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGCircleElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGCircleElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGCircleElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGCircleElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGCircleElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGCircleElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGCircleElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGCircleElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGCircleElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGCircleElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGCircleElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGClipPathElementDOMImpl extends _SVGElementDOMImpl implements SVGClipPathElement {
  _SVGClipPathElementDOMImpl();
  String get typeName() => "SVGClipPathElement";

  SVGAnimatedEnumeration get clipPathUnits() native "SVGClipPathElement_clipPathUnits_Getter";

  SVGStringList get requiredExtensions() native "SVGClipPathElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGClipPathElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGClipPathElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGClipPathElement_hasExtension_Callback";

  String get xmllang() native "SVGClipPathElement_xmllang_Getter";

  void set xmllang(String) native "SVGClipPathElement_xmllang_Setter";

  String get xmlspace() native "SVGClipPathElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGClipPathElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGClipPathElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGClipPathElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGClipPathElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGClipPathElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGClipPathElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGClipPathElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGClipPathElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGClipPathElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGClipPathElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGClipPathElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGClipPathElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGColorDOMImpl extends _CSSValueDOMImpl implements SVGColor {
  _SVGColorDOMImpl();
  String get typeName() => "SVGColor";

  int get colorType() native "SVGColor_colorType_Getter";

  RGBColor get rgbColor() native "SVGColor_rgbColor_Getter";

  void setColor(int colorType, String rgbColor, String iccColor) {
    _setColor(colorType, rgbColor, iccColor);
    return;
  }

  void _setColor(colorType, rgbColor, iccColor) native "SVGColor_setColor_Callback";

  void setRGBColor(String rgbColor) {
    _setRGBColor(rgbColor);
    return;
  }

  void _setRGBColor(rgbColor) native "SVGColor_setRGBColor_Callback";

  void setRGBColorICCColor(String rgbColor, String iccColor) {
    _setRGBColorICCColor(rgbColor, iccColor);
    return;
  }

  void _setRGBColorICCColor(rgbColor, iccColor) native "SVGColor_setRGBColorICCColor_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGComponentTransferFunctionElementDOMImpl extends _SVGElementDOMImpl implements SVGComponentTransferFunctionElement {
  _SVGComponentTransferFunctionElementDOMImpl();
  String get typeName() => "SVGComponentTransferFunctionElement";

  SVGAnimatedNumber get amplitude() native "SVGComponentTransferFunctionElement_amplitude_Getter";

  SVGAnimatedNumber get exponent() native "SVGComponentTransferFunctionElement_exponent_Getter";

  SVGAnimatedNumber get intercept() native "SVGComponentTransferFunctionElement_intercept_Getter";

  SVGAnimatedNumber get offset() native "SVGComponentTransferFunctionElement_offset_Getter";

  SVGAnimatedNumber get slope() native "SVGComponentTransferFunctionElement_slope_Getter";

  SVGAnimatedNumberList get tableValues() native "SVGComponentTransferFunctionElement_tableValues_Getter";

  SVGAnimatedEnumeration get type() native "SVGComponentTransferFunctionElement_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGCursorElementDOMImpl extends _SVGElementDOMImpl implements SVGCursorElement {
  _SVGCursorElementDOMImpl();
  String get typeName() => "SVGCursorElement";

  SVGAnimatedLength get x() native "SVGCursorElement_x_Getter";

  SVGAnimatedLength get y() native "SVGCursorElement_y_Getter";

  SVGAnimatedString get href() native "SVGCursorElement_href_Getter";

  SVGStringList get requiredExtensions() native "SVGCursorElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGCursorElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGCursorElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGCursorElement_hasExtension_Callback";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGCursorElement_externalResourcesRequired_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGDefsElementDOMImpl extends _SVGElementDOMImpl implements SVGDefsElement {
  _SVGDefsElementDOMImpl();
  String get typeName() => "SVGDefsElement";

  SVGStringList get requiredExtensions() native "SVGDefsElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGDefsElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGDefsElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGDefsElement_hasExtension_Callback";

  String get xmllang() native "SVGDefsElement_xmllang_Getter";

  void set xmllang(String) native "SVGDefsElement_xmllang_Setter";

  String get xmlspace() native "SVGDefsElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGDefsElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGDefsElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGDefsElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGDefsElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGDefsElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGDefsElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGDefsElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGDefsElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGDefsElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGDefsElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGDefsElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGDefsElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGDescElementDOMImpl extends _SVGElementDOMImpl implements SVGDescElement {
  _SVGDescElementDOMImpl();
  String get typeName() => "SVGDescElement";

  String get xmllang() native "SVGDescElement_xmllang_Getter";

  void set xmllang(String) native "SVGDescElement_xmllang_Setter";

  String get xmlspace() native "SVGDescElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGDescElement_xmlspace_Setter";

  SVGAnimatedString get $dom_svgClassName() native "SVGDescElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGDescElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGDescElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGDocumentDOMImpl extends _DocumentDOMImpl implements SVGDocument {
  _SVGDocumentDOMImpl();
  String get typeName() => "SVGDocument";

  SVGSVGElement get rootElement() native "SVGDocument_rootElement_Getter";

  Event $dom_createEvent(String eventType) {
    return _createEvent(eventType);
  }

  Event _createEvent(eventType) native "SVGDocument_createEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGElementDOMImpl extends _ElementDOMImpl implements SVGElement {
  _SVGElementDOMImpl();
  String get typeName() => "SVGElement";

  String get id() native "SVGElement_id_Getter";

  void set id(String) native "SVGElement_id_Setter";

  SVGSVGElement get ownerSVGElement() native "SVGElement_ownerSVGElement_Getter";

  SVGElement get viewportElement() native "SVGElement_viewportElement_Getter";

  String get xmlbase() native "SVGElement_xmlbase_Getter";

  void set xmlbase(String) native "SVGElement_xmlbase_Setter";

}

class _SVGElementInstanceEventsImpl extends _EventsImpl implements SVGElementInstanceEvents {
  _SVGElementInstanceEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get beforeCopy() => _get('beforecopy');
  EventListenerList get beforeCut() => _get('beforecut');
  EventListenerList get beforePaste() => _get('beforepaste');
  EventListenerList get blur() => _get('blur');
  EventListenerList get change() => _get('change');
  EventListenerList get click() => _get('click');
  EventListenerList get contextMenu() => _get('contextmenu');
  EventListenerList get copy() => _get('copy');
  EventListenerList get cut() => _get('cut');
  EventListenerList get doubleClick() => _get('dblclick');
  EventListenerList get drag() => _get('drag');
  EventListenerList get dragEnd() => _get('dragend');
  EventListenerList get dragEnter() => _get('dragenter');
  EventListenerList get dragLeave() => _get('dragleave');
  EventListenerList get dragOver() => _get('dragover');
  EventListenerList get dragStart() => _get('dragstart');
  EventListenerList get drop() => _get('drop');
  EventListenerList get error() => _get('error');
  EventListenerList get focus() => _get('focus');
  EventListenerList get input() => _get('input');
  EventListenerList get keyDown() => _get('keydown');
  EventListenerList get keyPress() => _get('keypress');
  EventListenerList get keyUp() => _get('keyup');
  EventListenerList get load() => _get('load');
  EventListenerList get mouseDown() => _get('mousedown');
  EventListenerList get mouseMove() => _get('mousemove');
  EventListenerList get mouseOut() => _get('mouseout');
  EventListenerList get mouseOver() => _get('mouseover');
  EventListenerList get mouseUp() => _get('mouseup');
  EventListenerList get mouseWheel() => _get('mousewheel');
  EventListenerList get paste() => _get('paste');
  EventListenerList get reset() => _get('reset');
  EventListenerList get resize() => _get('resize');
  EventListenerList get scroll() => _get('scroll');
  EventListenerList get search() => _get('search');
  EventListenerList get select() => _get('select');
  EventListenerList get selectStart() => _get('selectstart');
  EventListenerList get submit() => _get('submit');
  EventListenerList get unload() => _get('unload');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGElementInstanceDOMImpl extends _DOMWrapperBase implements SVGElementInstance {
  _SVGElementInstanceDOMImpl();
  String get typeName() => "SVGElementInstance";
  _EventsImpl _on;

  _SVGElementInstanceEventsImpl get on() {
    if (_on === null) _on = new _SVGElementInstanceEventsImpl(this);
    return _on;
  }

  SVGElementInstanceList get childNodes() native "SVGElementInstance_childNodes_Getter";

  SVGElement get correspondingElement() native "SVGElementInstance_correspondingElement_Getter";

  SVGUseElement get correspondingUseElement() native "SVGElementInstance_correspondingUseElement_Getter";

  SVGElementInstance get firstChild() native "SVGElementInstance_firstChild_Getter";

  SVGElementInstance get lastChild() native "SVGElementInstance_lastChild_Getter";

  SVGElementInstance get nextSibling() native "SVGElementInstance_nextSibling_Getter";

  SVGElementInstance get parentNode() native "SVGElementInstance_parentNode_Getter";

  SVGElementInstance get previousSibling() native "SVGElementInstance_previousSibling_Getter";

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "SVGElementInstance_addEventListener_Callback";

  bool dispatchEvent(Event event) {
    return _dispatchEvent(event);
  }

  bool _dispatchEvent(event) native "SVGElementInstance_dispatchEvent_Callback";

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "SVGElementInstance_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGElementInstanceListDOMImpl extends _DOMWrapperBase implements SVGElementInstanceList {
  _SVGElementInstanceListDOMImpl();
  String get typeName() => "SVGElementInstanceList";

  int get length() native "SVGElementInstanceList_length_Getter";

  SVGElementInstance item(int index) {
    return _item(index);
  }

  SVGElementInstance _item(index) native "SVGElementInstanceList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGEllipseElementDOMImpl extends _SVGElementDOMImpl implements SVGEllipseElement {
  _SVGEllipseElementDOMImpl();
  String get typeName() => "SVGEllipseElement";

  SVGAnimatedLength get cx() native "SVGEllipseElement_cx_Getter";

  SVGAnimatedLength get cy() native "SVGEllipseElement_cy_Getter";

  SVGAnimatedLength get rx() native "SVGEllipseElement_rx_Getter";

  SVGAnimatedLength get ry() native "SVGEllipseElement_ry_Getter";

  SVGStringList get requiredExtensions() native "SVGEllipseElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGEllipseElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGEllipseElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGEllipseElement_hasExtension_Callback";

  String get xmllang() native "SVGEllipseElement_xmllang_Getter";

  void set xmllang(String) native "SVGEllipseElement_xmllang_Setter";

  String get xmlspace() native "SVGEllipseElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGEllipseElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGEllipseElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGEllipseElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGEllipseElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGEllipseElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGEllipseElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGEllipseElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGEllipseElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGEllipseElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGEllipseElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGEllipseElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGEllipseElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGExceptionDOMImpl extends _DOMWrapperBase implements SVGException {
  _SVGExceptionDOMImpl();
  String get typeName() => "SVGException";

  int get code() native "SVGException_code_Getter";

  String get message() native "SVGException_message_Getter";

  String get name() native "SVGException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "SVGException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEBlendElementDOMImpl extends _SVGElementDOMImpl implements SVGFEBlendElement {
  _SVGFEBlendElementDOMImpl();
  String get typeName() => "SVGFEBlendElement";

  SVGAnimatedString get in1() native "SVGFEBlendElement_in1_Getter";

  SVGAnimatedString get in2() native "SVGFEBlendElement_in2_Getter";

  SVGAnimatedEnumeration get mode() native "SVGFEBlendElement_mode_Getter";

  SVGAnimatedLength get height() native "SVGFEBlendElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEBlendElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEBlendElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEBlendElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEBlendElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEBlendElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEBlendElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEBlendElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEColorMatrixElementDOMImpl extends _SVGElementDOMImpl implements SVGFEColorMatrixElement {
  _SVGFEColorMatrixElementDOMImpl();
  String get typeName() => "SVGFEColorMatrixElement";

  SVGAnimatedString get in1() native "SVGFEColorMatrixElement_in1_Getter";

  SVGAnimatedEnumeration get type() native "SVGFEColorMatrixElement_type_Getter";

  SVGAnimatedNumberList get values() native "SVGFEColorMatrixElement_values_Getter";

  SVGAnimatedLength get height() native "SVGFEColorMatrixElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEColorMatrixElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEColorMatrixElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEColorMatrixElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEColorMatrixElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEColorMatrixElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEColorMatrixElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEColorMatrixElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEComponentTransferElementDOMImpl extends _SVGElementDOMImpl implements SVGFEComponentTransferElement {
  _SVGFEComponentTransferElementDOMImpl();
  String get typeName() => "SVGFEComponentTransferElement";

  SVGAnimatedString get in1() native "SVGFEComponentTransferElement_in1_Getter";

  SVGAnimatedLength get height() native "SVGFEComponentTransferElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEComponentTransferElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEComponentTransferElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEComponentTransferElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEComponentTransferElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEComponentTransferElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEComponentTransferElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEComponentTransferElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFECompositeElementDOMImpl extends _SVGElementDOMImpl implements SVGFECompositeElement {
  _SVGFECompositeElementDOMImpl();
  String get typeName() => "SVGFECompositeElement";

  SVGAnimatedString get in1() native "SVGFECompositeElement_in1_Getter";

  SVGAnimatedString get in2() native "SVGFECompositeElement_in2_Getter";

  SVGAnimatedNumber get k1() native "SVGFECompositeElement_k1_Getter";

  SVGAnimatedNumber get k2() native "SVGFECompositeElement_k2_Getter";

  SVGAnimatedNumber get k3() native "SVGFECompositeElement_k3_Getter";

  SVGAnimatedNumber get k4() native "SVGFECompositeElement_k4_Getter";

  SVGAnimatedEnumeration get operator() native "SVGFECompositeElement_operator_Getter";

  SVGAnimatedLength get height() native "SVGFECompositeElement_height_Getter";

  SVGAnimatedString get result() native "SVGFECompositeElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFECompositeElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFECompositeElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFECompositeElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFECompositeElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFECompositeElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFECompositeElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEConvolveMatrixElementDOMImpl extends _SVGElementDOMImpl implements SVGFEConvolveMatrixElement {
  _SVGFEConvolveMatrixElementDOMImpl();
  String get typeName() => "SVGFEConvolveMatrixElement";

  SVGAnimatedNumber get bias() native "SVGFEConvolveMatrixElement_bias_Getter";

  SVGAnimatedNumber get divisor() native "SVGFEConvolveMatrixElement_divisor_Getter";

  SVGAnimatedEnumeration get edgeMode() native "SVGFEConvolveMatrixElement_edgeMode_Getter";

  SVGAnimatedString get in1() native "SVGFEConvolveMatrixElement_in1_Getter";

  SVGAnimatedNumberList get kernelMatrix() native "SVGFEConvolveMatrixElement_kernelMatrix_Getter";

  SVGAnimatedNumber get kernelUnitLengthX() native "SVGFEConvolveMatrixElement_kernelUnitLengthX_Getter";

  SVGAnimatedNumber get kernelUnitLengthY() native "SVGFEConvolveMatrixElement_kernelUnitLengthY_Getter";

  SVGAnimatedInteger get orderX() native "SVGFEConvolveMatrixElement_orderX_Getter";

  SVGAnimatedInteger get orderY() native "SVGFEConvolveMatrixElement_orderY_Getter";

  SVGAnimatedBoolean get preserveAlpha() native "SVGFEConvolveMatrixElement_preserveAlpha_Getter";

  SVGAnimatedInteger get targetX() native "SVGFEConvolveMatrixElement_targetX_Getter";

  SVGAnimatedInteger get targetY() native "SVGFEConvolveMatrixElement_targetY_Getter";

  SVGAnimatedLength get height() native "SVGFEConvolveMatrixElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEConvolveMatrixElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEConvolveMatrixElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEConvolveMatrixElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEConvolveMatrixElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEConvolveMatrixElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEConvolveMatrixElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEConvolveMatrixElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEDiffuseLightingElementDOMImpl extends _SVGElementDOMImpl implements SVGFEDiffuseLightingElement {
  _SVGFEDiffuseLightingElementDOMImpl();
  String get typeName() => "SVGFEDiffuseLightingElement";

  SVGAnimatedNumber get diffuseConstant() native "SVGFEDiffuseLightingElement_diffuseConstant_Getter";

  SVGAnimatedString get in1() native "SVGFEDiffuseLightingElement_in1_Getter";

  SVGAnimatedNumber get kernelUnitLengthX() native "SVGFEDiffuseLightingElement_kernelUnitLengthX_Getter";

  SVGAnimatedNumber get kernelUnitLengthY() native "SVGFEDiffuseLightingElement_kernelUnitLengthY_Getter";

  SVGAnimatedNumber get surfaceScale() native "SVGFEDiffuseLightingElement_surfaceScale_Getter";

  SVGAnimatedLength get height() native "SVGFEDiffuseLightingElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEDiffuseLightingElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEDiffuseLightingElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEDiffuseLightingElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEDiffuseLightingElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEDiffuseLightingElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEDiffuseLightingElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEDiffuseLightingElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEDisplacementMapElementDOMImpl extends _SVGElementDOMImpl implements SVGFEDisplacementMapElement {
  _SVGFEDisplacementMapElementDOMImpl();
  String get typeName() => "SVGFEDisplacementMapElement";

  SVGAnimatedString get in1() native "SVGFEDisplacementMapElement_in1_Getter";

  SVGAnimatedString get in2() native "SVGFEDisplacementMapElement_in2_Getter";

  SVGAnimatedNumber get scale() native "SVGFEDisplacementMapElement_scale_Getter";

  SVGAnimatedEnumeration get xChannelSelector() native "SVGFEDisplacementMapElement_xChannelSelector_Getter";

  SVGAnimatedEnumeration get yChannelSelector() native "SVGFEDisplacementMapElement_yChannelSelector_Getter";

  SVGAnimatedLength get height() native "SVGFEDisplacementMapElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEDisplacementMapElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEDisplacementMapElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEDisplacementMapElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEDisplacementMapElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEDisplacementMapElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEDisplacementMapElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEDisplacementMapElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEDistantLightElementDOMImpl extends _SVGElementDOMImpl implements SVGFEDistantLightElement {
  _SVGFEDistantLightElementDOMImpl();
  String get typeName() => "SVGFEDistantLightElement";

  SVGAnimatedNumber get azimuth() native "SVGFEDistantLightElement_azimuth_Getter";

  SVGAnimatedNumber get elevation() native "SVGFEDistantLightElement_elevation_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEDropShadowElementDOMImpl extends _SVGElementDOMImpl implements SVGFEDropShadowElement {
  _SVGFEDropShadowElementDOMImpl();
  String get typeName() => "SVGFEDropShadowElement";

  SVGAnimatedNumber get dx() native "SVGFEDropShadowElement_dx_Getter";

  SVGAnimatedNumber get dy() native "SVGFEDropShadowElement_dy_Getter";

  SVGAnimatedString get in1() native "SVGFEDropShadowElement_in1_Getter";

  SVGAnimatedNumber get stdDeviationX() native "SVGFEDropShadowElement_stdDeviationX_Getter";

  SVGAnimatedNumber get stdDeviationY() native "SVGFEDropShadowElement_stdDeviationY_Getter";

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _setStdDeviation(stdDeviationX, stdDeviationY);
    return;
  }

  void _setStdDeviation(stdDeviationX, stdDeviationY) native "SVGFEDropShadowElement_setStdDeviation_Callback";

  SVGAnimatedLength get height() native "SVGFEDropShadowElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEDropShadowElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEDropShadowElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEDropShadowElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEDropShadowElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEDropShadowElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEDropShadowElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEDropShadowElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEFloodElementDOMImpl extends _SVGElementDOMImpl implements SVGFEFloodElement {
  _SVGFEFloodElementDOMImpl();
  String get typeName() => "SVGFEFloodElement";

  SVGAnimatedLength get height() native "SVGFEFloodElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEFloodElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEFloodElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEFloodElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEFloodElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEFloodElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEFloodElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEFloodElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEFuncAElementDOMImpl extends _SVGComponentTransferFunctionElementDOMImpl implements SVGFEFuncAElement {
  _SVGFEFuncAElementDOMImpl();
  String get typeName() => "SVGFEFuncAElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEFuncBElementDOMImpl extends _SVGComponentTransferFunctionElementDOMImpl implements SVGFEFuncBElement {
  _SVGFEFuncBElementDOMImpl();
  String get typeName() => "SVGFEFuncBElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEFuncGElementDOMImpl extends _SVGComponentTransferFunctionElementDOMImpl implements SVGFEFuncGElement {
  _SVGFEFuncGElementDOMImpl();
  String get typeName() => "SVGFEFuncGElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEFuncRElementDOMImpl extends _SVGComponentTransferFunctionElementDOMImpl implements SVGFEFuncRElement {
  _SVGFEFuncRElementDOMImpl();
  String get typeName() => "SVGFEFuncRElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEGaussianBlurElementDOMImpl extends _SVGElementDOMImpl implements SVGFEGaussianBlurElement {
  _SVGFEGaussianBlurElementDOMImpl();
  String get typeName() => "SVGFEGaussianBlurElement";

  SVGAnimatedString get in1() native "SVGFEGaussianBlurElement_in1_Getter";

  SVGAnimatedNumber get stdDeviationX() native "SVGFEGaussianBlurElement_stdDeviationX_Getter";

  SVGAnimatedNumber get stdDeviationY() native "SVGFEGaussianBlurElement_stdDeviationY_Getter";

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _setStdDeviation(stdDeviationX, stdDeviationY);
    return;
  }

  void _setStdDeviation(stdDeviationX, stdDeviationY) native "SVGFEGaussianBlurElement_setStdDeviation_Callback";

  SVGAnimatedLength get height() native "SVGFEGaussianBlurElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEGaussianBlurElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEGaussianBlurElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEGaussianBlurElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEGaussianBlurElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEGaussianBlurElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEGaussianBlurElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEGaussianBlurElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEImageElementDOMImpl extends _SVGElementDOMImpl implements SVGFEImageElement {
  _SVGFEImageElementDOMImpl();
  String get typeName() => "SVGFEImageElement";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGFEImageElement_preserveAspectRatio_Getter";

  SVGAnimatedString get href() native "SVGFEImageElement_href_Getter";

  String get xmllang() native "SVGFEImageElement_xmllang_Getter";

  void set xmllang(String) native "SVGFEImageElement_xmllang_Setter";

  String get xmlspace() native "SVGFEImageElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGFEImageElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGFEImageElement_externalResourcesRequired_Getter";

  SVGAnimatedLength get height() native "SVGFEImageElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEImageElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEImageElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEImageElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEImageElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEImageElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEImageElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEImageElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEMergeElementDOMImpl extends _SVGElementDOMImpl implements SVGFEMergeElement {
  _SVGFEMergeElementDOMImpl();
  String get typeName() => "SVGFEMergeElement";

  SVGAnimatedLength get height() native "SVGFEMergeElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEMergeElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEMergeElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEMergeElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEMergeElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEMergeElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEMergeElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEMergeElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEMergeNodeElementDOMImpl extends _SVGElementDOMImpl implements SVGFEMergeNodeElement {
  _SVGFEMergeNodeElementDOMImpl();
  String get typeName() => "SVGFEMergeNodeElement";

  SVGAnimatedString get in1() native "SVGFEMergeNodeElement_in1_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEMorphologyElementDOMImpl extends _SVGElementDOMImpl implements SVGFEMorphologyElement {
  _SVGFEMorphologyElementDOMImpl();
  String get typeName() => "SVGFEMorphologyElement";

  SVGAnimatedString get in1() native "SVGFEMorphologyElement_in1_Getter";

  SVGAnimatedEnumeration get operator() native "SVGFEMorphologyElement_operator_Getter";

  SVGAnimatedNumber get radiusX() native "SVGFEMorphologyElement_radiusX_Getter";

  SVGAnimatedNumber get radiusY() native "SVGFEMorphologyElement_radiusY_Getter";

  void setRadius(num radiusX, num radiusY) {
    _setRadius(radiusX, radiusY);
    return;
  }

  void _setRadius(radiusX, radiusY) native "SVGFEMorphologyElement_setRadius_Callback";

  SVGAnimatedLength get height() native "SVGFEMorphologyElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEMorphologyElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEMorphologyElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEMorphologyElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEMorphologyElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEMorphologyElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEMorphologyElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEMorphologyElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEOffsetElementDOMImpl extends _SVGElementDOMImpl implements SVGFEOffsetElement {
  _SVGFEOffsetElementDOMImpl();
  String get typeName() => "SVGFEOffsetElement";

  SVGAnimatedNumber get dx() native "SVGFEOffsetElement_dx_Getter";

  SVGAnimatedNumber get dy() native "SVGFEOffsetElement_dy_Getter";

  SVGAnimatedString get in1() native "SVGFEOffsetElement_in1_Getter";

  SVGAnimatedLength get height() native "SVGFEOffsetElement_height_Getter";

  SVGAnimatedString get result() native "SVGFEOffsetElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFEOffsetElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFEOffsetElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFEOffsetElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFEOffsetElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFEOffsetElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFEOffsetElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFEPointLightElementDOMImpl extends _SVGElementDOMImpl implements SVGFEPointLightElement {
  _SVGFEPointLightElementDOMImpl();
  String get typeName() => "SVGFEPointLightElement";

  SVGAnimatedNumber get x() native "SVGFEPointLightElement_x_Getter";

  SVGAnimatedNumber get y() native "SVGFEPointLightElement_y_Getter";

  SVGAnimatedNumber get z() native "SVGFEPointLightElement_z_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFESpecularLightingElementDOMImpl extends _SVGElementDOMImpl implements SVGFESpecularLightingElement {
  _SVGFESpecularLightingElementDOMImpl();
  String get typeName() => "SVGFESpecularLightingElement";

  SVGAnimatedString get in1() native "SVGFESpecularLightingElement_in1_Getter";

  SVGAnimatedNumber get specularConstant() native "SVGFESpecularLightingElement_specularConstant_Getter";

  SVGAnimatedNumber get specularExponent() native "SVGFESpecularLightingElement_specularExponent_Getter";

  SVGAnimatedNumber get surfaceScale() native "SVGFESpecularLightingElement_surfaceScale_Getter";

  SVGAnimatedLength get height() native "SVGFESpecularLightingElement_height_Getter";

  SVGAnimatedString get result() native "SVGFESpecularLightingElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFESpecularLightingElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFESpecularLightingElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFESpecularLightingElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFESpecularLightingElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFESpecularLightingElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFESpecularLightingElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFESpotLightElementDOMImpl extends _SVGElementDOMImpl implements SVGFESpotLightElement {
  _SVGFESpotLightElementDOMImpl();
  String get typeName() => "SVGFESpotLightElement";

  SVGAnimatedNumber get limitingConeAngle() native "SVGFESpotLightElement_limitingConeAngle_Getter";

  SVGAnimatedNumber get pointsAtX() native "SVGFESpotLightElement_pointsAtX_Getter";

  SVGAnimatedNumber get pointsAtY() native "SVGFESpotLightElement_pointsAtY_Getter";

  SVGAnimatedNumber get pointsAtZ() native "SVGFESpotLightElement_pointsAtZ_Getter";

  SVGAnimatedNumber get specularExponent() native "SVGFESpotLightElement_specularExponent_Getter";

  SVGAnimatedNumber get x() native "SVGFESpotLightElement_x_Getter";

  SVGAnimatedNumber get y() native "SVGFESpotLightElement_y_Getter";

  SVGAnimatedNumber get z() native "SVGFESpotLightElement_z_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFETileElementDOMImpl extends _SVGElementDOMImpl implements SVGFETileElement {
  _SVGFETileElementDOMImpl();
  String get typeName() => "SVGFETileElement";

  SVGAnimatedString get in1() native "SVGFETileElement_in1_Getter";

  SVGAnimatedLength get height() native "SVGFETileElement_height_Getter";

  SVGAnimatedString get result() native "SVGFETileElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFETileElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFETileElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFETileElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFETileElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFETileElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFETileElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFETurbulenceElementDOMImpl extends _SVGElementDOMImpl implements SVGFETurbulenceElement {
  _SVGFETurbulenceElementDOMImpl();
  String get typeName() => "SVGFETurbulenceElement";

  SVGAnimatedNumber get baseFrequencyX() native "SVGFETurbulenceElement_baseFrequencyX_Getter";

  SVGAnimatedNumber get baseFrequencyY() native "SVGFETurbulenceElement_baseFrequencyY_Getter";

  SVGAnimatedInteger get numOctaves() native "SVGFETurbulenceElement_numOctaves_Getter";

  SVGAnimatedNumber get seed() native "SVGFETurbulenceElement_seed_Getter";

  SVGAnimatedEnumeration get stitchTiles() native "SVGFETurbulenceElement_stitchTiles_Getter";

  SVGAnimatedEnumeration get type() native "SVGFETurbulenceElement_type_Getter";

  SVGAnimatedLength get height() native "SVGFETurbulenceElement_height_Getter";

  SVGAnimatedString get result() native "SVGFETurbulenceElement_result_Getter";

  SVGAnimatedLength get width() native "SVGFETurbulenceElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFETurbulenceElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFETurbulenceElement_y_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFETurbulenceElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFETurbulenceElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFETurbulenceElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFilterElementDOMImpl extends _SVGElementDOMImpl implements SVGFilterElement {
  _SVGFilterElementDOMImpl();
  String get typeName() => "SVGFilterElement";

  SVGAnimatedInteger get filterResX() native "SVGFilterElement_filterResX_Getter";

  SVGAnimatedInteger get filterResY() native "SVGFilterElement_filterResY_Getter";

  SVGAnimatedEnumeration get filterUnits() native "SVGFilterElement_filterUnits_Getter";

  SVGAnimatedLength get height() native "SVGFilterElement_height_Getter";

  SVGAnimatedEnumeration get primitiveUnits() native "SVGFilterElement_primitiveUnits_Getter";

  SVGAnimatedLength get width() native "SVGFilterElement_width_Getter";

  SVGAnimatedLength get x() native "SVGFilterElement_x_Getter";

  SVGAnimatedLength get y() native "SVGFilterElement_y_Getter";

  void setFilterRes(int filterResX, int filterResY) {
    _setFilterRes(filterResX, filterResY);
    return;
  }

  void _setFilterRes(filterResX, filterResY) native "SVGFilterElement_setFilterRes_Callback";

  SVGAnimatedString get href() native "SVGFilterElement_href_Getter";

  String get xmllang() native "SVGFilterElement_xmllang_Getter";

  void set xmllang(String) native "SVGFilterElement_xmllang_Setter";

  String get xmlspace() native "SVGFilterElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGFilterElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGFilterElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGFilterElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGFilterElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGFilterElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFontElementDOMImpl extends _SVGElementDOMImpl implements SVGFontElement {
  _SVGFontElementDOMImpl();
  String get typeName() => "SVGFontElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFontFaceElementDOMImpl extends _SVGElementDOMImpl implements SVGFontFaceElement {
  _SVGFontFaceElementDOMImpl();
  String get typeName() => "SVGFontFaceElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFontFaceFormatElementDOMImpl extends _SVGElementDOMImpl implements SVGFontFaceFormatElement {
  _SVGFontFaceFormatElementDOMImpl();
  String get typeName() => "SVGFontFaceFormatElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFontFaceNameElementDOMImpl extends _SVGElementDOMImpl implements SVGFontFaceNameElement {
  _SVGFontFaceNameElementDOMImpl();
  String get typeName() => "SVGFontFaceNameElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFontFaceSrcElementDOMImpl extends _SVGElementDOMImpl implements SVGFontFaceSrcElement {
  _SVGFontFaceSrcElementDOMImpl();
  String get typeName() => "SVGFontFaceSrcElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGFontFaceUriElementDOMImpl extends _SVGElementDOMImpl implements SVGFontFaceUriElement {
  _SVGFontFaceUriElementDOMImpl();
  String get typeName() => "SVGFontFaceUriElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGForeignObjectElementDOMImpl extends _SVGElementDOMImpl implements SVGForeignObjectElement {
  _SVGForeignObjectElementDOMImpl();
  String get typeName() => "SVGForeignObjectElement";

  SVGAnimatedLength get height() native "SVGForeignObjectElement_height_Getter";

  SVGAnimatedLength get width() native "SVGForeignObjectElement_width_Getter";

  SVGAnimatedLength get x() native "SVGForeignObjectElement_x_Getter";

  SVGAnimatedLength get y() native "SVGForeignObjectElement_y_Getter";

  SVGStringList get requiredExtensions() native "SVGForeignObjectElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGForeignObjectElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGForeignObjectElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGForeignObjectElement_hasExtension_Callback";

  String get xmllang() native "SVGForeignObjectElement_xmllang_Getter";

  void set xmllang(String) native "SVGForeignObjectElement_xmllang_Setter";

  String get xmlspace() native "SVGForeignObjectElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGForeignObjectElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGForeignObjectElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGForeignObjectElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGForeignObjectElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGForeignObjectElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGForeignObjectElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGForeignObjectElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGForeignObjectElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGForeignObjectElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGForeignObjectElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGForeignObjectElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGForeignObjectElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGGElementDOMImpl extends _SVGElementDOMImpl implements SVGGElement {
  _SVGGElementDOMImpl();
  String get typeName() => "SVGGElement";

  SVGStringList get requiredExtensions() native "SVGGElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGGElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGGElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGGElement_hasExtension_Callback";

  String get xmllang() native "SVGGElement_xmllang_Getter";

  void set xmllang(String) native "SVGGElement_xmllang_Setter";

  String get xmlspace() native "SVGGElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGGElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGGElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGGElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGGElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGGElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGGElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGGElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGGElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGGElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGGElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGGElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGGElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGGlyphElementDOMImpl extends _SVGElementDOMImpl implements SVGGlyphElement {
  _SVGGlyphElementDOMImpl();
  String get typeName() => "SVGGlyphElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGGlyphRefElementDOMImpl extends _SVGElementDOMImpl implements SVGGlyphRefElement {
  _SVGGlyphRefElementDOMImpl();
  String get typeName() => "SVGGlyphRefElement";

  num get dx() native "SVGGlyphRefElement_dx_Getter";

  void set dx(num) native "SVGGlyphRefElement_dx_Setter";

  num get dy() native "SVGGlyphRefElement_dy_Getter";

  void set dy(num) native "SVGGlyphRefElement_dy_Setter";

  String get format() native "SVGGlyphRefElement_format_Getter";

  void set format(String) native "SVGGlyphRefElement_format_Setter";

  String get glyphRef() native "SVGGlyphRefElement_glyphRef_Getter";

  void set glyphRef(String) native "SVGGlyphRefElement_glyphRef_Setter";

  num get x() native "SVGGlyphRefElement_x_Getter";

  void set x(num) native "SVGGlyphRefElement_x_Setter";

  num get y() native "SVGGlyphRefElement_y_Getter";

  void set y(num) native "SVGGlyphRefElement_y_Setter";

  SVGAnimatedString get href() native "SVGGlyphRefElement_href_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGGlyphRefElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGGlyphRefElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGGlyphRefElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGGradientElementDOMImpl extends _SVGElementDOMImpl implements SVGGradientElement {
  _SVGGradientElementDOMImpl();
  String get typeName() => "SVGGradientElement";

  SVGAnimatedTransformList get gradientTransform() native "SVGGradientElement_gradientTransform_Getter";

  SVGAnimatedEnumeration get gradientUnits() native "SVGGradientElement_gradientUnits_Getter";

  SVGAnimatedEnumeration get spreadMethod() native "SVGGradientElement_spreadMethod_Getter";

  SVGAnimatedString get href() native "SVGGradientElement_href_Getter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGGradientElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGGradientElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGGradientElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGGradientElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGHKernElementDOMImpl extends _SVGElementDOMImpl implements SVGHKernElement {
  _SVGHKernElementDOMImpl();
  String get typeName() => "SVGHKernElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGImageElementDOMImpl extends _SVGElementDOMImpl implements SVGImageElement {
  _SVGImageElementDOMImpl();
  String get typeName() => "SVGImageElement";

  SVGAnimatedLength get height() native "SVGImageElement_height_Getter";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGImageElement_preserveAspectRatio_Getter";

  SVGAnimatedLength get width() native "SVGImageElement_width_Getter";

  SVGAnimatedLength get x() native "SVGImageElement_x_Getter";

  SVGAnimatedLength get y() native "SVGImageElement_y_Getter";

  SVGAnimatedString get href() native "SVGImageElement_href_Getter";

  SVGStringList get requiredExtensions() native "SVGImageElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGImageElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGImageElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGImageElement_hasExtension_Callback";

  String get xmllang() native "SVGImageElement_xmllang_Getter";

  void set xmllang(String) native "SVGImageElement_xmllang_Setter";

  String get xmlspace() native "SVGImageElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGImageElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGImageElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGImageElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGImageElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGImageElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGImageElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGImageElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGImageElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGImageElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGImageElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGImageElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGImageElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGLengthDOMImpl extends _DOMWrapperBase implements SVGLength {
  _SVGLengthDOMImpl();
  String get typeName() => "SVGLength";

  int get unitType() native "SVGLength_unitType_Getter";

  num get value() native "SVGLength_value_Getter";

  void set value(num) native "SVGLength_value_Setter";

  String get valueAsString() native "SVGLength_valueAsString_Getter";

  void set valueAsString(String) native "SVGLength_valueAsString_Setter";

  num get valueInSpecifiedUnits() native "SVGLength_valueInSpecifiedUnits_Getter";

  void set valueInSpecifiedUnits(num) native "SVGLength_valueInSpecifiedUnits_Setter";

  void convertToSpecifiedUnits(int unitType) native "SVGLength_convertToSpecifiedUnits_Callback";

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _newValueSpecifiedUnits(unitType, valueInSpecifiedUnits);
    return;
  }

  void _newValueSpecifiedUnits(unitType, valueInSpecifiedUnits) native "SVGLength_newValueSpecifiedUnits_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGLengthListDOMImpl extends _DOMWrapperBase implements SVGLengthList {
  _SVGLengthListDOMImpl();
  String get typeName() => "SVGLengthList";

  int get numberOfItems() native "SVGLengthList_numberOfItems_Getter";

  SVGLength appendItem(SVGLength item) {
    return _appendItem(item);
  }

  SVGLength _appendItem(item) native "SVGLengthList_appendItem_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "SVGLengthList_clear_Callback";

  SVGLength getItem(int index) {
    return _getItem(index);
  }

  SVGLength _getItem(index) native "SVGLengthList_getItem_Callback";

  SVGLength initialize(SVGLength item) {
    return _initialize(item);
  }

  SVGLength _initialize(item) native "SVGLengthList_initialize_Callback";

  SVGLength insertItemBefore(SVGLength item, int index) {
    return _insertItemBefore(item, index);
  }

  SVGLength _insertItemBefore(item, index) native "SVGLengthList_insertItemBefore_Callback";

  SVGLength removeItem(int index) {
    return _removeItem(index);
  }

  SVGLength _removeItem(index) native "SVGLengthList_removeItem_Callback";

  SVGLength replaceItem(SVGLength item, int index) {
    return _replaceItem(item, index);
  }

  SVGLength _replaceItem(item, index) native "SVGLengthList_replaceItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGLineElementDOMImpl extends _SVGElementDOMImpl implements SVGLineElement {
  _SVGLineElementDOMImpl();
  String get typeName() => "SVGLineElement";

  SVGAnimatedLength get x1() native "SVGLineElement_x1_Getter";

  SVGAnimatedLength get x2() native "SVGLineElement_x2_Getter";

  SVGAnimatedLength get y1() native "SVGLineElement_y1_Getter";

  SVGAnimatedLength get y2() native "SVGLineElement_y2_Getter";

  SVGStringList get requiredExtensions() native "SVGLineElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGLineElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGLineElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGLineElement_hasExtension_Callback";

  String get xmllang() native "SVGLineElement_xmllang_Getter";

  void set xmllang(String) native "SVGLineElement_xmllang_Setter";

  String get xmlspace() native "SVGLineElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGLineElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGLineElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGLineElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGLineElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGLineElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGLineElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGLineElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGLineElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGLineElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGLineElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGLineElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGLineElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGLinearGradientElementDOMImpl extends _SVGGradientElementDOMImpl implements SVGLinearGradientElement {
  _SVGLinearGradientElementDOMImpl();
  String get typeName() => "SVGLinearGradientElement";

  SVGAnimatedLength get x1() native "SVGLinearGradientElement_x1_Getter";

  SVGAnimatedLength get x2() native "SVGLinearGradientElement_x2_Getter";

  SVGAnimatedLength get y1() native "SVGLinearGradientElement_y1_Getter";

  SVGAnimatedLength get y2() native "SVGLinearGradientElement_y2_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGMPathElementDOMImpl extends _SVGElementDOMImpl implements SVGMPathElement {
  _SVGMPathElementDOMImpl();
  String get typeName() => "SVGMPathElement";

  SVGAnimatedString get href() native "SVGMPathElement_href_Getter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGMPathElement_externalResourcesRequired_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGMarkerElementDOMImpl extends _SVGElementDOMImpl implements SVGMarkerElement {
  _SVGMarkerElementDOMImpl();
  String get typeName() => "SVGMarkerElement";

  SVGAnimatedLength get markerHeight() native "SVGMarkerElement_markerHeight_Getter";

  SVGAnimatedEnumeration get markerUnits() native "SVGMarkerElement_markerUnits_Getter";

  SVGAnimatedLength get markerWidth() native "SVGMarkerElement_markerWidth_Getter";

  SVGAnimatedAngle get orientAngle() native "SVGMarkerElement_orientAngle_Getter";

  SVGAnimatedEnumeration get orientType() native "SVGMarkerElement_orientType_Getter";

  SVGAnimatedLength get refX() native "SVGMarkerElement_refX_Getter";

  SVGAnimatedLength get refY() native "SVGMarkerElement_refY_Getter";

  void setOrientToAngle(SVGAngle angle) {
    _setOrientToAngle(angle);
    return;
  }

  void _setOrientToAngle(angle) native "SVGMarkerElement_setOrientToAngle_Callback";

  void setOrientToAuto() {
    _setOrientToAuto();
    return;
  }

  void _setOrientToAuto() native "SVGMarkerElement_setOrientToAuto_Callback";

  String get xmllang() native "SVGMarkerElement_xmllang_Getter";

  void set xmllang(String) native "SVGMarkerElement_xmllang_Setter";

  String get xmlspace() native "SVGMarkerElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGMarkerElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGMarkerElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGMarkerElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGMarkerElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGMarkerElement_getPresentationAttribute_Callback";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGMarkerElement_preserveAspectRatio_Getter";

  SVGAnimatedRect get viewBox() native "SVGMarkerElement_viewBox_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGMaskElementDOMImpl extends _SVGElementDOMImpl implements SVGMaskElement {
  _SVGMaskElementDOMImpl();
  String get typeName() => "SVGMaskElement";

  SVGAnimatedLength get height() native "SVGMaskElement_height_Getter";

  SVGAnimatedEnumeration get maskContentUnits() native "SVGMaskElement_maskContentUnits_Getter";

  SVGAnimatedEnumeration get maskUnits() native "SVGMaskElement_maskUnits_Getter";

  SVGAnimatedLength get width() native "SVGMaskElement_width_Getter";

  SVGAnimatedLength get x() native "SVGMaskElement_x_Getter";

  SVGAnimatedLength get y() native "SVGMaskElement_y_Getter";

  SVGStringList get requiredExtensions() native "SVGMaskElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGMaskElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGMaskElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGMaskElement_hasExtension_Callback";

  String get xmllang() native "SVGMaskElement_xmllang_Getter";

  void set xmllang(String) native "SVGMaskElement_xmllang_Setter";

  String get xmlspace() native "SVGMaskElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGMaskElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGMaskElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGMaskElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGMaskElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGMaskElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGMatrixDOMImpl extends _DOMWrapperBase implements SVGMatrix {
  _SVGMatrixDOMImpl();
  String get typeName() => "SVGMatrix";

  num get a() native "SVGMatrix_a_Getter";

  void set a(num) native "SVGMatrix_a_Setter";

  num get b() native "SVGMatrix_b_Getter";

  void set b(num) native "SVGMatrix_b_Setter";

  num get c() native "SVGMatrix_c_Getter";

  void set c(num) native "SVGMatrix_c_Setter";

  num get d() native "SVGMatrix_d_Getter";

  void set d(num) native "SVGMatrix_d_Setter";

  num get e() native "SVGMatrix_e_Getter";

  void set e(num) native "SVGMatrix_e_Setter";

  num get f() native "SVGMatrix_f_Getter";

  void set f(num) native "SVGMatrix_f_Setter";

  SVGMatrix flipX() {
    return _flipX();
  }

  SVGMatrix _flipX() native "SVGMatrix_flipX_Callback";

  SVGMatrix flipY() {
    return _flipY();
  }

  SVGMatrix _flipY() native "SVGMatrix_flipY_Callback";

  SVGMatrix inverse() {
    return _inverse();
  }

  SVGMatrix _inverse() native "SVGMatrix_inverse_Callback";

  SVGMatrix multiply(SVGMatrix secondMatrix) {
    return _multiply(secondMatrix);
  }

  SVGMatrix _multiply(secondMatrix) native "SVGMatrix_multiply_Callback";

  SVGMatrix rotate(num angle) {
    return _rotate(angle);
  }

  SVGMatrix _rotate(angle) native "SVGMatrix_rotate_Callback";

  SVGMatrix rotateFromVector(num x, num y) {
    return _rotateFromVector(x, y);
  }

  SVGMatrix _rotateFromVector(x, y) native "SVGMatrix_rotateFromVector_Callback";

  SVGMatrix scale(num scaleFactor) {
    return _scale(scaleFactor);
  }

  SVGMatrix _scale(scaleFactor) native "SVGMatrix_scale_Callback";

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY) {
    return _scaleNonUniform(scaleFactorX, scaleFactorY);
  }

  SVGMatrix _scaleNonUniform(scaleFactorX, scaleFactorY) native "SVGMatrix_scaleNonUniform_Callback";

  SVGMatrix skewX(num angle) {
    return _skewX(angle);
  }

  SVGMatrix _skewX(angle) native "SVGMatrix_skewX_Callback";

  SVGMatrix skewY(num angle) {
    return _skewY(angle);
  }

  SVGMatrix _skewY(angle) native "SVGMatrix_skewY_Callback";

  SVGMatrix translate(num x, num y) {
    return _translate(x, y);
  }

  SVGMatrix _translate(x, y) native "SVGMatrix_translate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGMetadataElementDOMImpl extends _SVGElementDOMImpl implements SVGMetadataElement {
  _SVGMetadataElementDOMImpl();
  String get typeName() => "SVGMetadataElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGMissingGlyphElementDOMImpl extends _SVGElementDOMImpl implements SVGMissingGlyphElement {
  _SVGMissingGlyphElementDOMImpl();
  String get typeName() => "SVGMissingGlyphElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGNumberDOMImpl extends _DOMWrapperBase implements SVGNumber {
  _SVGNumberDOMImpl();
  String get typeName() => "SVGNumber";

  num get value() native "SVGNumber_value_Getter";

  void set value(num) native "SVGNumber_value_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGNumberListDOMImpl extends _DOMWrapperBase implements SVGNumberList {
  _SVGNumberListDOMImpl();
  String get typeName() => "SVGNumberList";

  int get numberOfItems() native "SVGNumberList_numberOfItems_Getter";

  SVGNumber appendItem(SVGNumber item) {
    return _appendItem(item);
  }

  SVGNumber _appendItem(item) native "SVGNumberList_appendItem_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "SVGNumberList_clear_Callback";

  SVGNumber getItem(int index) {
    return _getItem(index);
  }

  SVGNumber _getItem(index) native "SVGNumberList_getItem_Callback";

  SVGNumber initialize(SVGNumber item) {
    return _initialize(item);
  }

  SVGNumber _initialize(item) native "SVGNumberList_initialize_Callback";

  SVGNumber insertItemBefore(SVGNumber item, int index) {
    return _insertItemBefore(item, index);
  }

  SVGNumber _insertItemBefore(item, index) native "SVGNumberList_insertItemBefore_Callback";

  SVGNumber removeItem(int index) {
    return _removeItem(index);
  }

  SVGNumber _removeItem(index) native "SVGNumberList_removeItem_Callback";

  SVGNumber replaceItem(SVGNumber item, int index) {
    return _replaceItem(item, index);
  }

  SVGNumber _replaceItem(item, index) native "SVGNumberList_replaceItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPaintDOMImpl extends _SVGColorDOMImpl implements SVGPaint {
  _SVGPaintDOMImpl();
  String get typeName() => "SVGPaint";

  int get paintType() native "SVGPaint_paintType_Getter";

  String get uri() native "SVGPaint_uri_Getter";

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) {
    _setPaint(paintType, uri, rgbColor, iccColor);
    return;
  }

  void _setPaint(paintType, uri, rgbColor, iccColor) native "SVGPaint_setPaint_Callback";

  void setUri(String uri) {
    _setUri(uri);
    return;
  }

  void _setUri(uri) native "SVGPaint_setUri_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathElementDOMImpl extends _SVGElementDOMImpl implements SVGPathElement {
  _SVGPathElementDOMImpl();
  String get typeName() => "SVGPathElement";

  SVGPathSegList get animatedNormalizedPathSegList() native "SVGPathElement_animatedNormalizedPathSegList_Getter";

  SVGPathSegList get animatedPathSegList() native "SVGPathElement_animatedPathSegList_Getter";

  SVGPathSegList get normalizedPathSegList() native "SVGPathElement_normalizedPathSegList_Getter";

  SVGAnimatedNumber get pathLength() native "SVGPathElement_pathLength_Getter";

  SVGPathSegList get pathSegList() native "SVGPathElement_pathSegList_Getter";

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return _createSVGPathSegArcAbs(x, y, r1, r2, angle, largeArcFlag, sweepFlag);
  }

  SVGPathSegArcAbs _createSVGPathSegArcAbs(x, y, r1, r2, angle, largeArcFlag, sweepFlag) native "SVGPathElement_createSVGPathSegArcAbs_Callback";

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return _createSVGPathSegArcRel(x, y, r1, r2, angle, largeArcFlag, sweepFlag);
  }

  SVGPathSegArcRel _createSVGPathSegArcRel(x, y, r1, r2, angle, largeArcFlag, sweepFlag) native "SVGPathElement_createSVGPathSegArcRel_Callback";

  SVGPathSegClosePath createSVGPathSegClosePath() {
    return _createSVGPathSegClosePath();
  }

  SVGPathSegClosePath _createSVGPathSegClosePath() native "SVGPathElement_createSVGPathSegClosePath_Callback";

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) {
    return _createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2);
  }

  SVGPathSegCurvetoCubicAbs _createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2) native "SVGPathElement_createSVGPathSegCurvetoCubicAbs_Callback";

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) {
    return _createSVGPathSegCurvetoCubicRel(x, y, x1, y1, x2, y2);
  }

  SVGPathSegCurvetoCubicRel _createSVGPathSegCurvetoCubicRel(x, y, x1, y1, x2, y2) native "SVGPathElement_createSVGPathSegCurvetoCubicRel_Callback";

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) {
    return _createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2);
  }

  SVGPathSegCurvetoCubicSmoothAbs _createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2) native "SVGPathElement_createSVGPathSegCurvetoCubicSmoothAbs_Callback";

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) {
    return _createSVGPathSegCurvetoCubicSmoothRel(x, y, x2, y2);
  }

  SVGPathSegCurvetoCubicSmoothRel _createSVGPathSegCurvetoCubicSmoothRel(x, y, x2, y2) native "SVGPathElement_createSVGPathSegCurvetoCubicSmoothRel_Callback";

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) {
    return _createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1);
  }

  SVGPathSegCurvetoQuadraticAbs _createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1) native "SVGPathElement_createSVGPathSegCurvetoQuadraticAbs_Callback";

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) {
    return _createSVGPathSegCurvetoQuadraticRel(x, y, x1, y1);
  }

  SVGPathSegCurvetoQuadraticRel _createSVGPathSegCurvetoQuadraticRel(x, y, x1, y1) native "SVGPathElement_createSVGPathSegCurvetoQuadraticRel_Callback";

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) {
    return _createSVGPathSegCurvetoQuadraticSmoothAbs(x, y);
  }

  SVGPathSegCurvetoQuadraticSmoothAbs _createSVGPathSegCurvetoQuadraticSmoothAbs(x, y) native "SVGPathElement_createSVGPathSegCurvetoQuadraticSmoothAbs_Callback";

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) {
    return _createSVGPathSegCurvetoQuadraticSmoothRel(x, y);
  }

  SVGPathSegCurvetoQuadraticSmoothRel _createSVGPathSegCurvetoQuadraticSmoothRel(x, y) native "SVGPathElement_createSVGPathSegCurvetoQuadraticSmoothRel_Callback";

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y) {
    return _createSVGPathSegLinetoAbs(x, y);
  }

  SVGPathSegLinetoAbs _createSVGPathSegLinetoAbs(x, y) native "SVGPathElement_createSVGPathSegLinetoAbs_Callback";

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x) {
    return _createSVGPathSegLinetoHorizontalAbs(x);
  }

  SVGPathSegLinetoHorizontalAbs _createSVGPathSegLinetoHorizontalAbs(x) native "SVGPathElement_createSVGPathSegLinetoHorizontalAbs_Callback";

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x) {
    return _createSVGPathSegLinetoHorizontalRel(x);
  }

  SVGPathSegLinetoHorizontalRel _createSVGPathSegLinetoHorizontalRel(x) native "SVGPathElement_createSVGPathSegLinetoHorizontalRel_Callback";

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y) {
    return _createSVGPathSegLinetoRel(x, y);
  }

  SVGPathSegLinetoRel _createSVGPathSegLinetoRel(x, y) native "SVGPathElement_createSVGPathSegLinetoRel_Callback";

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y) {
    return _createSVGPathSegLinetoVerticalAbs(y);
  }

  SVGPathSegLinetoVerticalAbs _createSVGPathSegLinetoVerticalAbs(y) native "SVGPathElement_createSVGPathSegLinetoVerticalAbs_Callback";

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y) {
    return _createSVGPathSegLinetoVerticalRel(y);
  }

  SVGPathSegLinetoVerticalRel _createSVGPathSegLinetoVerticalRel(y) native "SVGPathElement_createSVGPathSegLinetoVerticalRel_Callback";

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y) {
    return _createSVGPathSegMovetoAbs(x, y);
  }

  SVGPathSegMovetoAbs _createSVGPathSegMovetoAbs(x, y) native "SVGPathElement_createSVGPathSegMovetoAbs_Callback";

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y) {
    return _createSVGPathSegMovetoRel(x, y);
  }

  SVGPathSegMovetoRel _createSVGPathSegMovetoRel(x, y) native "SVGPathElement_createSVGPathSegMovetoRel_Callback";

  int getPathSegAtLength(num distance) {
    return _getPathSegAtLength(distance);
  }

  int _getPathSegAtLength(distance) native "SVGPathElement_getPathSegAtLength_Callback";

  SVGPoint getPointAtLength(num distance) {
    return _getPointAtLength(distance);
  }

  SVGPoint _getPointAtLength(distance) native "SVGPathElement_getPointAtLength_Callback";

  num getTotalLength() {
    return _getTotalLength();
  }

  num _getTotalLength() native "SVGPathElement_getTotalLength_Callback";

  SVGStringList get requiredExtensions() native "SVGPathElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGPathElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGPathElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGPathElement_hasExtension_Callback";

  String get xmllang() native "SVGPathElement_xmllang_Getter";

  void set xmllang(String) native "SVGPathElement_xmllang_Setter";

  String get xmlspace() native "SVGPathElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGPathElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGPathElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGPathElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGPathElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGPathElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGPathElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGPathElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGPathElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGPathElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGPathElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGPathElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGPathElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegArcAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegArcAbs {
  _SVGPathSegArcAbsDOMImpl();
  String get typeName() => "SVGPathSegArcAbs";

  num get angle() native "SVGPathSegArcAbs_angle_Getter";

  void set angle(num) native "SVGPathSegArcAbs_angle_Setter";

  bool get largeArcFlag() native "SVGPathSegArcAbs_largeArcFlag_Getter";

  void set largeArcFlag(bool) native "SVGPathSegArcAbs_largeArcFlag_Setter";

  num get r1() native "SVGPathSegArcAbs_r1_Getter";

  void set r1(num) native "SVGPathSegArcAbs_r1_Setter";

  num get r2() native "SVGPathSegArcAbs_r2_Getter";

  void set r2(num) native "SVGPathSegArcAbs_r2_Setter";

  bool get sweepFlag() native "SVGPathSegArcAbs_sweepFlag_Getter";

  void set sweepFlag(bool) native "SVGPathSegArcAbs_sweepFlag_Setter";

  num get x() native "SVGPathSegArcAbs_x_Getter";

  void set x(num) native "SVGPathSegArcAbs_x_Setter";

  num get y() native "SVGPathSegArcAbs_y_Getter";

  void set y(num) native "SVGPathSegArcAbs_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegArcRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegArcRel {
  _SVGPathSegArcRelDOMImpl();
  String get typeName() => "SVGPathSegArcRel";

  num get angle() native "SVGPathSegArcRel_angle_Getter";

  void set angle(num) native "SVGPathSegArcRel_angle_Setter";

  bool get largeArcFlag() native "SVGPathSegArcRel_largeArcFlag_Getter";

  void set largeArcFlag(bool) native "SVGPathSegArcRel_largeArcFlag_Setter";

  num get r1() native "SVGPathSegArcRel_r1_Getter";

  void set r1(num) native "SVGPathSegArcRel_r1_Setter";

  num get r2() native "SVGPathSegArcRel_r2_Getter";

  void set r2(num) native "SVGPathSegArcRel_r2_Setter";

  bool get sweepFlag() native "SVGPathSegArcRel_sweepFlag_Getter";

  void set sweepFlag(bool) native "SVGPathSegArcRel_sweepFlag_Setter";

  num get x() native "SVGPathSegArcRel_x_Getter";

  void set x(num) native "SVGPathSegArcRel_x_Setter";

  num get y() native "SVGPathSegArcRel_y_Getter";

  void set y(num) native "SVGPathSegArcRel_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegClosePathDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegClosePath {
  _SVGPathSegClosePathDOMImpl();
  String get typeName() => "SVGPathSegClosePath";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoCubicAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoCubicAbs {
  _SVGPathSegCurvetoCubicAbsDOMImpl();
  String get typeName() => "SVGPathSegCurvetoCubicAbs";

  num get x() native "SVGPathSegCurvetoCubicAbs_x_Getter";

  void set x(num) native "SVGPathSegCurvetoCubicAbs_x_Setter";

  num get x1() native "SVGPathSegCurvetoCubicAbs_x1_Getter";

  void set x1(num) native "SVGPathSegCurvetoCubicAbs_x1_Setter";

  num get x2() native "SVGPathSegCurvetoCubicAbs_x2_Getter";

  void set x2(num) native "SVGPathSegCurvetoCubicAbs_x2_Setter";

  num get y() native "SVGPathSegCurvetoCubicAbs_y_Getter";

  void set y(num) native "SVGPathSegCurvetoCubicAbs_y_Setter";

  num get y1() native "SVGPathSegCurvetoCubicAbs_y1_Getter";

  void set y1(num) native "SVGPathSegCurvetoCubicAbs_y1_Setter";

  num get y2() native "SVGPathSegCurvetoCubicAbs_y2_Getter";

  void set y2(num) native "SVGPathSegCurvetoCubicAbs_y2_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoCubicRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoCubicRel {
  _SVGPathSegCurvetoCubicRelDOMImpl();
  String get typeName() => "SVGPathSegCurvetoCubicRel";

  num get x() native "SVGPathSegCurvetoCubicRel_x_Getter";

  void set x(num) native "SVGPathSegCurvetoCubicRel_x_Setter";

  num get x1() native "SVGPathSegCurvetoCubicRel_x1_Getter";

  void set x1(num) native "SVGPathSegCurvetoCubicRel_x1_Setter";

  num get x2() native "SVGPathSegCurvetoCubicRel_x2_Getter";

  void set x2(num) native "SVGPathSegCurvetoCubicRel_x2_Setter";

  num get y() native "SVGPathSegCurvetoCubicRel_y_Getter";

  void set y(num) native "SVGPathSegCurvetoCubicRel_y_Setter";

  num get y1() native "SVGPathSegCurvetoCubicRel_y1_Getter";

  void set y1(num) native "SVGPathSegCurvetoCubicRel_y1_Setter";

  num get y2() native "SVGPathSegCurvetoCubicRel_y2_Getter";

  void set y2(num) native "SVGPathSegCurvetoCubicRel_y2_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoCubicSmoothAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoCubicSmoothAbs {
  _SVGPathSegCurvetoCubicSmoothAbsDOMImpl();
  String get typeName() => "SVGPathSegCurvetoCubicSmoothAbs";

  num get x() native "SVGPathSegCurvetoCubicSmoothAbs_x_Getter";

  void set x(num) native "SVGPathSegCurvetoCubicSmoothAbs_x_Setter";

  num get x2() native "SVGPathSegCurvetoCubicSmoothAbs_x2_Getter";

  void set x2(num) native "SVGPathSegCurvetoCubicSmoothAbs_x2_Setter";

  num get y() native "SVGPathSegCurvetoCubicSmoothAbs_y_Getter";

  void set y(num) native "SVGPathSegCurvetoCubicSmoothAbs_y_Setter";

  num get y2() native "SVGPathSegCurvetoCubicSmoothAbs_y2_Getter";

  void set y2(num) native "SVGPathSegCurvetoCubicSmoothAbs_y2_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoCubicSmoothRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoCubicSmoothRel {
  _SVGPathSegCurvetoCubicSmoothRelDOMImpl();
  String get typeName() => "SVGPathSegCurvetoCubicSmoothRel";

  num get x() native "SVGPathSegCurvetoCubicSmoothRel_x_Getter";

  void set x(num) native "SVGPathSegCurvetoCubicSmoothRel_x_Setter";

  num get x2() native "SVGPathSegCurvetoCubicSmoothRel_x2_Getter";

  void set x2(num) native "SVGPathSegCurvetoCubicSmoothRel_x2_Setter";

  num get y() native "SVGPathSegCurvetoCubicSmoothRel_y_Getter";

  void set y(num) native "SVGPathSegCurvetoCubicSmoothRel_y_Setter";

  num get y2() native "SVGPathSegCurvetoCubicSmoothRel_y2_Getter";

  void set y2(num) native "SVGPathSegCurvetoCubicSmoothRel_y2_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoQuadraticAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoQuadraticAbs {
  _SVGPathSegCurvetoQuadraticAbsDOMImpl();
  String get typeName() => "SVGPathSegCurvetoQuadraticAbs";

  num get x() native "SVGPathSegCurvetoQuadraticAbs_x_Getter";

  void set x(num) native "SVGPathSegCurvetoQuadraticAbs_x_Setter";

  num get x1() native "SVGPathSegCurvetoQuadraticAbs_x1_Getter";

  void set x1(num) native "SVGPathSegCurvetoQuadraticAbs_x1_Setter";

  num get y() native "SVGPathSegCurvetoQuadraticAbs_y_Getter";

  void set y(num) native "SVGPathSegCurvetoQuadraticAbs_y_Setter";

  num get y1() native "SVGPathSegCurvetoQuadraticAbs_y1_Getter";

  void set y1(num) native "SVGPathSegCurvetoQuadraticAbs_y1_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoQuadraticRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoQuadraticRel {
  _SVGPathSegCurvetoQuadraticRelDOMImpl();
  String get typeName() => "SVGPathSegCurvetoQuadraticRel";

  num get x() native "SVGPathSegCurvetoQuadraticRel_x_Getter";

  void set x(num) native "SVGPathSegCurvetoQuadraticRel_x_Setter";

  num get x1() native "SVGPathSegCurvetoQuadraticRel_x1_Getter";

  void set x1(num) native "SVGPathSegCurvetoQuadraticRel_x1_Setter";

  num get y() native "SVGPathSegCurvetoQuadraticRel_y_Getter";

  void set y(num) native "SVGPathSegCurvetoQuadraticRel_y_Setter";

  num get y1() native "SVGPathSegCurvetoQuadraticRel_y1_Getter";

  void set y1(num) native "SVGPathSegCurvetoQuadraticRel_y1_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoQuadraticSmoothAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoQuadraticSmoothAbs {
  _SVGPathSegCurvetoQuadraticSmoothAbsDOMImpl();
  String get typeName() => "SVGPathSegCurvetoQuadraticSmoothAbs";

  num get x() native "SVGPathSegCurvetoQuadraticSmoothAbs_x_Getter";

  void set x(num) native "SVGPathSegCurvetoQuadraticSmoothAbs_x_Setter";

  num get y() native "SVGPathSegCurvetoQuadraticSmoothAbs_y_Getter";

  void set y(num) native "SVGPathSegCurvetoQuadraticSmoothAbs_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegCurvetoQuadraticSmoothRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegCurvetoQuadraticSmoothRel {
  _SVGPathSegCurvetoQuadraticSmoothRelDOMImpl();
  String get typeName() => "SVGPathSegCurvetoQuadraticSmoothRel";

  num get x() native "SVGPathSegCurvetoQuadraticSmoothRel_x_Getter";

  void set x(num) native "SVGPathSegCurvetoQuadraticSmoothRel_x_Setter";

  num get y() native "SVGPathSegCurvetoQuadraticSmoothRel_y_Getter";

  void set y(num) native "SVGPathSegCurvetoQuadraticSmoothRel_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegDOMImpl extends _DOMWrapperBase implements SVGPathSeg {
  _SVGPathSegDOMImpl();
  String get typeName() => "SVGPathSeg";

  int get pathSegType() native "SVGPathSeg_pathSegType_Getter";

  String get pathSegTypeAsLetter() native "SVGPathSeg_pathSegTypeAsLetter_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegLinetoAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegLinetoAbs {
  _SVGPathSegLinetoAbsDOMImpl();
  String get typeName() => "SVGPathSegLinetoAbs";

  num get x() native "SVGPathSegLinetoAbs_x_Getter";

  void set x(num) native "SVGPathSegLinetoAbs_x_Setter";

  num get y() native "SVGPathSegLinetoAbs_y_Getter";

  void set y(num) native "SVGPathSegLinetoAbs_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegLinetoHorizontalAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegLinetoHorizontalAbs {
  _SVGPathSegLinetoHorizontalAbsDOMImpl();
  String get typeName() => "SVGPathSegLinetoHorizontalAbs";

  num get x() native "SVGPathSegLinetoHorizontalAbs_x_Getter";

  void set x(num) native "SVGPathSegLinetoHorizontalAbs_x_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegLinetoHorizontalRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegLinetoHorizontalRel {
  _SVGPathSegLinetoHorizontalRelDOMImpl();
  String get typeName() => "SVGPathSegLinetoHorizontalRel";

  num get x() native "SVGPathSegLinetoHorizontalRel_x_Getter";

  void set x(num) native "SVGPathSegLinetoHorizontalRel_x_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegLinetoRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegLinetoRel {
  _SVGPathSegLinetoRelDOMImpl();
  String get typeName() => "SVGPathSegLinetoRel";

  num get x() native "SVGPathSegLinetoRel_x_Getter";

  void set x(num) native "SVGPathSegLinetoRel_x_Setter";

  num get y() native "SVGPathSegLinetoRel_y_Getter";

  void set y(num) native "SVGPathSegLinetoRel_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegLinetoVerticalAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegLinetoVerticalAbs {
  _SVGPathSegLinetoVerticalAbsDOMImpl();
  String get typeName() => "SVGPathSegLinetoVerticalAbs";

  num get y() native "SVGPathSegLinetoVerticalAbs_y_Getter";

  void set y(num) native "SVGPathSegLinetoVerticalAbs_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegLinetoVerticalRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegLinetoVerticalRel {
  _SVGPathSegLinetoVerticalRelDOMImpl();
  String get typeName() => "SVGPathSegLinetoVerticalRel";

  num get y() native "SVGPathSegLinetoVerticalRel_y_Getter";

  void set y(num) native "SVGPathSegLinetoVerticalRel_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegListDOMImpl extends _DOMWrapperBase implements SVGPathSegList {
  _SVGPathSegListDOMImpl();
  String get typeName() => "SVGPathSegList";

  int get numberOfItems() native "SVGPathSegList_numberOfItems_Getter";

  SVGPathSeg appendItem(SVGPathSeg newItem) {
    return _appendItem(newItem);
  }

  SVGPathSeg _appendItem(newItem) native "SVGPathSegList_appendItem_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "SVGPathSegList_clear_Callback";

  SVGPathSeg getItem(int index) {
    return _getItem(index);
  }

  SVGPathSeg _getItem(index) native "SVGPathSegList_getItem_Callback";

  SVGPathSeg initialize(SVGPathSeg newItem) {
    return _initialize(newItem);
  }

  SVGPathSeg _initialize(newItem) native "SVGPathSegList_initialize_Callback";

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index) {
    return _insertItemBefore(newItem, index);
  }

  SVGPathSeg _insertItemBefore(newItem, index) native "SVGPathSegList_insertItemBefore_Callback";

  SVGPathSeg removeItem(int index) {
    return _removeItem(index);
  }

  SVGPathSeg _removeItem(index) native "SVGPathSegList_removeItem_Callback";

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index) {
    return _replaceItem(newItem, index);
  }

  SVGPathSeg _replaceItem(newItem, index) native "SVGPathSegList_replaceItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegMovetoAbsDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegMovetoAbs {
  _SVGPathSegMovetoAbsDOMImpl();
  String get typeName() => "SVGPathSegMovetoAbs";

  num get x() native "SVGPathSegMovetoAbs_x_Getter";

  void set x(num) native "SVGPathSegMovetoAbs_x_Setter";

  num get y() native "SVGPathSegMovetoAbs_y_Getter";

  void set y(num) native "SVGPathSegMovetoAbs_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPathSegMovetoRelDOMImpl extends _SVGPathSegDOMImpl implements SVGPathSegMovetoRel {
  _SVGPathSegMovetoRelDOMImpl();
  String get typeName() => "SVGPathSegMovetoRel";

  num get x() native "SVGPathSegMovetoRel_x_Getter";

  void set x(num) native "SVGPathSegMovetoRel_x_Setter";

  num get y() native "SVGPathSegMovetoRel_y_Getter";

  void set y(num) native "SVGPathSegMovetoRel_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPatternElementDOMImpl extends _SVGElementDOMImpl implements SVGPatternElement {
  _SVGPatternElementDOMImpl();
  String get typeName() => "SVGPatternElement";

  SVGAnimatedLength get height() native "SVGPatternElement_height_Getter";

  SVGAnimatedEnumeration get patternContentUnits() native "SVGPatternElement_patternContentUnits_Getter";

  SVGAnimatedTransformList get patternTransform() native "SVGPatternElement_patternTransform_Getter";

  SVGAnimatedEnumeration get patternUnits() native "SVGPatternElement_patternUnits_Getter";

  SVGAnimatedLength get width() native "SVGPatternElement_width_Getter";

  SVGAnimatedLength get x() native "SVGPatternElement_x_Getter";

  SVGAnimatedLength get y() native "SVGPatternElement_y_Getter";

  SVGAnimatedString get href() native "SVGPatternElement_href_Getter";

  SVGStringList get requiredExtensions() native "SVGPatternElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGPatternElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGPatternElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGPatternElement_hasExtension_Callback";

  String get xmllang() native "SVGPatternElement_xmllang_Getter";

  void set xmllang(String) native "SVGPatternElement_xmllang_Setter";

  String get xmlspace() native "SVGPatternElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGPatternElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGPatternElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGPatternElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGPatternElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGPatternElement_getPresentationAttribute_Callback";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGPatternElement_preserveAspectRatio_Getter";

  SVGAnimatedRect get viewBox() native "SVGPatternElement_viewBox_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPointDOMImpl extends _DOMWrapperBase implements SVGPoint {
  _SVGPointDOMImpl();
  String get typeName() => "SVGPoint";

  num get x() native "SVGPoint_x_Getter";

  void set x(num) native "SVGPoint_x_Setter";

  num get y() native "SVGPoint_y_Getter";

  void set y(num) native "SVGPoint_y_Setter";

  SVGPoint matrixTransform(SVGMatrix matrix) {
    return _matrixTransform(matrix);
  }

  SVGPoint _matrixTransform(matrix) native "SVGPoint_matrixTransform_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPointListDOMImpl extends _DOMWrapperBase implements SVGPointList {
  _SVGPointListDOMImpl();
  String get typeName() => "SVGPointList";

  int get numberOfItems() native "SVGPointList_numberOfItems_Getter";

  SVGPoint appendItem(SVGPoint item) {
    return _appendItem(item);
  }

  SVGPoint _appendItem(item) native "SVGPointList_appendItem_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "SVGPointList_clear_Callback";

  SVGPoint getItem(int index) {
    return _getItem(index);
  }

  SVGPoint _getItem(index) native "SVGPointList_getItem_Callback";

  SVGPoint initialize(SVGPoint item) {
    return _initialize(item);
  }

  SVGPoint _initialize(item) native "SVGPointList_initialize_Callback";

  SVGPoint insertItemBefore(SVGPoint item, int index) {
    return _insertItemBefore(item, index);
  }

  SVGPoint _insertItemBefore(item, index) native "SVGPointList_insertItemBefore_Callback";

  SVGPoint removeItem(int index) {
    return _removeItem(index);
  }

  SVGPoint _removeItem(index) native "SVGPointList_removeItem_Callback";

  SVGPoint replaceItem(SVGPoint item, int index) {
    return _replaceItem(item, index);
  }

  SVGPoint _replaceItem(item, index) native "SVGPointList_replaceItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPolygonElementDOMImpl extends _SVGElementDOMImpl implements SVGPolygonElement {
  _SVGPolygonElementDOMImpl();
  String get typeName() => "SVGPolygonElement";

  SVGPointList get animatedPoints() native "SVGPolygonElement_animatedPoints_Getter";

  SVGPointList get points() native "SVGPolygonElement_points_Getter";

  SVGStringList get requiredExtensions() native "SVGPolygonElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGPolygonElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGPolygonElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGPolygonElement_hasExtension_Callback";

  String get xmllang() native "SVGPolygonElement_xmllang_Getter";

  void set xmllang(String) native "SVGPolygonElement_xmllang_Setter";

  String get xmlspace() native "SVGPolygonElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGPolygonElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGPolygonElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGPolygonElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGPolygonElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGPolygonElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGPolygonElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGPolygonElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGPolygonElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGPolygonElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGPolygonElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGPolygonElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGPolygonElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPolylineElementDOMImpl extends _SVGElementDOMImpl implements SVGPolylineElement {
  _SVGPolylineElementDOMImpl();
  String get typeName() => "SVGPolylineElement";

  SVGPointList get animatedPoints() native "SVGPolylineElement_animatedPoints_Getter";

  SVGPointList get points() native "SVGPolylineElement_points_Getter";

  SVGStringList get requiredExtensions() native "SVGPolylineElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGPolylineElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGPolylineElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGPolylineElement_hasExtension_Callback";

  String get xmllang() native "SVGPolylineElement_xmllang_Getter";

  void set xmllang(String) native "SVGPolylineElement_xmllang_Setter";

  String get xmlspace() native "SVGPolylineElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGPolylineElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGPolylineElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGPolylineElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGPolylineElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGPolylineElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGPolylineElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGPolylineElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGPolylineElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGPolylineElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGPolylineElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGPolylineElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGPolylineElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGPreserveAspectRatioDOMImpl extends _DOMWrapperBase implements SVGPreserveAspectRatio {
  _SVGPreserveAspectRatioDOMImpl();
  String get typeName() => "SVGPreserveAspectRatio";

  int get align() native "SVGPreserveAspectRatio_align_Getter";

  void set align(int) native "SVGPreserveAspectRatio_align_Setter";

  int get meetOrSlice() native "SVGPreserveAspectRatio_meetOrSlice_Getter";

  void set meetOrSlice(int) native "SVGPreserveAspectRatio_meetOrSlice_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGRadialGradientElementDOMImpl extends _SVGGradientElementDOMImpl implements SVGRadialGradientElement {
  _SVGRadialGradientElementDOMImpl();
  String get typeName() => "SVGRadialGradientElement";

  SVGAnimatedLength get cx() native "SVGRadialGradientElement_cx_Getter";

  SVGAnimatedLength get cy() native "SVGRadialGradientElement_cy_Getter";

  SVGAnimatedLength get fx() native "SVGRadialGradientElement_fx_Getter";

  SVGAnimatedLength get fy() native "SVGRadialGradientElement_fy_Getter";

  SVGAnimatedLength get r() native "SVGRadialGradientElement_r_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGRectElementDOMImpl extends _SVGElementDOMImpl implements SVGRectElement {
  _SVGRectElementDOMImpl();
  String get typeName() => "SVGRectElement";

  SVGAnimatedLength get height() native "SVGRectElement_height_Getter";

  SVGAnimatedLength get rx() native "SVGRectElement_rx_Getter";

  SVGAnimatedLength get ry() native "SVGRectElement_ry_Getter";

  SVGAnimatedLength get width() native "SVGRectElement_width_Getter";

  SVGAnimatedLength get x() native "SVGRectElement_x_Getter";

  SVGAnimatedLength get y() native "SVGRectElement_y_Getter";

  SVGStringList get requiredExtensions() native "SVGRectElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGRectElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGRectElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGRectElement_hasExtension_Callback";

  String get xmllang() native "SVGRectElement_xmllang_Getter";

  void set xmllang(String) native "SVGRectElement_xmllang_Setter";

  String get xmlspace() native "SVGRectElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGRectElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGRectElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGRectElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGRectElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGRectElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGRectElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGRectElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGRectElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGRectElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGRectElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGRectElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGRectElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGRectDOMImpl extends _DOMWrapperBase implements SVGRect {
  _SVGRectDOMImpl();
  String get typeName() => "SVGRect";

  num get height() native "SVGRect_height_Getter";

  void set height(num) native "SVGRect_height_Setter";

  num get width() native "SVGRect_width_Getter";

  void set width(num) native "SVGRect_width_Setter";

  num get x() native "SVGRect_x_Getter";

  void set x(num) native "SVGRect_x_Setter";

  num get y() native "SVGRect_y_Getter";

  void set y(num) native "SVGRect_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGRenderingIntentDOMImpl extends _DOMWrapperBase implements SVGRenderingIntent {
  _SVGRenderingIntentDOMImpl();
  String get typeName() => "SVGRenderingIntent";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGSVGElementDOMImpl extends _SVGElementDOMImpl implements SVGSVGElement {
  _SVGSVGElementDOMImpl();
  String get typeName() => "SVGSVGElement";

  String get contentScriptType() native "SVGSVGElement_contentScriptType_Getter";

  void set contentScriptType(String) native "SVGSVGElement_contentScriptType_Setter";

  String get contentStyleType() native "SVGSVGElement_contentStyleType_Getter";

  void set contentStyleType(String) native "SVGSVGElement_contentStyleType_Setter";

  num get currentScale() native "SVGSVGElement_currentScale_Getter";

  void set currentScale(num) native "SVGSVGElement_currentScale_Setter";

  SVGPoint get currentTranslate() native "SVGSVGElement_currentTranslate_Getter";

  SVGAnimatedLength get height() native "SVGSVGElement_height_Getter";

  num get pixelUnitToMillimeterX() native "SVGSVGElement_pixelUnitToMillimeterX_Getter";

  num get pixelUnitToMillimeterY() native "SVGSVGElement_pixelUnitToMillimeterY_Getter";

  num get screenPixelToMillimeterX() native "SVGSVGElement_screenPixelToMillimeterX_Getter";

  num get screenPixelToMillimeterY() native "SVGSVGElement_screenPixelToMillimeterY_Getter";

  bool get useCurrentView() native "SVGSVGElement_useCurrentView_Getter";

  void set useCurrentView(bool) native "SVGSVGElement_useCurrentView_Setter";

  SVGRect get viewport() native "SVGSVGElement_viewport_Getter";

  SVGAnimatedLength get width() native "SVGSVGElement_width_Getter";

  SVGAnimatedLength get x() native "SVGSVGElement_x_Getter";

  SVGAnimatedLength get y() native "SVGSVGElement_y_Getter";

  bool animationsPaused() {
    return _animationsPaused();
  }

  bool _animationsPaused() native "SVGSVGElement_animationsPaused_Callback";

  bool checkEnclosure(SVGElement element, SVGRect rect) {
    return _checkEnclosure(element, rect);
  }

  bool _checkEnclosure(element, rect) native "SVGSVGElement_checkEnclosure_Callback";

  bool checkIntersection(SVGElement element, SVGRect rect) {
    return _checkIntersection(element, rect);
  }

  bool _checkIntersection(element, rect) native "SVGSVGElement_checkIntersection_Callback";

  SVGAngle createSVGAngle() {
    return _createSVGAngle();
  }

  SVGAngle _createSVGAngle() native "SVGSVGElement_createSVGAngle_Callback";

  SVGLength createSVGLength() {
    return _createSVGLength();
  }

  SVGLength _createSVGLength() native "SVGSVGElement_createSVGLength_Callback";

  SVGMatrix createSVGMatrix() {
    return _createSVGMatrix();
  }

  SVGMatrix _createSVGMatrix() native "SVGSVGElement_createSVGMatrix_Callback";

  SVGNumber createSVGNumber() {
    return _createSVGNumber();
  }

  SVGNumber _createSVGNumber() native "SVGSVGElement_createSVGNumber_Callback";

  SVGPoint createSVGPoint() {
    return _createSVGPoint();
  }

  SVGPoint _createSVGPoint() native "SVGSVGElement_createSVGPoint_Callback";

  SVGRect createSVGRect() {
    return _createSVGRect();
  }

  SVGRect _createSVGRect() native "SVGSVGElement_createSVGRect_Callback";

  SVGTransform createSVGTransform() {
    return _createSVGTransform();
  }

  SVGTransform _createSVGTransform() native "SVGSVGElement_createSVGTransform_Callback";

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return _createSVGTransformFromMatrix(matrix);
  }

  SVGTransform _createSVGTransformFromMatrix(matrix) native "SVGSVGElement_createSVGTransformFromMatrix_Callback";

  void deselectAll() {
    _deselectAll();
    return;
  }

  void _deselectAll() native "SVGSVGElement_deselectAll_Callback";

  void forceRedraw() {
    _forceRedraw();
    return;
  }

  void _forceRedraw() native "SVGSVGElement_forceRedraw_Callback";

  num getCurrentTime() {
    return _getCurrentTime();
  }

  num _getCurrentTime() native "SVGSVGElement_getCurrentTime_Callback";

  Element getElementById(String elementId) {
    return _getElementById(elementId);
  }

  Element _getElementById(elementId) native "SVGSVGElement_getElementById_Callback";

  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement) {
    return _getEnclosureList(rect, referenceElement);
  }

  NodeList _getEnclosureList(rect, referenceElement) native "SVGSVGElement_getEnclosureList_Callback";

  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement) {
    return _getIntersectionList(rect, referenceElement);
  }

  NodeList _getIntersectionList(rect, referenceElement) native "SVGSVGElement_getIntersectionList_Callback";

  void pauseAnimations() {
    _pauseAnimations();
    return;
  }

  void _pauseAnimations() native "SVGSVGElement_pauseAnimations_Callback";

  void setCurrentTime(num seconds) {
    _setCurrentTime(seconds);
    return;
  }

  void _setCurrentTime(seconds) native "SVGSVGElement_setCurrentTime_Callback";

  int suspendRedraw(int maxWaitMilliseconds) {
    return _suspendRedraw(maxWaitMilliseconds);
  }

  int _suspendRedraw(maxWaitMilliseconds) native "SVGSVGElement_suspendRedraw_Callback";

  void unpauseAnimations() {
    _unpauseAnimations();
    return;
  }

  void _unpauseAnimations() native "SVGSVGElement_unpauseAnimations_Callback";

  void unsuspendRedraw(int suspendHandleId) {
    _unsuspendRedraw(suspendHandleId);
    return;
  }

  void _unsuspendRedraw(suspendHandleId) native "SVGSVGElement_unsuspendRedraw_Callback";

  void unsuspendRedrawAll() {
    _unsuspendRedrawAll();
    return;
  }

  void _unsuspendRedrawAll() native "SVGSVGElement_unsuspendRedrawAll_Callback";

  SVGStringList get requiredExtensions() native "SVGSVGElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGSVGElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGSVGElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGSVGElement_hasExtension_Callback";

  String get xmllang() native "SVGSVGElement_xmllang_Getter";

  void set xmllang(String) native "SVGSVGElement_xmllang_Setter";

  String get xmlspace() native "SVGSVGElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGSVGElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGSVGElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGSVGElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGSVGElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGSVGElement_getPresentationAttribute_Callback";

  SVGElement get farthestViewportElement() native "SVGSVGElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGSVGElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGSVGElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGSVGElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGSVGElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGSVGElement_getTransformToElement_Callback";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGSVGElement_preserveAspectRatio_Getter";

  SVGAnimatedRect get viewBox() native "SVGSVGElement_viewBox_Getter";

  int get zoomAndPan() native "SVGSVGElement_zoomAndPan_Getter";

  void set zoomAndPan(int) native "SVGSVGElement_zoomAndPan_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGScriptElementDOMImpl extends _SVGElementDOMImpl implements SVGScriptElement {
  _SVGScriptElementDOMImpl();
  String get typeName() => "SVGScriptElement";

  String get type() native "SVGScriptElement_type_Getter";

  void set type(String) native "SVGScriptElement_type_Setter";

  SVGAnimatedString get href() native "SVGScriptElement_href_Getter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGScriptElement_externalResourcesRequired_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGSetElementDOMImpl extends _SVGAnimationElementDOMImpl implements SVGSetElement {
  _SVGSetElementDOMImpl();
  String get typeName() => "SVGSetElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGStopElementDOMImpl extends _SVGElementDOMImpl implements SVGStopElement {
  _SVGStopElementDOMImpl();
  String get typeName() => "SVGStopElement";

  SVGAnimatedNumber get offset() native "SVGStopElement_offset_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGStopElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGStopElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGStopElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGStringListDOMImpl extends _DOMWrapperBase implements SVGStringList {
  _SVGStringListDOMImpl();
  String get typeName() => "SVGStringList";

  int get numberOfItems() native "SVGStringList_numberOfItems_Getter";

  String appendItem(String item) {
    return _appendItem(item);
  }

  String _appendItem(item) native "SVGStringList_appendItem_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "SVGStringList_clear_Callback";

  String getItem(int index) {
    return _getItem(index);
  }

  String _getItem(index) native "SVGStringList_getItem_Callback";

  String initialize(String item) {
    return _initialize(item);
  }

  String _initialize(item) native "SVGStringList_initialize_Callback";

  String insertItemBefore(String item, int index) {
    return _insertItemBefore(item, index);
  }

  String _insertItemBefore(item, index) native "SVGStringList_insertItemBefore_Callback";

  String removeItem(int index) {
    return _removeItem(index);
  }

  String _removeItem(index) native "SVGStringList_removeItem_Callback";

  String replaceItem(String item, int index) {
    return _replaceItem(item, index);
  }

  String _replaceItem(item, index) native "SVGStringList_replaceItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGStyleElementDOMImpl extends _SVGElementDOMImpl implements SVGStyleElement {
  _SVGStyleElementDOMImpl();
  String get typeName() => "SVGStyleElement";

  bool get disabled() native "SVGStyleElement_disabled_Getter";

  void set disabled(bool) native "SVGStyleElement_disabled_Setter";

  String get media() native "SVGStyleElement_media_Getter";

  void set media(String) native "SVGStyleElement_media_Setter";

  String get title() native "SVGStyleElement_title_Getter";

  void set title(String) native "SVGStyleElement_title_Setter";

  String get type() native "SVGStyleElement_type_Getter";

  void set type(String) native "SVGStyleElement_type_Setter";

  String get xmllang() native "SVGStyleElement_xmllang_Getter";

  void set xmllang(String) native "SVGStyleElement_xmllang_Setter";

  String get xmlspace() native "SVGStyleElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGStyleElement_xmlspace_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGSwitchElementDOMImpl extends _SVGElementDOMImpl implements SVGSwitchElement {
  _SVGSwitchElementDOMImpl();
  String get typeName() => "SVGSwitchElement";

  SVGStringList get requiredExtensions() native "SVGSwitchElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGSwitchElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGSwitchElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGSwitchElement_hasExtension_Callback";

  String get xmllang() native "SVGSwitchElement_xmllang_Getter";

  void set xmllang(String) native "SVGSwitchElement_xmllang_Setter";

  String get xmlspace() native "SVGSwitchElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGSwitchElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGSwitchElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGSwitchElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGSwitchElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGSwitchElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGSwitchElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGSwitchElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGSwitchElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGSwitchElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGSwitchElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGSwitchElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGSwitchElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGSymbolElementDOMImpl extends _SVGElementDOMImpl implements SVGSymbolElement {
  _SVGSymbolElementDOMImpl();
  String get typeName() => "SVGSymbolElement";

  String get xmllang() native "SVGSymbolElement_xmllang_Getter";

  void set xmllang(String) native "SVGSymbolElement_xmllang_Setter";

  String get xmlspace() native "SVGSymbolElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGSymbolElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGSymbolElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGSymbolElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGSymbolElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGSymbolElement_getPresentationAttribute_Callback";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGSymbolElement_preserveAspectRatio_Getter";

  SVGAnimatedRect get viewBox() native "SVGSymbolElement_viewBox_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTRefElementDOMImpl extends _SVGTextPositioningElementDOMImpl implements SVGTRefElement {
  _SVGTRefElementDOMImpl();
  String get typeName() => "SVGTRefElement";

  SVGAnimatedString get href() native "SVGTRefElement_href_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTSpanElementDOMImpl extends _SVGTextPositioningElementDOMImpl implements SVGTSpanElement {
  _SVGTSpanElementDOMImpl();
  String get typeName() => "SVGTSpanElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTextContentElementDOMImpl extends _SVGElementDOMImpl implements SVGTextContentElement {
  _SVGTextContentElementDOMImpl();
  String get typeName() => "SVGTextContentElement";

  SVGAnimatedEnumeration get lengthAdjust() native "SVGTextContentElement_lengthAdjust_Getter";

  SVGAnimatedLength get textLength() native "SVGTextContentElement_textLength_Getter";

  int getCharNumAtPosition(SVGPoint point) {
    return _getCharNumAtPosition(point);
  }

  int _getCharNumAtPosition(point) native "SVGTextContentElement_getCharNumAtPosition_Callback";

  num getComputedTextLength() {
    return _getComputedTextLength();
  }

  num _getComputedTextLength() native "SVGTextContentElement_getComputedTextLength_Callback";

  SVGPoint getEndPositionOfChar(int offset) {
    return _getEndPositionOfChar(offset);
  }

  SVGPoint _getEndPositionOfChar(offset) native "SVGTextContentElement_getEndPositionOfChar_Callback";

  SVGRect getExtentOfChar(int offset) {
    return _getExtentOfChar(offset);
  }

  SVGRect _getExtentOfChar(offset) native "SVGTextContentElement_getExtentOfChar_Callback";

  int getNumberOfChars() {
    return _getNumberOfChars();
  }

  int _getNumberOfChars() native "SVGTextContentElement_getNumberOfChars_Callback";

  num getRotationOfChar(int offset) {
    return _getRotationOfChar(offset);
  }

  num _getRotationOfChar(offset) native "SVGTextContentElement_getRotationOfChar_Callback";

  SVGPoint getStartPositionOfChar(int offset) {
    return _getStartPositionOfChar(offset);
  }

  SVGPoint _getStartPositionOfChar(offset) native "SVGTextContentElement_getStartPositionOfChar_Callback";

  num getSubStringLength(int offset, int length) {
    return _getSubStringLength(offset, length);
  }

  num _getSubStringLength(offset, length) native "SVGTextContentElement_getSubStringLength_Callback";

  void selectSubString(int offset, int length) {
    _selectSubString(offset, length);
    return;
  }

  void _selectSubString(offset, length) native "SVGTextContentElement_selectSubString_Callback";

  SVGStringList get requiredExtensions() native "SVGTextContentElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGTextContentElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGTextContentElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGTextContentElement_hasExtension_Callback";

  String get xmllang() native "SVGTextContentElement_xmllang_Getter";

  void set xmllang(String) native "SVGTextContentElement_xmllang_Setter";

  String get xmlspace() native "SVGTextContentElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGTextContentElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGTextContentElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGTextContentElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGTextContentElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGTextContentElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTextElementDOMImpl extends _SVGTextPositioningElementDOMImpl implements SVGTextElement {
  _SVGTextElementDOMImpl();
  String get typeName() => "SVGTextElement";

  SVGAnimatedTransformList get transform() native "SVGTextElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGTextElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGTextElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGTextElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGTextElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGTextElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGTextElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTextPathElementDOMImpl extends _SVGTextContentElementDOMImpl implements SVGTextPathElement {
  _SVGTextPathElementDOMImpl();
  String get typeName() => "SVGTextPathElement";

  SVGAnimatedEnumeration get method() native "SVGTextPathElement_method_Getter";

  SVGAnimatedEnumeration get spacing() native "SVGTextPathElement_spacing_Getter";

  SVGAnimatedLength get startOffset() native "SVGTextPathElement_startOffset_Getter";

  SVGAnimatedString get href() native "SVGTextPathElement_href_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTextPositioningElementDOMImpl extends _SVGTextContentElementDOMImpl implements SVGTextPositioningElement {
  _SVGTextPositioningElementDOMImpl();
  String get typeName() => "SVGTextPositioningElement";

  SVGAnimatedLengthList get dx() native "SVGTextPositioningElement_dx_Getter";

  SVGAnimatedLengthList get dy() native "SVGTextPositioningElement_dy_Getter";

  SVGAnimatedNumberList get rotate() native "SVGTextPositioningElement_rotate_Getter";

  SVGAnimatedLengthList get x() native "SVGTextPositioningElement_x_Getter";

  SVGAnimatedLengthList get y() native "SVGTextPositioningElement_y_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTitleElementDOMImpl extends _SVGElementDOMImpl implements SVGTitleElement {
  _SVGTitleElementDOMImpl();
  String get typeName() => "SVGTitleElement";

  String get xmllang() native "SVGTitleElement_xmllang_Getter";

  void set xmllang(String) native "SVGTitleElement_xmllang_Setter";

  String get xmlspace() native "SVGTitleElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGTitleElement_xmlspace_Setter";

  SVGAnimatedString get $dom_svgClassName() native "SVGTitleElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGTitleElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGTitleElement_getPresentationAttribute_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTransformDOMImpl extends _DOMWrapperBase implements SVGTransform {
  _SVGTransformDOMImpl();
  String get typeName() => "SVGTransform";

  num get angle() native "SVGTransform_angle_Getter";

  SVGMatrix get matrix() native "SVGTransform_matrix_Getter";

  int get type() native "SVGTransform_type_Getter";

  void setMatrix(SVGMatrix matrix) {
    _setMatrix(matrix);
    return;
  }

  void _setMatrix(matrix) native "SVGTransform_setMatrix_Callback";

  void setRotate(num angle, num cx, num cy) {
    _setRotate(angle, cx, cy);
    return;
  }

  void _setRotate(angle, cx, cy) native "SVGTransform_setRotate_Callback";

  void setScale(num sx, num sy) {
    _setScale(sx, sy);
    return;
  }

  void _setScale(sx, sy) native "SVGTransform_setScale_Callback";

  void setSkewX(num angle) {
    _setSkewX(angle);
    return;
  }

  void _setSkewX(angle) native "SVGTransform_setSkewX_Callback";

  void setSkewY(num angle) {
    _setSkewY(angle);
    return;
  }

  void _setSkewY(angle) native "SVGTransform_setSkewY_Callback";

  void setTranslate(num tx, num ty) {
    _setTranslate(tx, ty);
    return;
  }

  void _setTranslate(tx, ty) native "SVGTransform_setTranslate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGTransformListDOMImpl extends _DOMWrapperBase implements SVGTransformList {
  _SVGTransformListDOMImpl();
  String get typeName() => "SVGTransformList";

  int get numberOfItems() native "SVGTransformList_numberOfItems_Getter";

  SVGTransform appendItem(SVGTransform item) {
    return _appendItem(item);
  }

  SVGTransform _appendItem(item) native "SVGTransformList_appendItem_Callback";

  void clear() {
    _clear();
    return;
  }

  void _clear() native "SVGTransformList_clear_Callback";

  SVGTransform consolidate() {
    return _consolidate();
  }

  SVGTransform _consolidate() native "SVGTransformList_consolidate_Callback";

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return _createSVGTransformFromMatrix(matrix);
  }

  SVGTransform _createSVGTransformFromMatrix(matrix) native "SVGTransformList_createSVGTransformFromMatrix_Callback";

  SVGTransform getItem(int index) {
    return _getItem(index);
  }

  SVGTransform _getItem(index) native "SVGTransformList_getItem_Callback";

  SVGTransform initialize(SVGTransform item) {
    return _initialize(item);
  }

  SVGTransform _initialize(item) native "SVGTransformList_initialize_Callback";

  SVGTransform insertItemBefore(SVGTransform item, int index) {
    return _insertItemBefore(item, index);
  }

  SVGTransform _insertItemBefore(item, index) native "SVGTransformList_insertItemBefore_Callback";

  SVGTransform removeItem(int index) {
    return _removeItem(index);
  }

  SVGTransform _removeItem(index) native "SVGTransformList_removeItem_Callback";

  SVGTransform replaceItem(SVGTransform item, int index) {
    return _replaceItem(item, index);
  }

  SVGTransform _replaceItem(item, index) native "SVGTransformList_replaceItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGUnitTypesDOMImpl extends _DOMWrapperBase implements SVGUnitTypes {
  _SVGUnitTypesDOMImpl();
  String get typeName() => "SVGUnitTypes";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGUseElementDOMImpl extends _SVGElementDOMImpl implements SVGUseElement {
  _SVGUseElementDOMImpl();
  String get typeName() => "SVGUseElement";

  SVGElementInstance get animatedInstanceRoot() native "SVGUseElement_animatedInstanceRoot_Getter";

  SVGAnimatedLength get height() native "SVGUseElement_height_Getter";

  SVGElementInstance get instanceRoot() native "SVGUseElement_instanceRoot_Getter";

  SVGAnimatedLength get width() native "SVGUseElement_width_Getter";

  SVGAnimatedLength get x() native "SVGUseElement_x_Getter";

  SVGAnimatedLength get y() native "SVGUseElement_y_Getter";

  SVGAnimatedString get href() native "SVGUseElement_href_Getter";

  SVGStringList get requiredExtensions() native "SVGUseElement_requiredExtensions_Getter";

  SVGStringList get requiredFeatures() native "SVGUseElement_requiredFeatures_Getter";

  SVGStringList get systemLanguage() native "SVGUseElement_systemLanguage_Getter";

  bool hasExtension(String extension) {
    return _hasExtension(extension);
  }

  bool _hasExtension(extension) native "SVGUseElement_hasExtension_Callback";

  String get xmllang() native "SVGUseElement_xmllang_Getter";

  void set xmllang(String) native "SVGUseElement_xmllang_Setter";

  String get xmlspace() native "SVGUseElement_xmlspace_Getter";

  void set xmlspace(String) native "SVGUseElement_xmlspace_Setter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGUseElement_externalResourcesRequired_Getter";

  SVGAnimatedString get $dom_svgClassName() native "SVGUseElement_className_Getter";

  CSSStyleDeclaration get style() native "SVGUseElement_style_Getter";

  CSSValue getPresentationAttribute(String name) {
    return _getPresentationAttribute(name);
  }

  CSSValue _getPresentationAttribute(name) native "SVGUseElement_getPresentationAttribute_Callback";

  SVGAnimatedTransformList get transform() native "SVGUseElement_transform_Getter";

  SVGElement get farthestViewportElement() native "SVGUseElement_farthestViewportElement_Getter";

  SVGElement get nearestViewportElement() native "SVGUseElement_nearestViewportElement_Getter";

  SVGRect getBBox() {
    return _getBBox();
  }

  SVGRect _getBBox() native "SVGUseElement_getBBox_Callback";

  SVGMatrix getCTM() {
    return _getCTM();
  }

  SVGMatrix _getCTM() native "SVGUseElement_getCTM_Callback";

  SVGMatrix getScreenCTM() {
    return _getScreenCTM();
  }

  SVGMatrix _getScreenCTM() native "SVGUseElement_getScreenCTM_Callback";

  SVGMatrix getTransformToElement(SVGElement element) {
    return _getTransformToElement(element);
  }

  SVGMatrix _getTransformToElement(element) native "SVGUseElement_getTransformToElement_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGVKernElementDOMImpl extends _SVGElementDOMImpl implements SVGVKernElement {
  _SVGVKernElementDOMImpl();
  String get typeName() => "SVGVKernElement";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGViewElementDOMImpl extends _SVGElementDOMImpl implements SVGViewElement {
  _SVGViewElementDOMImpl();
  String get typeName() => "SVGViewElement";

  SVGStringList get viewTarget() native "SVGViewElement_viewTarget_Getter";

  SVGAnimatedBoolean get externalResourcesRequired() native "SVGViewElement_externalResourcesRequired_Getter";

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() native "SVGViewElement_preserveAspectRatio_Getter";

  SVGAnimatedRect get viewBox() native "SVGViewElement_viewBox_Getter";

  int get zoomAndPan() native "SVGViewElement_zoomAndPan_Getter";

  void set zoomAndPan(int) native "SVGViewElement_zoomAndPan_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SVGZoomEventDOMImpl extends _UIEventDOMImpl implements SVGZoomEvent {
  _SVGZoomEventDOMImpl();
  String get typeName() => "SVGZoomEvent";

  num get newScale() native "SVGZoomEvent_newScale_Getter";

  SVGPoint get newTranslate() native "SVGZoomEvent_newTranslate_Getter";

  num get previousScale() native "SVGZoomEvent_previousScale_Getter";

  SVGPoint get previousTranslate() native "SVGZoomEvent_previousTranslate_Getter";

  SVGRect get zoomRectScreen() native "SVGZoomEvent_zoomRectScreen_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ScreenDOMImpl extends _DOMWrapperBase implements Screen {
  _ScreenDOMImpl();
  String get typeName() => "Screen";

  int get availHeight() native "Screen_availHeight_Getter";

  int get availLeft() native "Screen_availLeft_Getter";

  int get availTop() native "Screen_availTop_Getter";

  int get availWidth() native "Screen_availWidth_Getter";

  int get colorDepth() native "Screen_colorDepth_Getter";

  int get height() native "Screen_height_Getter";

  int get pixelDepth() native "Screen_pixelDepth_Getter";

  int get width() native "Screen_width_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ScriptProfileDOMImpl extends _DOMWrapperBase implements ScriptProfile {
  _ScriptProfileDOMImpl();
  String get typeName() => "ScriptProfile";

  ScriptProfileNode get head() native "ScriptProfile_head_Getter";

  String get title() native "ScriptProfile_title_Getter";

  int get uid() native "ScriptProfile_uid_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ScriptProfileNodeDOMImpl extends _DOMWrapperBase implements ScriptProfileNode {
  _ScriptProfileNodeDOMImpl();
  String get typeName() => "ScriptProfileNode";

  int get callUID() native "ScriptProfileNode_callUID_Getter";

  List<ScriptProfileNode> get children() native "ScriptProfileNode_children_Getter";

  String get functionName() native "ScriptProfileNode_functionName_Getter";

  int get lineNumber() native "ScriptProfileNode_lineNumber_Getter";

  int get numberOfCalls() native "ScriptProfileNode_numberOfCalls_Getter";

  num get selfTime() native "ScriptProfileNode_selfTime_Getter";

  num get totalTime() native "ScriptProfileNode_totalTime_Getter";

  String get url() native "ScriptProfileNode_url_Getter";

  bool get visible() native "ScriptProfileNode_visible_Getter";

}
class _SessionDescriptionFactoryProviderImpl {
  static _SessionDescriptionDOMImpl createSessionDescription(String sdp)
      native "SessionDescription_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SessionDescriptionDOMImpl extends _DOMWrapperBase implements SessionDescription {
  _SessionDescriptionDOMImpl();
  String get typeName() => "SessionDescription";

  void addCandidate(IceCandidate candidate) {
    _addCandidate(candidate);
    return;
  }

  void _addCandidate(candidate) native "SessionDescription_addCandidate_Callback";

  String toSdp() {
    return _toSdp();
  }

  String _toSdp() native "SessionDescription_toSdp_Callback";

}
class _ShadowRootFactoryProviderImpl {
  static _ShadowRootDOMImpl createShadowRoot(Element host)
      native "ShadowRoot_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ShadowRootDOMImpl extends _DocumentFragmentDOMImpl implements ShadowRoot {
  _ShadowRootDOMImpl();
  String get typeName() => "ShadowRoot";

  Element get activeElement() native "ShadowRoot_activeElement_Getter";

  bool get applyAuthorStyles() native "ShadowRoot_applyAuthorStyles_Getter";

  void set applyAuthorStyles(bool) native "ShadowRoot_applyAuthorStyles_Setter";

  Element get host() native "ShadowRoot_host_Getter";

  String get innerHTML() native "ShadowRoot_innerHTML_Getter";

  void set innerHTML(String) native "ShadowRoot_innerHTML_Setter";

  DOMSelection get selection() native "ShadowRoot_selection_Getter";

  Element getElementById(String elementId) {
    return _getElementById(elementId);
  }

  Element _getElementById(elementId) native "ShadowRoot_getElementById_Callback";

  NodeList getElementsByClassName(String className) {
    return _getElementsByClassName(className);
  }

  NodeList _getElementsByClassName(className) native "ShadowRoot_getElementsByClassName_Callback";

  NodeList getElementsByTagName(String tagName) {
    return _getElementsByTagName(tagName);
  }

  NodeList _getElementsByTagName(tagName) native "ShadowRoot_getElementsByTagName_Callback";

  NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
    return _getElementsByTagNameNS(namespaceURI, localName);
  }

  NodeList _getElementsByTagNameNS(namespaceURI, localName) native "ShadowRoot_getElementsByTagNameNS_Callback";

}

class _SharedWorkerContextEventsImpl extends _WorkerContextEventsImpl implements SharedWorkerContextEvents {
  _SharedWorkerContextEventsImpl(_ptr) : super(_ptr);
  EventListenerList get connect() => _get('connect');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SharedWorkerContextDOMImpl extends _WorkerContextDOMImpl implements SharedWorkerContext {
  _SharedWorkerContextDOMImpl();
  String get typeName() => "SharedWorkerContext";

  _SharedWorkerContextEventsImpl get on() {
    if (_on === null) _on = new _SharedWorkerContextEventsImpl(this);
    return _on;
  }

  String get name() native "SharedWorkerContext_name_Getter";

}
class _SharedWorkerFactoryProviderImpl {
  static _SharedWorkerDOMImpl createSharedWorker(String scriptURL, [String name = null])
      native "SharedWorker_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SharedWorkerDOMImpl extends _AbstractWorkerDOMImpl implements SharedWorker {
  _SharedWorkerDOMImpl();
  String get typeName() => "SharedWorker";

  MessagePort get port() native "SharedWorker_port_Getter";

}
class _SpeechGrammarFactoryProviderImpl {
  static _SpeechGrammarDOMImpl createSpeechGrammar()
      native "SpeechGrammar_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechGrammarDOMImpl extends _DOMWrapperBase implements SpeechGrammar {
  _SpeechGrammarDOMImpl();
  String get typeName() => "SpeechGrammar";

  String get src() native "SpeechGrammar_src_Getter";

  void set src(String) native "SpeechGrammar_src_Setter";

  num get weight() native "SpeechGrammar_weight_Getter";

  void set weight(num) native "SpeechGrammar_weight_Setter";

}
class _SpeechGrammarListFactoryProviderImpl {
  static _SpeechGrammarListDOMImpl createSpeechGrammarList()
      native "SpeechGrammarList_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechGrammarListDOMImpl extends _DOMWrapperBase implements SpeechGrammarList {
  _SpeechGrammarListDOMImpl();
  String get typeName() => "SpeechGrammarList";

  int get length() native "SpeechGrammarList_length_Getter";

  void addFromString(String string, [num weight = null]) {
    //
    // addFromString(String string)
    // addFromString(String string, [Optional] num weight)
    //
    // -- reduced:
    // addFromString(String string, [Optional] num weight)
    //
    _addFromString(string, weight);
    return;
  }

  void _addFromString(string, weight) native "SpeechGrammarList_addFromString_Callback";

  void addFromUri(String src, [num weight = null]) {
    //
    // addFromUri(String src)
    // addFromUri(String src, [Optional] num weight)
    //
    // -- reduced:
    // addFromUri(String src, [Optional] num weight)
    //
    _addFromUri(src, weight);
    return;
  }

  void _addFromUri(src, weight) native "SpeechGrammarList_addFromUri_Callback";

  SpeechGrammar item(int index) {
    return _item(index);
  }

  SpeechGrammar _item(index) native "SpeechGrammarList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechInputEventDOMImpl extends _EventDOMImpl implements SpeechInputEvent {
  _SpeechInputEventDOMImpl();
  String get typeName() => "SpeechInputEvent";

  SpeechInputResultList get results() native "SpeechInputEvent_results_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechInputResultDOMImpl extends _DOMWrapperBase implements SpeechInputResult {
  _SpeechInputResultDOMImpl();
  String get typeName() => "SpeechInputResult";

  num get confidence() native "SpeechInputResult_confidence_Getter";

  String get utterance() native "SpeechInputResult_utterance_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechInputResultListDOMImpl extends _DOMWrapperBase implements SpeechInputResultList {
  _SpeechInputResultListDOMImpl();
  String get typeName() => "SpeechInputResultList";

  int get length() native "SpeechInputResultList_length_Getter";

  SpeechInputResult item(int index) {
    return _item(index);
  }

  SpeechInputResult _item(index) native "SpeechInputResultList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechRecognitionAlternativeDOMImpl extends _DOMWrapperBase implements SpeechRecognitionAlternative {
  _SpeechRecognitionAlternativeDOMImpl();
  String get typeName() => "SpeechRecognitionAlternative";

  num get confidence() native "SpeechRecognitionAlternative_confidence_Getter";

  String get transcript() native "SpeechRecognitionAlternative_transcript_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechRecognitionErrorDOMImpl extends _DOMWrapperBase implements SpeechRecognitionError {
  _SpeechRecognitionErrorDOMImpl();
  String get typeName() => "SpeechRecognitionError";

  int get code() native "SpeechRecognitionError_code_Getter";

  String get message() native "SpeechRecognitionError_message_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechRecognitionEventDOMImpl extends _EventDOMImpl implements SpeechRecognitionEvent {
  _SpeechRecognitionEventDOMImpl();
  String get typeName() => "SpeechRecognitionEvent";

  SpeechRecognitionError get error() native "SpeechRecognitionEvent_error_Getter";

  SpeechRecognitionResult get result() native "SpeechRecognitionEvent_result_Getter";

  SpeechRecognitionResultList get resultHistory() native "SpeechRecognitionEvent_resultHistory_Getter";

  int get resultIndex() native "SpeechRecognitionEvent_resultIndex_Getter";

}
class _SpeechRecognitionFactoryProviderImpl {
  static _SpeechRecognitionDOMImpl createSpeechRecognition()
      native "SpeechRecognition_constructor_Callback";
}
class _SpeechRecognitionEventsImpl extends _EventsImpl implements SpeechRecognitionEvents {
  _SpeechRecognitionEventsImpl(_ptr) : super(_ptr);
  EventListenerList get audioEnd() => _get('audioend');
  EventListenerList get audioStart() => _get('audiostart');
  EventListenerList get end() => _get('end');
  EventListenerList get error() => _get('error');
  EventListenerList get noMatch() => _get('nomatch');
  EventListenerList get result() => _get('result');
  EventListenerList get resultDeleted() => _get('resultdeleted');
  EventListenerList get soundEnd() => _get('soundend');
  EventListenerList get soundStart() => _get('soundstart');
  EventListenerList get speechEnd() => _get('speechend');
  EventListenerList get speechStart() => _get('speechstart');
  EventListenerList get start() => _get('start');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechRecognitionDOMImpl extends _DOMWrapperBase implements SpeechRecognition {
  _SpeechRecognitionDOMImpl();
  String get typeName() => "SpeechRecognition";
  _EventsImpl _on;

  _SpeechRecognitionEventsImpl get on() {
    if (_on === null) _on = new _SpeechRecognitionEventsImpl(this);
    return _on;
  }

  bool get continuous() native "SpeechRecognition_continuous_Getter";

  void set continuous(bool) native "SpeechRecognition_continuous_Setter";

  SpeechGrammarList get grammars() native "SpeechRecognition_grammars_Getter";

  void set grammars(SpeechGrammarList) native "SpeechRecognition_grammars_Setter";

  String get lang() native "SpeechRecognition_lang_Getter";

  void set lang(String) native "SpeechRecognition_lang_Setter";

  void abort() {
    _abort();
    return;
  }

  void _abort() native "SpeechRecognition_abort_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "SpeechRecognition_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "SpeechRecognition_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "SpeechRecognition_removeEventListener_Callback";

  void start() {
    _start();
    return;
  }

  void _start() native "SpeechRecognition_start_Callback";

  void stop() {
    _stop();
    return;
  }

  void _stop() native "SpeechRecognition_stop_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechRecognitionResultDOMImpl extends _DOMWrapperBase implements SpeechRecognitionResult {
  _SpeechRecognitionResultDOMImpl();
  String get typeName() => "SpeechRecognitionResult";

  bool get finalValue() native "SpeechRecognitionResult_final_Getter";

  int get length() native "SpeechRecognitionResult_length_Getter";

  SpeechRecognitionAlternative item(int index) {
    return _item(index);
  }

  SpeechRecognitionAlternative _item(index) native "SpeechRecognitionResult_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _SpeechRecognitionResultListDOMImpl extends _DOMWrapperBase implements SpeechRecognitionResultList {
  _SpeechRecognitionResultListDOMImpl();
  String get typeName() => "SpeechRecognitionResultList";

  int get length() native "SpeechRecognitionResultList_length_Getter";

  SpeechRecognitionResult item(int index) {
    return _item(index);
  }

  SpeechRecognitionResult _item(index) native "SpeechRecognitionResultList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _StorageEventDOMImpl extends _EventDOMImpl implements StorageEvent {
  _StorageEventDOMImpl();
  String get typeName() => "StorageEvent";

  String get key() native "StorageEvent_key_Getter";

  String get newValue() native "StorageEvent_newValue_Getter";

  String get oldValue() native "StorageEvent_oldValue_Getter";

  Storage get storageArea() native "StorageEvent_storageArea_Getter";

  String get url() native "StorageEvent_url_Getter";

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) {
    _initStorageEvent(typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg);
    return;
  }

  void _initStorageEvent(typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg) native "StorageEvent_initStorageEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _StorageDOMImpl extends _DOMWrapperBase implements Storage {
  _StorageDOMImpl();
  String get typeName() => "Storage";

  int get $dom_length() native "Storage_length_Getter";

  void $dom_clear() {
    _clear();
    return;
  }

  void _clear() native "Storage_clear_Callback";

  String $dom_getItem(String key) {
    return _getItem(key);
  }

  String _getItem(key) native "Storage_getItem_Callback";

  String $dom_key(int index) {
    return _key(index);
  }

  String _key(index) native "Storage_key_Callback";

  void $dom_removeItem(String key) {
    _removeItem(key);
    return;
  }

  void _removeItem(key) native "Storage_removeItem_Callback";

  void $dom_setItem(String key, String data) {
    _setItem(key, data);
    return;
  }

  void _setItem(key, data) native "Storage_setItem_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _StorageInfoDOMImpl extends _DOMWrapperBase implements StorageInfo {
  _StorageInfoDOMImpl();
  String get typeName() => "StorageInfo";

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback = null, StorageInfoErrorCallback errorCallback = null]) {
    _queryUsageAndQuota(storageType, usageCallback, errorCallback);
    return;
  }

  void _queryUsageAndQuota(storageType, usageCallback, errorCallback) native "StorageInfo_queryUsageAndQuota_Callback";

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback = null, StorageInfoErrorCallback errorCallback = null]) {
    _requestQuota(storageType, newQuotaInBytes, quotaCallback, errorCallback);
    return;
  }

  void _requestQuota(storageType, newQuotaInBytes, quotaCallback, errorCallback) native "StorageInfo_requestQuota_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _StyleMediaDOMImpl extends _DOMWrapperBase implements StyleMedia {
  _StyleMediaDOMImpl();
  String get typeName() => "StyleMedia";

  String get type() native "StyleMedia_type_Getter";

  bool matchMedium(String mediaquery) {
    return _matchMedium(mediaquery);
  }

  bool _matchMedium(mediaquery) native "StyleMedia_matchMedium_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _StyleSheetDOMImpl extends _DOMWrapperBase implements StyleSheet {
  _StyleSheetDOMImpl();
  String get typeName() => "StyleSheet";

  bool get disabled() native "StyleSheet_disabled_Getter";

  void set disabled(bool) native "StyleSheet_disabled_Setter";

  String get href() native "StyleSheet_href_Getter";

  MediaList get media() native "StyleSheet_media_Getter";

  Node get ownerNode() native "StyleSheet_ownerNode_Getter";

  StyleSheet get parentStyleSheet() native "StyleSheet_parentStyleSheet_Getter";

  String get title() native "StyleSheet_title_Getter";

  String get type() native "StyleSheet_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _StyleSheetListDOMImpl extends _DOMWrapperBase implements StyleSheetList {
  _StyleSheetListDOMImpl();
  String get typeName() => "StyleSheetList";

  int get length() native "StyleSheetList_length_Getter";

  StyleSheet operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, StyleSheet value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<StyleSheet> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(StyleSheet a, StyleSheet b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(StyleSheet element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(StyleSheet element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  StyleSheet removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  StyleSheet last() {
    return this[length - 1];
  }

  void forEach(void f(StyleSheet element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(StyleSheet element)) {
    return _Collections.map(this, [], f);
  }

  Collection<StyleSheet> filter(bool f(StyleSheet element)) {
    return _Collections.filter(this, new List<StyleSheet>(), f);
  }

  bool every(bool f(StyleSheet element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(StyleSheet element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [StyleSheet initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<StyleSheet> iterator() {
    return new _FixedSizeListIterator<StyleSheet>(this);
  }

  StyleSheet item(int index) {
    return _item(index);
  }

  StyleSheet _item(index) native "StyleSheetList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextEventDOMImpl extends _UIEventDOMImpl implements TextEvent {
  _TextEventDOMImpl();
  String get typeName() => "TextEvent";

  String get data() native "TextEvent_data_Getter";

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) {
    if ((viewArg === null || viewArg is Window)) {
      _initTextEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initTextEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg) native "TextEvent_initTextEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextDOMImpl extends _CharacterDataDOMImpl implements Text {
  _TextDOMImpl();
  String get typeName() => "Text";

  String get wholeText() native "Text_wholeText_Getter";

  Text replaceWholeText(String content) {
    return _replaceWholeText(content);
  }

  Text _replaceWholeText(content) native "Text_replaceWholeText_Callback";

  Text splitText(int offset) {
    return _splitText(offset);
  }

  Text _splitText(offset) native "Text_splitText_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextMetricsDOMImpl extends _DOMWrapperBase implements TextMetrics {
  _TextMetricsDOMImpl();
  String get typeName() => "TextMetrics";

  num get width() native "TextMetrics_width_Getter";

}
class _TextTrackCueFactoryProviderImpl {
  static _TextTrackCueDOMImpl createTextTrackCue(String id, num startTime, num endTime, String text, [String settings = null, bool pauseOnExit = null])
      native "TextTrackCue_constructor_Callback";
}
class _TextTrackCueEventsImpl extends _EventsImpl implements TextTrackCueEvents {
  _TextTrackCueEventsImpl(_ptr) : super(_ptr);
  EventListenerList get enter() => _get('enter');
  EventListenerList get exit() => _get('exit');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextTrackCueDOMImpl extends _DOMWrapperBase implements TextTrackCue {
  _TextTrackCueDOMImpl();
  String get typeName() => "TextTrackCue";
  _EventsImpl _on;

  _TextTrackCueEventsImpl get on() {
    if (_on === null) _on = new _TextTrackCueEventsImpl(this);
    return _on;
  }

  String get align() native "TextTrackCue_align_Getter";

  void set align(String) native "TextTrackCue_align_Setter";

  num get endTime() native "TextTrackCue_endTime_Getter";

  void set endTime(num) native "TextTrackCue_endTime_Setter";

  String get id() native "TextTrackCue_id_Getter";

  void set id(String) native "TextTrackCue_id_Setter";

  int get line() native "TextTrackCue_line_Getter";

  void set line(int) native "TextTrackCue_line_Setter";

  bool get pauseOnExit() native "TextTrackCue_pauseOnExit_Getter";

  void set pauseOnExit(bool) native "TextTrackCue_pauseOnExit_Setter";

  int get position() native "TextTrackCue_position_Getter";

  void set position(int) native "TextTrackCue_position_Setter";

  int get size() native "TextTrackCue_size_Getter";

  void set size(int) native "TextTrackCue_size_Setter";

  bool get snapToLines() native "TextTrackCue_snapToLines_Getter";

  void set snapToLines(bool) native "TextTrackCue_snapToLines_Setter";

  num get startTime() native "TextTrackCue_startTime_Getter";

  void set startTime(num) native "TextTrackCue_startTime_Setter";

  String get text() native "TextTrackCue_text_Getter";

  void set text(String) native "TextTrackCue_text_Setter";

  TextTrack get track() native "TextTrackCue_track_Getter";

  String get vertical() native "TextTrackCue_vertical_Getter";

  void set vertical(String) native "TextTrackCue_vertical_Setter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "TextTrackCue_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "TextTrackCue_dispatchEvent_Callback";

  DocumentFragment getCueAsHTML() {
    return _getCueAsHTML();
  }

  DocumentFragment _getCueAsHTML() native "TextTrackCue_getCueAsHTML_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "TextTrackCue_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextTrackCueListDOMImpl extends _DOMWrapperBase implements TextTrackCueList {
  _TextTrackCueListDOMImpl();
  String get typeName() => "TextTrackCueList";

  int get length() native "TextTrackCueList_length_Getter";

  TextTrackCue getCueById(String id) {
    return _getCueById(id);
  }

  TextTrackCue _getCueById(id) native "TextTrackCueList_getCueById_Callback";

  TextTrackCue item(int index) {
    return _item(index);
  }

  TextTrackCue _item(index) native "TextTrackCueList_item_Callback";

}

class _TextTrackEventsImpl extends _EventsImpl implements TextTrackEvents {
  _TextTrackEventsImpl(_ptr) : super(_ptr);
  EventListenerList get cueChange() => _get('cuechange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextTrackDOMImpl extends _DOMWrapperBase implements TextTrack {
  _TextTrackDOMImpl();
  String get typeName() => "TextTrack";
  _EventsImpl _on;

  _TextTrackEventsImpl get on() {
    if (_on === null) _on = new _TextTrackEventsImpl(this);
    return _on;
  }

  TextTrackCueList get activeCues() native "TextTrack_activeCues_Getter";

  TextTrackCueList get cues() native "TextTrack_cues_Getter";

  String get kind() native "TextTrack_kind_Getter";

  String get label() native "TextTrack_label_Getter";

  String get language() native "TextTrack_language_Getter";

  int get mode() native "TextTrack_mode_Getter";

  void set mode(int) native "TextTrack_mode_Setter";

  void addCue(TextTrackCue cue) {
    _addCue(cue);
    return;
  }

  void _addCue(cue) native "TextTrack_addCue_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "TextTrack_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "TextTrack_dispatchEvent_Callback";

  void removeCue(TextTrackCue cue) {
    _removeCue(cue);
    return;
  }

  void _removeCue(cue) native "TextTrack_removeCue_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "TextTrack_removeEventListener_Callback";

}

class _TextTrackListEventsImpl extends _EventsImpl implements TextTrackListEvents {
  _TextTrackListEventsImpl(_ptr) : super(_ptr);
  EventListenerList get addTrack() => _get('addtrack');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TextTrackListDOMImpl extends _DOMWrapperBase implements TextTrackList {
  _TextTrackListDOMImpl();
  String get typeName() => "TextTrackList";
  _EventsImpl _on;

  _TextTrackListEventsImpl get on() {
    if (_on === null) _on = new _TextTrackListEventsImpl(this);
    return _on;
  }

  int get length() native "TextTrackList_length_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "TextTrackList_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "TextTrackList_dispatchEvent_Callback";

  TextTrack item(int index) {
    return _item(index);
  }

  TextTrack _item(index) native "TextTrackList_item_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "TextTrackList_removeEventListener_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TimeRangesDOMImpl extends _DOMWrapperBase implements TimeRanges {
  _TimeRangesDOMImpl();
  String get typeName() => "TimeRanges";

  int get length() native "TimeRanges_length_Getter";

  num end(int index) {
    return _end(index);
  }

  num _end(index) native "TimeRanges_end_Callback";

  num start(int index) {
    return _start(index);
  }

  num _start(index) native "TimeRanges_start_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TouchEventDOMImpl extends _UIEventDOMImpl implements TouchEvent {
  _TouchEventDOMImpl();
  String get typeName() => "TouchEvent";

  bool get altKey() native "TouchEvent_altKey_Getter";

  TouchList get changedTouches() native "TouchEvent_changedTouches_Getter";

  bool get ctrlKey() native "TouchEvent_ctrlKey_Getter";

  bool get metaKey() native "TouchEvent_metaKey_Getter";

  bool get shiftKey() native "TouchEvent_shiftKey_Getter";

  TouchList get targetTouches() native "TouchEvent_targetTouches_Getter";

  TouchList get touches() native "TouchEvent_touches_Getter";

  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) {
    if ((view === null || view is Window)) {
      _initTouchEvent(touches, targetTouches, changedTouches, type, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initTouchEvent(touches, targetTouches, changedTouches, type, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey) native "TouchEvent_initTouchEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TouchDOMImpl extends _DOMWrapperBase implements Touch {
  _TouchDOMImpl();
  String get typeName() => "Touch";

  int get clientX() native "Touch_clientX_Getter";

  int get clientY() native "Touch_clientY_Getter";

  int get identifier() native "Touch_identifier_Getter";

  int get pageX() native "Touch_pageX_Getter";

  int get pageY() native "Touch_pageY_Getter";

  int get screenX() native "Touch_screenX_Getter";

  int get screenY() native "Touch_screenY_Getter";

  EventTarget get target() native "Touch_target_Getter";

  num get webkitForce() native "Touch_webkitForce_Getter";

  int get webkitRadiusX() native "Touch_webkitRadiusX_Getter";

  int get webkitRadiusY() native "Touch_webkitRadiusY_Getter";

  num get webkitRotationAngle() native "Touch_webkitRotationAngle_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TouchListDOMImpl extends _DOMWrapperBase implements TouchList {
  _TouchListDOMImpl();
  String get typeName() => "TouchList";

  int get length() native "TouchList_length_Getter";

  Touch operator[](int index) {
    return item(index);
  }

  void operator[]=(int index, Touch value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }

  void add(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Touch> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(Touch a, Touch b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(Touch element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Touch element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  Touch removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  Touch last() {
    return this[length - 1];
  }

  void forEach(void f(Touch element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(Touch element)) {
    return _Collections.map(this, [], f);
  }

  Collection<Touch> filter(bool f(Touch element)) {
    return _Collections.filter(this, new List<Touch>(), f);
  }

  bool every(bool f(Touch element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(Touch element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<Touch> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [Touch initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<Touch> iterator() {
    return new _FixedSizeListIterator<Touch>(this);
  }

  Touch item(int index) {
    return _item(index);
  }

  Touch _item(index) native "TouchList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TrackEventDOMImpl extends _EventDOMImpl implements TrackEvent {
  _TrackEventDOMImpl();
  String get typeName() => "TrackEvent";

  Object get track() native "TrackEvent_track_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _TreeWalkerDOMImpl extends _DOMWrapperBase implements TreeWalker {
  _TreeWalkerDOMImpl();
  String get typeName() => "TreeWalker";

  Node get currentNode() native "TreeWalker_currentNode_Getter";

  void set currentNode(Node) native "TreeWalker_currentNode_Setter";

  bool get expandEntityReferences() native "TreeWalker_expandEntityReferences_Getter";

  NodeFilter get filter() native "TreeWalker_filter_Getter";

  Node get root() native "TreeWalker_root_Getter";

  int get whatToShow() native "TreeWalker_whatToShow_Getter";

  Node firstChild() {
    return _firstChild();
  }

  Node _firstChild() native "TreeWalker_firstChild_Callback";

  Node lastChild() {
    return _lastChild();
  }

  Node _lastChild() native "TreeWalker_lastChild_Callback";

  Node nextNode() {
    return _nextNode();
  }

  Node _nextNode() native "TreeWalker_nextNode_Callback";

  Node nextSibling() {
    return _nextSibling();
  }

  Node _nextSibling() native "TreeWalker_nextSibling_Callback";

  Node parentNode() {
    return _parentNode();
  }

  Node _parentNode() native "TreeWalker_parentNode_Callback";

  Node previousNode() {
    return _previousNode();
  }

  Node _previousNode() native "TreeWalker_previousNode_Callback";

  Node previousSibling() {
    return _previousSibling();
  }

  Node _previousSibling() native "TreeWalker_previousSibling_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _UIEventDOMImpl extends _EventDOMImpl implements UIEvent {
  _UIEventDOMImpl();
  String get typeName() => "UIEvent";

  int get charCode() native "UIEvent_charCode_Getter";

  int get detail() native "UIEvent_detail_Getter";

  int get keyCode() native "UIEvent_keyCode_Getter";

  int get layerX() native "UIEvent_layerX_Getter";

  int get layerY() native "UIEvent_layerY_Getter";

  int get pageX() native "UIEvent_pageX_Getter";

  int get pageY() native "UIEvent_pageY_Getter";

  Window get view() native "UIEvent_view_Getter";

  int get which() native "UIEvent_which_Getter";

  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) {
    if ((view === null || view is Window)) {
      _initUIEvent(type, canBubble, cancelable, view, detail);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initUIEvent(type, canBubble, cancelable, view, detail) native "UIEvent_initUIEvent_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Uint16ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Uint16Array {
  _Uint16ArrayDOMImpl();
  String get typeName() => "Uint16Array";

  int get length() native "Uint16Array_length_Getter";

  int operator[](int index) native "Uint16Array_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Uint16Array_numericIndexSetter_Callback";

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) native "Uint16Array_setElements_Callback";

  Uint16Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Uint16Array _subarray(start, end) native "Uint16Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Uint32ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Uint32Array {
  _Uint32ArrayDOMImpl();
  String get typeName() => "Uint32Array";

  int get length() native "Uint32Array_length_Getter";

  int operator[](int index) native "Uint32Array_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Uint32Array_numericIndexSetter_Callback";

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) native "Uint32Array_setElements_Callback";

  Uint32Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Uint32Array _subarray(start, end) native "Uint32Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Uint8ArrayDOMImpl extends _ArrayBufferViewDOMImpl implements Uint8Array {
  _Uint8ArrayDOMImpl();
  String get typeName() => "Uint8Array";

  int get length() native "Uint8Array_length_Getter";

  int operator[](int index) native "Uint8Array_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Uint8Array_numericIndexSetter_Callback";

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw new UnsupportedOperationException("This object is immutable.");
  }

  int indexOf(int element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(int element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int clear() {
    throw new UnsupportedOperationException("Cannot clear immutable List.");
  }

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  int last() {
    return this[length - 1];
  }

  void forEach(void f(int element)) {
    _Collections.forEach(this, f);
  }

  Collection map(f(int element)) {
    return _Collections.map(this, [], f);
  }

  Collection<int> filter(bool f(int element)) {
    return _Collections.filter(this, new List<int>(), f);
  }

  bool every(bool f(int element)) {
    return _Collections.every(this, f);
  }

  bool some(bool f(int element)) {
    return _Collections.some(this, f);
  }

  void setRange(int start, int length, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int length) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int length, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int length) {
    throw new NotImplementedException();
  }

  bool isEmpty() {
    return length == 0;
  }

  Iterator<int> iterator() {
    return new _FixedSizeListIterator<int>(this);
  }

  void setElements(Object array, [int offset = null]) native "Uint8Array_setElements_Callback";

  Uint8Array subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Uint8Array _subarray(start, end) native "Uint8Array_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _Uint8ClampedArrayDOMImpl extends _Uint8ArrayDOMImpl implements Uint8ClampedArray {
  _Uint8ClampedArrayDOMImpl();
  String get typeName() => "Uint8ClampedArray";

  int get length() native "Uint8ClampedArray_length_Getter";

  int operator[](int index) native "Uint8ClampedArray_numericIndexGetter_Callback";

  void operator[]=(int index, int value) native "Uint8ClampedArray_numericIndexSetter_Callback";

  void setElements(Object array, [int offset = null]) native "Uint8ClampedArray_setElements_Callback";

  Uint8ClampedArray subarray(int start, [int end = null]) {
    //
    // subarray(int start)
    // subarray(int start, [Optional] int end)
    //
    // -- reduced:
    // subarray(int start, [Optional] int end)
    //
    return _subarray(start, end);
  }

  Uint8ClampedArray _subarray(start, end) native "Uint8ClampedArray_subarray_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _ValidityStateDOMImpl extends _DOMWrapperBase implements ValidityState {
  _ValidityStateDOMImpl();
  String get typeName() => "ValidityState";

  bool get customError() native "ValidityState_customError_Getter";

  bool get patternMismatch() native "ValidityState_patternMismatch_Getter";

  bool get rangeOverflow() native "ValidityState_rangeOverflow_Getter";

  bool get rangeUnderflow() native "ValidityState_rangeUnderflow_Getter";

  bool get stepMismatch() native "ValidityState_stepMismatch_Getter";

  bool get tooLong() native "ValidityState_tooLong_Getter";

  bool get typeMismatch() native "ValidityState_typeMismatch_Getter";

  bool get valid() native "ValidityState_valid_Getter";

  bool get valueMissing() native "ValidityState_valueMissing_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WaveShaperNodeDOMImpl extends _AudioNodeDOMImpl implements WaveShaperNode {
  _WaveShaperNodeDOMImpl();
  String get typeName() => "WaveShaperNode";

  Float32Array get curve() native "WaveShaperNode_curve_Getter";

  void set curve(Float32Array) native "WaveShaperNode_curve_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WaveTableDOMImpl extends _DOMWrapperBase implements WaveTable {
  _WaveTableDOMImpl();
  String get typeName() => "WaveTable";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLActiveInfoDOMImpl extends _DOMWrapperBase implements WebGLActiveInfo {
  _WebGLActiveInfoDOMImpl();
  String get typeName() => "WebGLActiveInfo";

  String get name() native "WebGLActiveInfo_name_Getter";

  int get size() native "WebGLActiveInfo_size_Getter";

  int get type() native "WebGLActiveInfo_type_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLBufferDOMImpl extends _DOMWrapperBase implements WebGLBuffer {
  _WebGLBufferDOMImpl();
  String get typeName() => "WebGLBuffer";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLCompressedTextureS3TCDOMImpl extends _DOMWrapperBase implements WebGLCompressedTextureS3TC {
  _WebGLCompressedTextureS3TCDOMImpl();
  String get typeName() => "WebGLCompressedTextureS3TC";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLContextAttributesDOMImpl extends _DOMWrapperBase implements WebGLContextAttributes {
  _WebGLContextAttributesDOMImpl();
  String get typeName() => "WebGLContextAttributes";

  bool get alpha() native "WebGLContextAttributes_alpha_Getter";

  void set alpha(bool) native "WebGLContextAttributes_alpha_Setter";

  bool get antialias() native "WebGLContextAttributes_antialias_Getter";

  void set antialias(bool) native "WebGLContextAttributes_antialias_Setter";

  bool get depth() native "WebGLContextAttributes_depth_Getter";

  void set depth(bool) native "WebGLContextAttributes_depth_Setter";

  bool get premultipliedAlpha() native "WebGLContextAttributes_premultipliedAlpha_Getter";

  void set premultipliedAlpha(bool) native "WebGLContextAttributes_premultipliedAlpha_Setter";

  bool get preserveDrawingBuffer() native "WebGLContextAttributes_preserveDrawingBuffer_Getter";

  void set preserveDrawingBuffer(bool) native "WebGLContextAttributes_preserveDrawingBuffer_Setter";

  bool get stencil() native "WebGLContextAttributes_stencil_Getter";

  void set stencil(bool) native "WebGLContextAttributes_stencil_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLContextEventDOMImpl extends _EventDOMImpl implements WebGLContextEvent {
  _WebGLContextEventDOMImpl();
  String get typeName() => "WebGLContextEvent";

  String get statusMessage() native "WebGLContextEvent_statusMessage_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLDebugRendererInfoDOMImpl extends _DOMWrapperBase implements WebGLDebugRendererInfo {
  _WebGLDebugRendererInfoDOMImpl();
  String get typeName() => "WebGLDebugRendererInfo";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLDebugShadersDOMImpl extends _DOMWrapperBase implements WebGLDebugShaders {
  _WebGLDebugShadersDOMImpl();
  String get typeName() => "WebGLDebugShaders";

  String getTranslatedShaderSource(WebGLShader shader) {
    return _getTranslatedShaderSource(shader);
  }

  String _getTranslatedShaderSource(shader) native "WebGLDebugShaders_getTranslatedShaderSource_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLFramebufferDOMImpl extends _DOMWrapperBase implements WebGLFramebuffer {
  _WebGLFramebufferDOMImpl();
  String get typeName() => "WebGLFramebuffer";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLLoseContextDOMImpl extends _DOMWrapperBase implements WebGLLoseContext {
  _WebGLLoseContextDOMImpl();
  String get typeName() => "WebGLLoseContext";

  void loseContext() {
    _loseContext();
    return;
  }

  void _loseContext() native "WebGLLoseContext_loseContext_Callback";

  void restoreContext() {
    _restoreContext();
    return;
  }

  void _restoreContext() native "WebGLLoseContext_restoreContext_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLProgramDOMImpl extends _DOMWrapperBase implements WebGLProgram {
  _WebGLProgramDOMImpl();
  String get typeName() => "WebGLProgram";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLRenderbufferDOMImpl extends _DOMWrapperBase implements WebGLRenderbuffer {
  _WebGLRenderbufferDOMImpl();
  String get typeName() => "WebGLRenderbuffer";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLRenderingContextDOMImpl extends _CanvasRenderingContextDOMImpl implements WebGLRenderingContext {
  _WebGLRenderingContextDOMImpl();
  String get typeName() => "WebGLRenderingContext";

  int get drawingBufferHeight() native "WebGLRenderingContext_drawingBufferHeight_Getter";

  int get drawingBufferWidth() native "WebGLRenderingContext_drawingBufferWidth_Getter";

  void activeTexture(int texture) {
    _activeTexture(texture);
    return;
  }

  void _activeTexture(texture) native "WebGLRenderingContext_activeTexture_Callback";

  void attachShader(WebGLProgram program, WebGLShader shader) {
    _attachShader(program, shader);
    return;
  }

  void _attachShader(program, shader) native "WebGLRenderingContext_attachShader_Callback";

  void bindAttribLocation(WebGLProgram program, int index, String name) {
    _bindAttribLocation(program, index, name);
    return;
  }

  void _bindAttribLocation(program, index, name) native "WebGLRenderingContext_bindAttribLocation_Callback";

  void bindBuffer(int target, WebGLBuffer buffer) {
    _bindBuffer(target, buffer);
    return;
  }

  void _bindBuffer(target, buffer) native "WebGLRenderingContext_bindBuffer_Callback";

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) {
    _bindFramebuffer(target, framebuffer);
    return;
  }

  void _bindFramebuffer(target, framebuffer) native "WebGLRenderingContext_bindFramebuffer_Callback";

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) {
    _bindRenderbuffer(target, renderbuffer);
    return;
  }

  void _bindRenderbuffer(target, renderbuffer) native "WebGLRenderingContext_bindRenderbuffer_Callback";

  void bindTexture(int target, WebGLTexture texture) {
    _bindTexture(target, texture);
    return;
  }

  void _bindTexture(target, texture) native "WebGLRenderingContext_bindTexture_Callback";

  void blendColor(num red, num green, num blue, num alpha) {
    _blendColor(red, green, blue, alpha);
    return;
  }

  void _blendColor(red, green, blue, alpha) native "WebGLRenderingContext_blendColor_Callback";

  void blendEquation(int mode) {
    _blendEquation(mode);
    return;
  }

  void _blendEquation(mode) native "WebGLRenderingContext_blendEquation_Callback";

  void blendEquationSeparate(int modeRGB, int modeAlpha) {
    _blendEquationSeparate(modeRGB, modeAlpha);
    return;
  }

  void _blendEquationSeparate(modeRGB, modeAlpha) native "WebGLRenderingContext_blendEquationSeparate_Callback";

  void blendFunc(int sfactor, int dfactor) {
    _blendFunc(sfactor, dfactor);
    return;
  }

  void _blendFunc(sfactor, dfactor) native "WebGLRenderingContext_blendFunc_Callback";

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
    _blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    return;
  }

  void _blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) native "WebGLRenderingContext_blendFuncSeparate_Callback";

  void bufferData(int target, data_OR_size, int usage) {
    //
    // bufferData(int target, ArrayBuffer data, int usage)
    // bufferData(int target, ArrayBufferView data, int usage)
    // bufferData(int target, int size, int usage)
    //
    if ((data_OR_size === null || data_OR_size is ArrayBuffer)) {
      _bufferData(target, data_OR_size, usage);
      return;
    }
    if ((data_OR_size === null || data_OR_size is ArrayBufferView)) {
      _bufferData_2(target, data_OR_size, usage);
      return;
    }
    if ((data_OR_size === null || data_OR_size is int)) {
      _bufferData_3(target, data_OR_size, usage);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _bufferData(target, data_OR_size, usage) native "WebGLRenderingContext_bufferData_Callback";

  void _bufferData_2(target, data_OR_size, usage) native "WebGLRenderingContext_bufferData_2_Callback";

  void _bufferData_3(target, data_OR_size, usage) native "WebGLRenderingContext_bufferData_3_Callback";

  void bufferSubData(int target, int offset, data) {
    //
    // bufferSubData(int target, int offset, ArrayBuffer data)
    // bufferSubData(int target, int offset, ArrayBufferView data)
    //
    if ((data === null || data is ArrayBuffer)) {
      _bufferSubData(target, offset, data);
      return;
    }
    if ((data === null || data is ArrayBufferView)) {
      _bufferSubData_2(target, offset, data);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _bufferSubData(target, offset, data) native "WebGLRenderingContext_bufferSubData_Callback";

  void _bufferSubData_2(target, offset, data) native "WebGLRenderingContext_bufferSubData_2_Callback";

  int checkFramebufferStatus(int target) {
    return _checkFramebufferStatus(target);
  }

  int _checkFramebufferStatus(target) native "WebGLRenderingContext_checkFramebufferStatus_Callback";

  void clear(int mask) {
    _clear(mask);
    return;
  }

  void _clear(mask) native "WebGLRenderingContext_clear_Callback";

  void clearColor(num red, num green, num blue, num alpha) {
    _clearColor(red, green, blue, alpha);
    return;
  }

  void _clearColor(red, green, blue, alpha) native "WebGLRenderingContext_clearColor_Callback";

  void clearDepth(num depth) {
    _clearDepth(depth);
    return;
  }

  void _clearDepth(depth) native "WebGLRenderingContext_clearDepth_Callback";

  void clearStencil(int s) {
    _clearStencil(s);
    return;
  }

  void _clearStencil(s) native "WebGLRenderingContext_clearStencil_Callback";

  void colorMask(bool red, bool green, bool blue, bool alpha) {
    _colorMask(red, green, blue, alpha);
    return;
  }

  void _colorMask(red, green, blue, alpha) native "WebGLRenderingContext_colorMask_Callback";

  void compileShader(WebGLShader shader) {
    _compileShader(shader);
    return;
  }

  void _compileShader(shader) native "WebGLRenderingContext_compileShader_Callback";

  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data) {
    _compressedTexImage2D(target, level, internalformat, width, height, border, data);
    return;
  }

  void _compressedTexImage2D(target, level, internalformat, width, height, border, data) native "WebGLRenderingContext_compressedTexImage2D_Callback";

  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data) {
    _compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data);
    return;
  }

  void _compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data) native "WebGLRenderingContext_compressedTexSubImage2D_Callback";

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
    _copyTexImage2D(target, level, internalformat, x, y, width, height, border);
    return;
  }

  void _copyTexImage2D(target, level, internalformat, x, y, width, height, border) native "WebGLRenderingContext_copyTexImage2D_Callback";

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
    _copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    return;
  }

  void _copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height) native "WebGLRenderingContext_copyTexSubImage2D_Callback";

  WebGLBuffer createBuffer() {
    return _createBuffer();
  }

  WebGLBuffer _createBuffer() native "WebGLRenderingContext_createBuffer_Callback";

  WebGLFramebuffer createFramebuffer() {
    return _createFramebuffer();
  }

  WebGLFramebuffer _createFramebuffer() native "WebGLRenderingContext_createFramebuffer_Callback";

  WebGLProgram createProgram() {
    return _createProgram();
  }

  WebGLProgram _createProgram() native "WebGLRenderingContext_createProgram_Callback";

  WebGLRenderbuffer createRenderbuffer() {
    return _createRenderbuffer();
  }

  WebGLRenderbuffer _createRenderbuffer() native "WebGLRenderingContext_createRenderbuffer_Callback";

  WebGLShader createShader(int type) {
    return _createShader(type);
  }

  WebGLShader _createShader(type) native "WebGLRenderingContext_createShader_Callback";

  WebGLTexture createTexture() {
    return _createTexture();
  }

  WebGLTexture _createTexture() native "WebGLRenderingContext_createTexture_Callback";

  void cullFace(int mode) {
    _cullFace(mode);
    return;
  }

  void _cullFace(mode) native "WebGLRenderingContext_cullFace_Callback";

  void deleteBuffer(WebGLBuffer buffer) {
    _deleteBuffer(buffer);
    return;
  }

  void _deleteBuffer(buffer) native "WebGLRenderingContext_deleteBuffer_Callback";

  void deleteFramebuffer(WebGLFramebuffer framebuffer) {
    _deleteFramebuffer(framebuffer);
    return;
  }

  void _deleteFramebuffer(framebuffer) native "WebGLRenderingContext_deleteFramebuffer_Callback";

  void deleteProgram(WebGLProgram program) {
    _deleteProgram(program);
    return;
  }

  void _deleteProgram(program) native "WebGLRenderingContext_deleteProgram_Callback";

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) {
    _deleteRenderbuffer(renderbuffer);
    return;
  }

  void _deleteRenderbuffer(renderbuffer) native "WebGLRenderingContext_deleteRenderbuffer_Callback";

  void deleteShader(WebGLShader shader) {
    _deleteShader(shader);
    return;
  }

  void _deleteShader(shader) native "WebGLRenderingContext_deleteShader_Callback";

  void deleteTexture(WebGLTexture texture) {
    _deleteTexture(texture);
    return;
  }

  void _deleteTexture(texture) native "WebGLRenderingContext_deleteTexture_Callback";

  void depthFunc(int func) {
    _depthFunc(func);
    return;
  }

  void _depthFunc(func) native "WebGLRenderingContext_depthFunc_Callback";

  void depthMask(bool flag) {
    _depthMask(flag);
    return;
  }

  void _depthMask(flag) native "WebGLRenderingContext_depthMask_Callback";

  void depthRange(num zNear, num zFar) {
    _depthRange(zNear, zFar);
    return;
  }

  void _depthRange(zNear, zFar) native "WebGLRenderingContext_depthRange_Callback";

  void detachShader(WebGLProgram program, WebGLShader shader) {
    _detachShader(program, shader);
    return;
  }

  void _detachShader(program, shader) native "WebGLRenderingContext_detachShader_Callback";

  void disable(int cap) {
    _disable(cap);
    return;
  }

  void _disable(cap) native "WebGLRenderingContext_disable_Callback";

  void disableVertexAttribArray(int index) {
    _disableVertexAttribArray(index);
    return;
  }

  void _disableVertexAttribArray(index) native "WebGLRenderingContext_disableVertexAttribArray_Callback";

  void drawArrays(int mode, int first, int count) {
    _drawArrays(mode, first, count);
    return;
  }

  void _drawArrays(mode, first, count) native "WebGLRenderingContext_drawArrays_Callback";

  void drawElements(int mode, int count, int type, int offset) {
    _drawElements(mode, count, type, offset);
    return;
  }

  void _drawElements(mode, count, type, offset) native "WebGLRenderingContext_drawElements_Callback";

  void enable(int cap) {
    _enable(cap);
    return;
  }

  void _enable(cap) native "WebGLRenderingContext_enable_Callback";

  void enableVertexAttribArray(int index) {
    _enableVertexAttribArray(index);
    return;
  }

  void _enableVertexAttribArray(index) native "WebGLRenderingContext_enableVertexAttribArray_Callback";

  void finish() {
    _finish();
    return;
  }

  void _finish() native "WebGLRenderingContext_finish_Callback";

  void flush() {
    _flush();
    return;
  }

  void _flush() native "WebGLRenderingContext_flush_Callback";

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) {
    _framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    return;
  }

  void _framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) native "WebGLRenderingContext_framebufferRenderbuffer_Callback";

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) {
    _framebufferTexture2D(target, attachment, textarget, texture, level);
    return;
  }

  void _framebufferTexture2D(target, attachment, textarget, texture, level) native "WebGLRenderingContext_framebufferTexture2D_Callback";

  void frontFace(int mode) {
    _frontFace(mode);
    return;
  }

  void _frontFace(mode) native "WebGLRenderingContext_frontFace_Callback";

  void generateMipmap(int target) {
    _generateMipmap(target);
    return;
  }

  void _generateMipmap(target) native "WebGLRenderingContext_generateMipmap_Callback";

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) {
    return _getActiveAttrib(program, index);
  }

  WebGLActiveInfo _getActiveAttrib(program, index) native "WebGLRenderingContext_getActiveAttrib_Callback";

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) {
    return _getActiveUniform(program, index);
  }

  WebGLActiveInfo _getActiveUniform(program, index) native "WebGLRenderingContext_getActiveUniform_Callback";

  List getAttachedShaders(WebGLProgram program) native "WebGLRenderingContext_getAttachedShaders_Callback";

  int getAttribLocation(WebGLProgram program, String name) {
    return _getAttribLocation(program, name);
  }

  int _getAttribLocation(program, name) native "WebGLRenderingContext_getAttribLocation_Callback";

  Object getBufferParameter(int target, int pname) native "WebGLRenderingContext_getBufferParameter_Callback";

  WebGLContextAttributes getContextAttributes() {
    return _getContextAttributes();
  }

  WebGLContextAttributes _getContextAttributes() native "WebGLRenderingContext_getContextAttributes_Callback";

  int getError() {
    return _getError();
  }

  int _getError() native "WebGLRenderingContext_getError_Callback";

  Object getExtension(String name) native "WebGLRenderingContext_getExtension_Callback";

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) native "WebGLRenderingContext_getFramebufferAttachmentParameter_Callback";

  Object getParameter(int pname) native "WebGLRenderingContext_getParameter_Callback";

  String getProgramInfoLog(WebGLProgram program) {
    return _getProgramInfoLog(program);
  }

  String _getProgramInfoLog(program) native "WebGLRenderingContext_getProgramInfoLog_Callback";

  Object getProgramParameter(WebGLProgram program, int pname) native "WebGLRenderingContext_getProgramParameter_Callback";

  Object getRenderbufferParameter(int target, int pname) native "WebGLRenderingContext_getRenderbufferParameter_Callback";

  String getShaderInfoLog(WebGLShader shader) {
    return _getShaderInfoLog(shader);
  }

  String _getShaderInfoLog(shader) native "WebGLRenderingContext_getShaderInfoLog_Callback";

  Object getShaderParameter(WebGLShader shader, int pname) native "WebGLRenderingContext_getShaderParameter_Callback";

  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype) {
    return _getShaderPrecisionFormat(shadertype, precisiontype);
  }

  WebGLShaderPrecisionFormat _getShaderPrecisionFormat(shadertype, precisiontype) native "WebGLRenderingContext_getShaderPrecisionFormat_Callback";

  String getShaderSource(WebGLShader shader) {
    return _getShaderSource(shader);
  }

  String _getShaderSource(shader) native "WebGLRenderingContext_getShaderSource_Callback";

  Object getTexParameter(int target, int pname) native "WebGLRenderingContext_getTexParameter_Callback";

  Object getUniform(WebGLProgram program, WebGLUniformLocation location) native "WebGLRenderingContext_getUniform_Callback";

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) {
    return _getUniformLocation(program, name);
  }

  WebGLUniformLocation _getUniformLocation(program, name) native "WebGLRenderingContext_getUniformLocation_Callback";

  Object getVertexAttrib(int index, int pname) native "WebGLRenderingContext_getVertexAttrib_Callback";

  int getVertexAttribOffset(int index, int pname) {
    return _getVertexAttribOffset(index, pname);
  }

  int _getVertexAttribOffset(index, pname) native "WebGLRenderingContext_getVertexAttribOffset_Callback";

  void hint(int target, int mode) {
    _hint(target, mode);
    return;
  }

  void _hint(target, mode) native "WebGLRenderingContext_hint_Callback";

  bool isBuffer(WebGLBuffer buffer) {
    return _isBuffer(buffer);
  }

  bool _isBuffer(buffer) native "WebGLRenderingContext_isBuffer_Callback";

  bool isContextLost() {
    return _isContextLost();
  }

  bool _isContextLost() native "WebGLRenderingContext_isContextLost_Callback";

  bool isEnabled(int cap) {
    return _isEnabled(cap);
  }

  bool _isEnabled(cap) native "WebGLRenderingContext_isEnabled_Callback";

  bool isFramebuffer(WebGLFramebuffer framebuffer) {
    return _isFramebuffer(framebuffer);
  }

  bool _isFramebuffer(framebuffer) native "WebGLRenderingContext_isFramebuffer_Callback";

  bool isProgram(WebGLProgram program) {
    return _isProgram(program);
  }

  bool _isProgram(program) native "WebGLRenderingContext_isProgram_Callback";

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) {
    return _isRenderbuffer(renderbuffer);
  }

  bool _isRenderbuffer(renderbuffer) native "WebGLRenderingContext_isRenderbuffer_Callback";

  bool isShader(WebGLShader shader) {
    return _isShader(shader);
  }

  bool _isShader(shader) native "WebGLRenderingContext_isShader_Callback";

  bool isTexture(WebGLTexture texture) {
    return _isTexture(texture);
  }

  bool _isTexture(texture) native "WebGLRenderingContext_isTexture_Callback";

  void lineWidth(num width) {
    _lineWidth(width);
    return;
  }

  void _lineWidth(width) native "WebGLRenderingContext_lineWidth_Callback";

  void linkProgram(WebGLProgram program) {
    _linkProgram(program);
    return;
  }

  void _linkProgram(program) native "WebGLRenderingContext_linkProgram_Callback";

  void pixelStorei(int pname, int param) {
    _pixelStorei(pname, param);
    return;
  }

  void _pixelStorei(pname, param) native "WebGLRenderingContext_pixelStorei_Callback";

  void polygonOffset(num factor, num units) {
    _polygonOffset(factor, units);
    return;
  }

  void _polygonOffset(factor, units) native "WebGLRenderingContext_polygonOffset_Callback";

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) {
    _readPixels(x, y, width, height, format, type, pixels);
    return;
  }

  void _readPixels(x, y, width, height, format, type, pixels) native "WebGLRenderingContext_readPixels_Callback";

  void releaseShaderCompiler() {
    _releaseShaderCompiler();
    return;
  }

  void _releaseShaderCompiler() native "WebGLRenderingContext_releaseShaderCompiler_Callback";

  void renderbufferStorage(int target, int internalformat, int width, int height) {
    _renderbufferStorage(target, internalformat, width, height);
    return;
  }

  void _renderbufferStorage(target, internalformat, width, height) native "WebGLRenderingContext_renderbufferStorage_Callback";

  void sampleCoverage(num value, bool invert) {
    _sampleCoverage(value, invert);
    return;
  }

  void _sampleCoverage(value, invert) native "WebGLRenderingContext_sampleCoverage_Callback";

  void scissor(int x, int y, int width, int height) {
    _scissor(x, y, width, height);
    return;
  }

  void _scissor(x, y, width, height) native "WebGLRenderingContext_scissor_Callback";

  void shaderSource(WebGLShader shader, String string) {
    _shaderSource(shader, string);
    return;
  }

  void _shaderSource(shader, string) native "WebGLRenderingContext_shaderSource_Callback";

  void stencilFunc(int func, int ref, int mask) {
    _stencilFunc(func, ref, mask);
    return;
  }

  void _stencilFunc(func, ref, mask) native "WebGLRenderingContext_stencilFunc_Callback";

  void stencilFuncSeparate(int face, int func, int ref, int mask) {
    _stencilFuncSeparate(face, func, ref, mask);
    return;
  }

  void _stencilFuncSeparate(face, func, ref, mask) native "WebGLRenderingContext_stencilFuncSeparate_Callback";

  void stencilMask(int mask) {
    _stencilMask(mask);
    return;
  }

  void _stencilMask(mask) native "WebGLRenderingContext_stencilMask_Callback";

  void stencilMaskSeparate(int face, int mask) {
    _stencilMaskSeparate(face, mask);
    return;
  }

  void _stencilMaskSeparate(face, mask) native "WebGLRenderingContext_stencilMaskSeparate_Callback";

  void stencilOp(int fail, int zfail, int zpass) {
    _stencilOp(fail, zfail, zpass);
    return;
  }

  void _stencilOp(fail, zfail, zpass) native "WebGLRenderingContext_stencilOp_Callback";

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) {
    _stencilOpSeparate(face, fail, zfail, zpass);
    return;
  }

  void _stencilOpSeparate(face, fail, zfail, zpass) native "WebGLRenderingContext_stencilOpSeparate_Callback";

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format = null, int type = null, ArrayBufferView pixels = null]) {
    //
    // texImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, ArrayBufferView pixels)
    // texImage2D(int target, int level, int internalformat, int format, int type, ImageData pixels)
    // texImage2D(int target, int level, int internalformat, int format, int type, HTMLImageElement image)
    // texImage2D(int target, int level, int internalformat, int format, int type, HTMLCanvasElement canvas)
    // texImage2D(int target, int level, int internalformat, int format, int type, HTMLVideoElement video)
    //
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video === null || border_OR_canvas_OR_image_OR_pixels_OR_video is int)) {
      _texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video === null || border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData) &&
        format === null &&
        type === null &&
        pixels === null) {
      _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video === null || border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement) &&
        format === null &&
        type === null &&
        pixels === null) {
      _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video === null || border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement) &&
        format === null &&
        type === null &&
        pixels === null) {
      _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((border_OR_canvas_OR_image_OR_pixels_OR_video === null || border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement) &&
        format === null &&
        type === null &&
        pixels === null) {
      _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _texImage2D(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels) native "WebGLRenderingContext_texImage2D_Callback";

  void _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texImage2D_2_Callback";

  void _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texImage2D_3_Callback";

  void _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texImage2D_4_Callback";

  void _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texImage2D_5_Callback";

  void texParameterf(int target, int pname, num param) {
    _texParameterf(target, pname, param);
    return;
  }

  void _texParameterf(target, pname, param) native "WebGLRenderingContext_texParameterf_Callback";

  void texParameteri(int target, int pname, int param) {
    _texParameteri(target, pname, param);
    return;
  }

  void _texParameteri(target, pname, param) native "WebGLRenderingContext_texParameteri_Callback";

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type = null, ArrayBufferView pixels = null]) {
    //
    // texSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, ArrayBufferView pixels)
    // texSubImage2D(int target, int level, int xoffset, int yoffset, int format, int type, ImageData pixels)
    // texSubImage2D(int target, int level, int xoffset, int yoffset, int format, int type, HTMLImageElement image)
    // texSubImage2D(int target, int level, int xoffset, int yoffset, int format, int type, HTMLCanvasElement canvas)
    // texSubImage2D(int target, int level, int xoffset, int yoffset, int format, int type, HTMLVideoElement video)
    //
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video === null || canvas_OR_format_OR_image_OR_pixels_OR_video is int)) {
      _texSubImage2D(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video === null || canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData) &&
        type === null &&
        pixels === null) {
      _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video === null || canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement) &&
        type === null &&
        pixels === null) {
      _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video === null || canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement) &&
        type === null &&
        pixels === null) {
      _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    if ((canvas_OR_format_OR_image_OR_pixels_OR_video === null || canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement) &&
        type === null &&
        pixels === null) {
      _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _texSubImage2D(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels) native "WebGLRenderingContext_texSubImage2D_Callback";

  void _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texSubImage2D_2_Callback";

  void _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texSubImage2D_3_Callback";

  void _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texSubImage2D_4_Callback";

  void _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video) native "WebGLRenderingContext_texSubImage2D_5_Callback";

  void uniform1f(WebGLUniformLocation location, num x) {
    _uniform1f(location, x);
    return;
  }

  void _uniform1f(location, x) native "WebGLRenderingContext_uniform1f_Callback";

  void uniform1fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform1fv_Callback";

  void uniform1i(WebGLUniformLocation location, int x) {
    _uniform1i(location, x);
    return;
  }

  void _uniform1i(location, x) native "WebGLRenderingContext_uniform1i_Callback";

  void uniform1iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform1iv_Callback";

  void uniform2f(WebGLUniformLocation location, num x, num y) {
    _uniform2f(location, x, y);
    return;
  }

  void _uniform2f(location, x, y) native "WebGLRenderingContext_uniform2f_Callback";

  void uniform2fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform2fv_Callback";

  void uniform2i(WebGLUniformLocation location, int x, int y) {
    _uniform2i(location, x, y);
    return;
  }

  void _uniform2i(location, x, y) native "WebGLRenderingContext_uniform2i_Callback";

  void uniform2iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform2iv_Callback";

  void uniform3f(WebGLUniformLocation location, num x, num y, num z) {
    _uniform3f(location, x, y, z);
    return;
  }

  void _uniform3f(location, x, y, z) native "WebGLRenderingContext_uniform3f_Callback";

  void uniform3fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform3fv_Callback";

  void uniform3i(WebGLUniformLocation location, int x, int y, int z) {
    _uniform3i(location, x, y, z);
    return;
  }

  void _uniform3i(location, x, y, z) native "WebGLRenderingContext_uniform3i_Callback";

  void uniform3iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform3iv_Callback";

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) {
    _uniform4f(location, x, y, z, w);
    return;
  }

  void _uniform4f(location, x, y, z, w) native "WebGLRenderingContext_uniform4f_Callback";

  void uniform4fv(WebGLUniformLocation location, Float32Array v) native "WebGLRenderingContext_uniform4fv_Callback";

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) {
    _uniform4i(location, x, y, z, w);
    return;
  }

  void _uniform4i(location, x, y, z, w) native "WebGLRenderingContext_uniform4i_Callback";

  void uniform4iv(WebGLUniformLocation location, Int32Array v) native "WebGLRenderingContext_uniform4iv_Callback";

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) native "WebGLRenderingContext_uniformMatrix2fv_Callback";

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) native "WebGLRenderingContext_uniformMatrix3fv_Callback";

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) native "WebGLRenderingContext_uniformMatrix4fv_Callback";

  void useProgram(WebGLProgram program) {
    _useProgram(program);
    return;
  }

  void _useProgram(program) native "WebGLRenderingContext_useProgram_Callback";

  void validateProgram(WebGLProgram program) {
    _validateProgram(program);
    return;
  }

  void _validateProgram(program) native "WebGLRenderingContext_validateProgram_Callback";

  void vertexAttrib1f(int indx, num x) {
    _vertexAttrib1f(indx, x);
    return;
  }

  void _vertexAttrib1f(indx, x) native "WebGLRenderingContext_vertexAttrib1f_Callback";

  void vertexAttrib1fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib1fv_Callback";

  void vertexAttrib2f(int indx, num x, num y) {
    _vertexAttrib2f(indx, x, y);
    return;
  }

  void _vertexAttrib2f(indx, x, y) native "WebGLRenderingContext_vertexAttrib2f_Callback";

  void vertexAttrib2fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib2fv_Callback";

  void vertexAttrib3f(int indx, num x, num y, num z) {
    _vertexAttrib3f(indx, x, y, z);
    return;
  }

  void _vertexAttrib3f(indx, x, y, z) native "WebGLRenderingContext_vertexAttrib3f_Callback";

  void vertexAttrib3fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib3fv_Callback";

  void vertexAttrib4f(int indx, num x, num y, num z, num w) {
    _vertexAttrib4f(indx, x, y, z, w);
    return;
  }

  void _vertexAttrib4f(indx, x, y, z, w) native "WebGLRenderingContext_vertexAttrib4f_Callback";

  void vertexAttrib4fv(int indx, Float32Array values) native "WebGLRenderingContext_vertexAttrib4fv_Callback";

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) {
    _vertexAttribPointer(indx, size, type, normalized, stride, offset);
    return;
  }

  void _vertexAttribPointer(indx, size, type, normalized, stride, offset) native "WebGLRenderingContext_vertexAttribPointer_Callback";

  void viewport(int x, int y, int width, int height) {
    _viewport(x, y, width, height);
    return;
  }

  void _viewport(x, y, width, height) native "WebGLRenderingContext_viewport_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLShaderDOMImpl extends _DOMWrapperBase implements WebGLShader {
  _WebGLShaderDOMImpl();
  String get typeName() => "WebGLShader";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLShaderPrecisionFormatDOMImpl extends _DOMWrapperBase implements WebGLShaderPrecisionFormat {
  _WebGLShaderPrecisionFormatDOMImpl();
  String get typeName() => "WebGLShaderPrecisionFormat";

  int get precision() native "WebGLShaderPrecisionFormat_precision_Getter";

  int get rangeMax() native "WebGLShaderPrecisionFormat_rangeMax_Getter";

  int get rangeMin() native "WebGLShaderPrecisionFormat_rangeMin_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLTextureDOMImpl extends _DOMWrapperBase implements WebGLTexture {
  _WebGLTextureDOMImpl();
  String get typeName() => "WebGLTexture";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLUniformLocationDOMImpl extends _DOMWrapperBase implements WebGLUniformLocation {
  _WebGLUniformLocationDOMImpl();
  String get typeName() => "WebGLUniformLocation";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebGLVertexArrayObjectOESDOMImpl extends _DOMWrapperBase implements WebGLVertexArrayObjectOES {
  _WebGLVertexArrayObjectOESDOMImpl();
  String get typeName() => "WebGLVertexArrayObjectOES";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitAnimationEventDOMImpl extends _EventDOMImpl implements AnimationEvent {
  _WebKitAnimationEventDOMImpl();
  String get typeName() => "WebKitAnimationEvent";

  String get animationName() native "WebKitAnimationEvent_animationName_Getter";

  num get elapsedTime() native "WebKitAnimationEvent_elapsedTime_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitAnimationDOMImpl extends _DOMWrapperBase implements Animation {
  _WebKitAnimationDOMImpl();
  String get typeName() => "WebKitAnimation";

  num get delay() native "WebKitAnimation_delay_Getter";

  int get direction() native "WebKitAnimation_direction_Getter";

  num get duration() native "WebKitAnimation_duration_Getter";

  num get elapsedTime() native "WebKitAnimation_elapsedTime_Getter";

  void set elapsedTime(num) native "WebKitAnimation_elapsedTime_Setter";

  bool get ended() native "WebKitAnimation_ended_Getter";

  int get fillMode() native "WebKitAnimation_fillMode_Getter";

  int get iterationCount() native "WebKitAnimation_iterationCount_Getter";

  String get name() native "WebKitAnimation_name_Getter";

  bool get paused() native "WebKitAnimation_paused_Getter";

  void pause() {
    _pause();
    return;
  }

  void _pause() native "WebKitAnimation_pause_Callback";

  void play() {
    _play();
    return;
  }

  void _play() native "WebKitAnimation_play_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitAnimationListDOMImpl extends _DOMWrapperBase implements AnimationList {
  _WebKitAnimationListDOMImpl();
  String get typeName() => "WebKitAnimationList";

  int get length() native "WebKitAnimationList_length_Getter";

  Animation item(int index) {
    return _item(index);
  }

  Animation _item(index) native "WebKitAnimationList_item_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitCSSFilterValueDOMImpl extends _CSSValueListDOMImpl implements WebKitCSSFilterValue {
  _WebKitCSSFilterValueDOMImpl();
  String get typeName() => "WebKitCSSFilterValue";

  int get operationType() native "WebKitCSSFilterValue_operationType_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitCSSKeyframeRuleDOMImpl extends _CSSRuleDOMImpl implements CSSKeyframeRule {
  _WebKitCSSKeyframeRuleDOMImpl();
  String get typeName() => "WebKitCSSKeyframeRule";

  String get keyText() native "WebKitCSSKeyframeRule_keyText_Getter";

  void set keyText(String) native "WebKitCSSKeyframeRule_keyText_Setter";

  CSSStyleDeclaration get style() native "WebKitCSSKeyframeRule_style_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitCSSKeyframesRuleDOMImpl extends _CSSRuleDOMImpl implements CSSKeyframesRule {
  _WebKitCSSKeyframesRuleDOMImpl();
  String get typeName() => "WebKitCSSKeyframesRule";

  CSSRuleList get cssRules() native "WebKitCSSKeyframesRule_cssRules_Getter";

  String get name() native "WebKitCSSKeyframesRule_name_Getter";

  void set name(String) native "WebKitCSSKeyframesRule_name_Setter";

  void deleteRule(String key) {
    _deleteRule(key);
    return;
  }

  void _deleteRule(key) native "WebKitCSSKeyframesRule_deleteRule_Callback";

  CSSKeyframeRule findRule(String key) {
    return _findRule(key);
  }

  CSSKeyframeRule _findRule(key) native "WebKitCSSKeyframesRule_findRule_Callback";

  void insertRule(String rule) {
    _insertRule(rule);
    return;
  }

  void _insertRule(rule) native "WebKitCSSKeyframesRule_insertRule_Callback";

}
class _WebKitCSSMatrixFactoryProviderImpl {
  static _WebKitCSSMatrixDOMImpl createWebKitCSSMatrix([String cssValue = null])
      native "WebKitCSSMatrix_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitCSSMatrixDOMImpl extends _DOMWrapperBase implements CSSMatrix {
  _WebKitCSSMatrixDOMImpl();
  String get typeName() => "WebKitCSSMatrix";

  num get a() native "WebKitCSSMatrix_a_Getter";

  void set a(num) native "WebKitCSSMatrix_a_Setter";

  num get b() native "WebKitCSSMatrix_b_Getter";

  void set b(num) native "WebKitCSSMatrix_b_Setter";

  num get c() native "WebKitCSSMatrix_c_Getter";

  void set c(num) native "WebKitCSSMatrix_c_Setter";

  num get d() native "WebKitCSSMatrix_d_Getter";

  void set d(num) native "WebKitCSSMatrix_d_Setter";

  num get e() native "WebKitCSSMatrix_e_Getter";

  void set e(num) native "WebKitCSSMatrix_e_Setter";

  num get f() native "WebKitCSSMatrix_f_Getter";

  void set f(num) native "WebKitCSSMatrix_f_Setter";

  num get m11() native "WebKitCSSMatrix_m11_Getter";

  void set m11(num) native "WebKitCSSMatrix_m11_Setter";

  num get m12() native "WebKitCSSMatrix_m12_Getter";

  void set m12(num) native "WebKitCSSMatrix_m12_Setter";

  num get m13() native "WebKitCSSMatrix_m13_Getter";

  void set m13(num) native "WebKitCSSMatrix_m13_Setter";

  num get m14() native "WebKitCSSMatrix_m14_Getter";

  void set m14(num) native "WebKitCSSMatrix_m14_Setter";

  num get m21() native "WebKitCSSMatrix_m21_Getter";

  void set m21(num) native "WebKitCSSMatrix_m21_Setter";

  num get m22() native "WebKitCSSMatrix_m22_Getter";

  void set m22(num) native "WebKitCSSMatrix_m22_Setter";

  num get m23() native "WebKitCSSMatrix_m23_Getter";

  void set m23(num) native "WebKitCSSMatrix_m23_Setter";

  num get m24() native "WebKitCSSMatrix_m24_Getter";

  void set m24(num) native "WebKitCSSMatrix_m24_Setter";

  num get m31() native "WebKitCSSMatrix_m31_Getter";

  void set m31(num) native "WebKitCSSMatrix_m31_Setter";

  num get m32() native "WebKitCSSMatrix_m32_Getter";

  void set m32(num) native "WebKitCSSMatrix_m32_Setter";

  num get m33() native "WebKitCSSMatrix_m33_Getter";

  void set m33(num) native "WebKitCSSMatrix_m33_Setter";

  num get m34() native "WebKitCSSMatrix_m34_Getter";

  void set m34(num) native "WebKitCSSMatrix_m34_Setter";

  num get m41() native "WebKitCSSMatrix_m41_Getter";

  void set m41(num) native "WebKitCSSMatrix_m41_Setter";

  num get m42() native "WebKitCSSMatrix_m42_Getter";

  void set m42(num) native "WebKitCSSMatrix_m42_Setter";

  num get m43() native "WebKitCSSMatrix_m43_Getter";

  void set m43(num) native "WebKitCSSMatrix_m43_Setter";

  num get m44() native "WebKitCSSMatrix_m44_Getter";

  void set m44(num) native "WebKitCSSMatrix_m44_Setter";

  CSSMatrix inverse() {
    return _inverse();
  }

  CSSMatrix _inverse() native "WebKitCSSMatrix_inverse_Callback";

  CSSMatrix multiply(CSSMatrix secondMatrix) {
    if ((secondMatrix === null || secondMatrix is CSSMatrix)) {
      return _multiply(secondMatrix);
    }
    throw "Incorrect number or type of arguments";
  }

  CSSMatrix _multiply(secondMatrix) native "WebKitCSSMatrix_multiply_Callback";

  CSSMatrix rotate(num rotX, num rotY, num rotZ) {
    return _rotate(rotX, rotY, rotZ);
  }

  CSSMatrix _rotate(rotX, rotY, rotZ) native "WebKitCSSMatrix_rotate_Callback";

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle) {
    return _rotateAxisAngle(x, y, z, angle);
  }

  CSSMatrix _rotateAxisAngle(x, y, z, angle) native "WebKitCSSMatrix_rotateAxisAngle_Callback";

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ) {
    return _scale(scaleX, scaleY, scaleZ);
  }

  CSSMatrix _scale(scaleX, scaleY, scaleZ) native "WebKitCSSMatrix_scale_Callback";

  void setMatrixValue(String string) {
    _setMatrixValue(string);
    return;
  }

  void _setMatrixValue(string) native "WebKitCSSMatrix_setMatrixValue_Callback";

  CSSMatrix skewX(num angle) {
    return _skewX(angle);
  }

  CSSMatrix _skewX(angle) native "WebKitCSSMatrix_skewX_Callback";

  CSSMatrix skewY(num angle) {
    return _skewY(angle);
  }

  CSSMatrix _skewY(angle) native "WebKitCSSMatrix_skewY_Callback";

  String toString() {
    return _toString();
  }

  String _toString() native "WebKitCSSMatrix_toString_Callback";

  CSSMatrix translate(num x, num y, num z) {
    return _translate(x, y, z);
  }

  CSSMatrix _translate(x, y, z) native "WebKitCSSMatrix_translate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitCSSRegionRuleDOMImpl extends _CSSRuleDOMImpl implements WebKitCSSRegionRule {
  _WebKitCSSRegionRuleDOMImpl();
  String get typeName() => "WebKitCSSRegionRule";

  CSSRuleList get cssRules() native "WebKitCSSRegionRule_cssRules_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitCSSTransformValueDOMImpl extends _CSSValueListDOMImpl implements CSSTransformValue {
  _WebKitCSSTransformValueDOMImpl();
  String get typeName() => "WebKitCSSTransformValue";

  int get operationType() native "WebKitCSSTransformValue_operationType_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitMutationObserverDOMImpl extends _DOMWrapperBase implements WebKitMutationObserver {
  _WebKitMutationObserverDOMImpl();
  String get typeName() => "WebKitMutationObserver";

  void disconnect() {
    _disconnect();
    return;
  }

  void _disconnect() native "WebKitMutationObserver_disconnect_Callback";

  List<MutationRecord> takeRecords() {
    return _takeRecords();
  }

  List<MutationRecord> _takeRecords() native "WebKitMutationObserver_takeRecords_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitNamedFlowDOMImpl extends _DOMWrapperBase implements WebKitNamedFlow {
  _WebKitNamedFlowDOMImpl();
  String get typeName() => "WebKitNamedFlow";

  NodeList get contentNodes() native "WebKitNamedFlow_contentNodes_Getter";

  bool get overflow() native "WebKitNamedFlow_overflow_Getter";

  NodeList getRegionsByContentNode(Node contentNode) {
    return _getRegionsByContentNode(contentNode);
  }

  NodeList _getRegionsByContentNode(contentNode) native "WebKitNamedFlow_getRegionsByContentNode_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitPointDOMImpl extends _DOMWrapperBase implements Point {
  _WebKitPointDOMImpl();
  String get typeName() => "WebKitPoint";

  num get x() native "WebKitPoint_x_Getter";

  void set x(num) native "WebKitPoint_x_Setter";

  num get y() native "WebKitPoint_y_Getter";

  void set y(num) native "WebKitPoint_y_Setter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebKitTransitionEventDOMImpl extends _EventDOMImpl implements TransitionEvent {
  _WebKitTransitionEventDOMImpl();
  String get typeName() => "WebKitTransitionEvent";

  num get elapsedTime() native "WebKitTransitionEvent_elapsedTime_Getter";

  String get propertyName() native "WebKitTransitionEvent_propertyName_Getter";

}

class _WebSocketEventsImpl extends _EventsImpl implements WebSocketEvents {
  _WebSocketEventsImpl(_ptr) : super(_ptr);
  EventListenerList get close() => _get('close');
  EventListenerList get error() => _get('error');
  EventListenerList get message() => _get('message');
  EventListenerList get open() => _get('open');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WebSocketDOMImpl extends _DOMWrapperBase implements WebSocket {
  _WebSocketDOMImpl();
  String get typeName() => "WebSocket";
  _EventsImpl _on;

  _WebSocketEventsImpl get on() {
    if (_on === null) _on = new _WebSocketEventsImpl(this);
    return _on;
  }

  String get URL() native "WebSocket_URL_Getter";

  String get binaryType() native "WebSocket_binaryType_Getter";

  void set binaryType(String) native "WebSocket_binaryType_Setter";

  int get bufferedAmount() native "WebSocket_bufferedAmount_Getter";

  String get extensions() native "WebSocket_extensions_Getter";

  String get protocol() native "WebSocket_protocol_Getter";

  int get readyState() native "WebSocket_readyState_Getter";

  String get url() native "WebSocket_url_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "WebSocket_addEventListener_Callback";

  void close([int code = null, String reason = null]) native "WebSocket_close_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "WebSocket_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "WebSocket_removeEventListener_Callback";

  bool send(String data) native "WebSocket_send_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WheelEventDOMImpl extends _UIEventDOMImpl implements WheelEvent {
  _WheelEventDOMImpl();
  String get typeName() => "WheelEvent";

  bool get altKey() native "WheelEvent_altKey_Getter";

  int get clientX() native "WheelEvent_clientX_Getter";

  int get clientY() native "WheelEvent_clientY_Getter";

  bool get ctrlKey() native "WheelEvent_ctrlKey_Getter";

  bool get metaKey() native "WheelEvent_metaKey_Getter";

  int get offsetX() native "WheelEvent_offsetX_Getter";

  int get offsetY() native "WheelEvent_offsetY_Getter";

  int get screenX() native "WheelEvent_screenX_Getter";

  int get screenY() native "WheelEvent_screenY_Getter";

  bool get shiftKey() native "WheelEvent_shiftKey_Getter";

  bool get webkitDirectionInvertedFromDevice() native "WheelEvent_webkitDirectionInvertedFromDevice_Getter";

  int get wheelDelta() native "WheelEvent_wheelDelta_Getter";

  int get wheelDeltaX() native "WheelEvent_wheelDeltaX_Getter";

  int get wheelDeltaY() native "WheelEvent_wheelDeltaY_Getter";

  int get x() native "WheelEvent_x_Getter";

  int get y() native "WheelEvent_y_Getter";

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) {
    if ((view === null || view is Window)) {
      _initWebKitWheelEvent(wheelDeltaX, wheelDeltaY, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void _initWebKitWheelEvent(wheelDeltaX, wheelDeltaY, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey) native "WheelEvent_initWebKitWheelEvent_Callback";

}

class _WorkerContextEventsImpl extends _EventsImpl implements WorkerContextEvents {
  _WorkerContextEventsImpl(_ptr) : super(_ptr);
  EventListenerList get error() => _get('error');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WorkerContextDOMImpl extends _DOMWrapperBase implements WorkerContext {
  _WorkerContextDOMImpl();
  String get typeName() => "WorkerContext";
  _EventsImpl _on;

  _WorkerContextEventsImpl get on() {
    if (_on === null) _on = new _WorkerContextEventsImpl(this);
    return _on;
  }

  WorkerLocation get location() native "WorkerContext_location_Getter";

  WorkerNavigator get navigator() native "WorkerContext_navigator_Getter";

  WorkerContext get self() native "WorkerContext_self_Getter";

  IDBFactory get webkitIndexedDB() native "WorkerContext_webkitIndexedDB_Getter";

  NotificationCenter get webkitNotifications() native "WorkerContext_webkitNotifications_Getter";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "WorkerContext_addEventListener_Callback";

  void clearInterval(int handle) {
    _clearInterval(handle);
    return;
  }

  void _clearInterval(handle) native "WorkerContext_clearInterval_Callback";

  void clearTimeout(int handle) {
    _clearTimeout(handle);
    return;
  }

  void _clearTimeout(handle) native "WorkerContext_clearTimeout_Callback";

  void close() {
    _close();
    return;
  }

  void _close() native "WorkerContext_close_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "WorkerContext_dispatchEvent_Callback";

  void importScripts() native "WorkerContext_importScripts_Callback";

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    return _openDatabase(name, version, displayName, estimatedSize, creationCallback);
  }

  Database _openDatabase(name, version, displayName, estimatedSize, creationCallback) native "WorkerContext_openDatabase_Callback";

  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    return _openDatabaseSync(name, version, displayName, estimatedSize, creationCallback);
  }

  DatabaseSync _openDatabaseSync(name, version, displayName, estimatedSize, creationCallback) native "WorkerContext_openDatabaseSync_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "WorkerContext_removeEventListener_Callback";

  int setInterval(TimeoutHandler handler, int timeout) native "WorkerContext_setInterval_Callback";

  int setTimeout(TimeoutHandler handler, int timeout) native "WorkerContext_setTimeout_Callback";

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback = null, ErrorCallback errorCallback = null]) {
    _webkitRequestFileSystem(type, size, successCallback, errorCallback);
    return;
  }

  void _webkitRequestFileSystem(type, size, successCallback, errorCallback) native "WorkerContext_webkitRequestFileSystem_Callback";

  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size) {
    return _webkitRequestFileSystemSync(type, size);
  }

  DOMFileSystemSync _webkitRequestFileSystemSync(type, size) native "WorkerContext_webkitRequestFileSystemSync_Callback";

  EntrySync webkitResolveLocalFileSystemSyncURL(String url) {
    return _webkitResolveLocalFileSystemSyncURL(url);
  }

  EntrySync _webkitResolveLocalFileSystemSyncURL(url) native "WorkerContext_webkitResolveLocalFileSystemSyncURL_Callback";

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    _webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    return;
  }

  void _webkitResolveLocalFileSystemURL(url, successCallback, errorCallback) native "WorkerContext_webkitResolveLocalFileSystemURL_Callback";

}
class _WorkerFactoryProviderImpl {
  static _WorkerDOMImpl createWorker(String scriptUrl)
      native "Worker_constructor_Callback";
}
class _WorkerEventsImpl extends _AbstractWorkerEventsImpl implements WorkerEvents {
  _WorkerEventsImpl(_ptr) : super(_ptr);
  EventListenerList get message() => _get('message');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WorkerDOMImpl extends _AbstractWorkerDOMImpl implements Worker {
  _WorkerDOMImpl();
  String get typeName() => "Worker";

  _WorkerEventsImpl get on() {
    if (_on === null) _on = new _WorkerEventsImpl(this);
    return _on;
  }

  void postMessage(message, [List messagePorts = null]) native "Worker_postMessage_Callback";

  void terminate() {
    _terminate();
    return;
  }

  void _terminate() native "Worker_terminate_Callback";

  void webkitPostMessage(message, [List messagePorts = null]) native "Worker_webkitPostMessage_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WorkerLocationDOMImpl extends _DOMWrapperBase implements WorkerLocation {
  _WorkerLocationDOMImpl();
  String get typeName() => "WorkerLocation";

  String get hash() native "WorkerLocation_hash_Getter";

  String get host() native "WorkerLocation_host_Getter";

  String get hostname() native "WorkerLocation_hostname_Getter";

  String get href() native "WorkerLocation_href_Getter";

  String get pathname() native "WorkerLocation_pathname_Getter";

  String get port() native "WorkerLocation_port_Getter";

  String get protocol() native "WorkerLocation_protocol_Getter";

  String get search() native "WorkerLocation_search_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "WorkerLocation_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _WorkerNavigatorDOMImpl extends _DOMWrapperBase implements WorkerNavigator {
  _WorkerNavigatorDOMImpl();
  String get typeName() => "WorkerNavigator";

  String get appName() native "WorkerNavigator_appName_Getter";

  String get appVersion() native "WorkerNavigator_appVersion_Getter";

  bool get onLine() native "WorkerNavigator_onLine_Getter";

  String get platform() native "WorkerNavigator_platform_Getter";

  String get userAgent() native "WorkerNavigator_userAgent_Getter";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XMLHttpRequestExceptionDOMImpl extends _DOMWrapperBase implements XMLHttpRequestException {
  _XMLHttpRequestExceptionDOMImpl();
  String get typeName() => "XMLHttpRequestException";

  int get code() native "XMLHttpRequestException_code_Getter";

  String get message() native "XMLHttpRequestException_message_Getter";

  String get name() native "XMLHttpRequestException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "XMLHttpRequestException_toString_Callback";

}
class _XMLHttpRequestFactoryProviderImpl {
  static _XMLHttpRequestDOMImpl createXMLHttpRequest()
      native "XMLHttpRequest_constructor_Callback";
}
class _XMLHttpRequestEventsImpl extends _EventsImpl implements XMLHttpRequestEvents {
  _XMLHttpRequestEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get load() => _get('load');
  EventListenerList get loadEnd() => _get('loadend');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get progress() => _get('progress');
  EventListenerList get readyStateChange() => _get('readystatechange');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XMLHttpRequestDOMImpl extends _DOMWrapperBase implements XMLHttpRequest {
  _XMLHttpRequestDOMImpl();
  String get typeName() => "XMLHttpRequest";
  _EventsImpl _on;

  _XMLHttpRequestEventsImpl get on() {
    if (_on === null) _on = new _XMLHttpRequestEventsImpl(this);
    return _on;
  }

  bool get asBlob() native "XMLHttpRequest_asBlob_Getter";

  void set asBlob(bool) native "XMLHttpRequest_asBlob_Setter";

  int get readyState() native "XMLHttpRequest_readyState_Getter";

  Object get response() native "XMLHttpRequest_response_Getter";

  Blob get responseBlob() native "XMLHttpRequest_responseBlob_Getter";

  String get responseText() native "XMLHttpRequest_responseText_Getter";

  String get responseType() native "XMLHttpRequest_responseType_Getter";

  void set responseType(String) native "XMLHttpRequest_responseType_Setter";

  Document get responseXML() native "XMLHttpRequest_responseXML_Getter";

  int get status() native "XMLHttpRequest_status_Getter";

  String get statusText() native "XMLHttpRequest_statusText_Getter";

  XMLHttpRequestUpload get upload() native "XMLHttpRequest_upload_Getter";

  bool get withCredentials() native "XMLHttpRequest_withCredentials_Getter";

  void set withCredentials(bool) native "XMLHttpRequest_withCredentials_Setter";

  void abort() {
    _abort();
    return;
  }

  void _abort() native "XMLHttpRequest_abort_Callback";

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "XMLHttpRequest_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "XMLHttpRequest_dispatchEvent_Callback";

  String getAllResponseHeaders() {
    return _getAllResponseHeaders();
  }

  String _getAllResponseHeaders() native "XMLHttpRequest_getAllResponseHeaders_Callback";

  String getResponseHeader(String header) {
    return _getResponseHeader(header);
  }

  String _getResponseHeader(header) native "XMLHttpRequest_getResponseHeader_Callback";

  void open(String method, String url, [bool async = null, String user = null, String password = null]) native "XMLHttpRequest_open_Callback";

  void overrideMimeType(String override) {
    _overrideMimeType(override);
    return;
  }

  void _overrideMimeType(override) native "XMLHttpRequest_overrideMimeType_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "XMLHttpRequest_removeEventListener_Callback";

  void send([data = null]) native "XMLHttpRequest_send_Callback";

  void setRequestHeader(String header, String value) {
    _setRequestHeader(header, value);
    return;
  }

  void _setRequestHeader(header, value) native "XMLHttpRequest_setRequestHeader_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XMLHttpRequestProgressEventDOMImpl extends _ProgressEventDOMImpl implements XMLHttpRequestProgressEvent {
  _XMLHttpRequestProgressEventDOMImpl();
  String get typeName() => "XMLHttpRequestProgressEvent";

  int get position() native "XMLHttpRequestProgressEvent_position_Getter";

  int get totalSize() native "XMLHttpRequestProgressEvent_totalSize_Getter";

}

class _XMLHttpRequestUploadEventsImpl extends _EventsImpl implements XMLHttpRequestUploadEvents {
  _XMLHttpRequestUploadEventsImpl(_ptr) : super(_ptr);
  EventListenerList get abort() => _get('abort');
  EventListenerList get error() => _get('error');
  EventListenerList get load() => _get('load');
  EventListenerList get loadEnd() => _get('loadend');
  EventListenerList get loadStart() => _get('loadstart');
  EventListenerList get progress() => _get('progress');

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XMLHttpRequestUploadDOMImpl extends _DOMWrapperBase implements XMLHttpRequestUpload {
  _XMLHttpRequestUploadDOMImpl();
  String get typeName() => "XMLHttpRequestUpload";
  _EventsImpl _on;

  _XMLHttpRequestUploadEventsImpl get on() {
    if (_on === null) _on = new _XMLHttpRequestUploadEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // addEventListener(String type, EventListener listener)
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // addEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _addEventListener(type, listener, useCapture);
    return;
  }

  void _addEventListener(type, listener, useCapture) native "XMLHttpRequestUpload_addEventListener_Callback";

  bool $dom_dispatchEvent(Event evt) {
    return _dispatchEvent(evt);
  }

  bool _dispatchEvent(evt) native "XMLHttpRequestUpload_dispatchEvent_Callback";

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    //
    // removeEventListener(String type, EventListener listener)
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    // -- reduced:
    // removeEventListener(String type, EventListener listener, [Optional] bool useCapture)
    //
    _removeEventListener(type, listener, useCapture);
    return;
  }

  void _removeEventListener(type, listener, useCapture) native "XMLHttpRequestUpload_removeEventListener_Callback";

}
class _XMLSerializerFactoryProviderImpl {
  static _XMLSerializerDOMImpl createXMLSerializer()
      native "XMLSerializer_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XMLSerializerDOMImpl extends _DOMWrapperBase implements XMLSerializer {
  _XMLSerializerDOMImpl();
  String get typeName() => "XMLSerializer";

  String serializeToString(Node node) {
    return _serializeToString(node);
  }

  String _serializeToString(node) native "XMLSerializer_serializeToString_Callback";

}
class _XPathEvaluatorFactoryProviderImpl {
  static _XPathEvaluatorDOMImpl createXPathEvaluator()
      native "XPathEvaluator_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XPathEvaluatorDOMImpl extends _DOMWrapperBase implements XPathEvaluator {
  _XPathEvaluatorDOMImpl();
  String get typeName() => "XPathEvaluator";

  XPathExpression createExpression(String expression, XPathNSResolver resolver) {
    return _createExpression(expression, resolver);
  }

  XPathExpression _createExpression(expression, resolver) native "XPathEvaluator_createExpression_Callback";

  XPathNSResolver createNSResolver(Node nodeResolver) {
    return _createNSResolver(nodeResolver);
  }

  XPathNSResolver _createNSResolver(nodeResolver) native "XPathEvaluator_createNSResolver_Callback";

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) {
    return _evaluate(expression, contextNode, resolver, type, inResult);
  }

  XPathResult _evaluate(expression, contextNode, resolver, type, inResult) native "XPathEvaluator_evaluate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XPathExceptionDOMImpl extends _DOMWrapperBase implements XPathException {
  _XPathExceptionDOMImpl();
  String get typeName() => "XPathException";

  int get code() native "XPathException_code_Getter";

  String get message() native "XPathException_message_Getter";

  String get name() native "XPathException_name_Getter";

  String toString() {
    return _toString();
  }

  String _toString() native "XPathException_toString_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XPathExpressionDOMImpl extends _DOMWrapperBase implements XPathExpression {
  _XPathExpressionDOMImpl();
  String get typeName() => "XPathExpression";

  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) {
    return _evaluate(contextNode, type, inResult);
  }

  XPathResult _evaluate(contextNode, type, inResult) native "XPathExpression_evaluate_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XPathNSResolverDOMImpl extends _DOMWrapperBase implements XPathNSResolver {
  _XPathNSResolverDOMImpl();
  String get typeName() => "XPathNSResolver";

  String lookupNamespaceURI(String prefix) {
    return _lookupNamespaceURI(prefix);
  }

  String _lookupNamespaceURI(prefix) native "XPathNSResolver_lookupNamespaceURI_Callback";

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XPathResultDOMImpl extends _DOMWrapperBase implements XPathResult {
  _XPathResultDOMImpl();
  String get typeName() => "XPathResult";

  bool get booleanValue() native "XPathResult_booleanValue_Getter";

  bool get invalidIteratorState() native "XPathResult_invalidIteratorState_Getter";

  num get numberValue() native "XPathResult_numberValue_Getter";

  int get resultType() native "XPathResult_resultType_Getter";

  Node get singleNodeValue() native "XPathResult_singleNodeValue_Getter";

  int get snapshotLength() native "XPathResult_snapshotLength_Getter";

  String get stringValue() native "XPathResult_stringValue_Getter";

  Node iterateNext() {
    return _iterateNext();
  }

  Node _iterateNext() native "XPathResult_iterateNext_Callback";

  Node snapshotItem(int index) {
    return _snapshotItem(index);
  }

  Node _snapshotItem(index) native "XPathResult_snapshotItem_Callback";

}
class _XSLTProcessorFactoryProviderImpl {
  static _XSLTProcessorDOMImpl createXSLTProcessor()
      native "XSLTProcessor_constructor_Callback";
}// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

class _XSLTProcessorDOMImpl extends _DOMWrapperBase implements XSLTProcessor {
  _XSLTProcessorDOMImpl();
  String get typeName() => "XSLTProcessor";

  void clearParameters() {
    _clearParameters();
    return;
  }

  void _clearParameters() native "XSLTProcessor_clearParameters_Callback";

  String getParameter(String namespaceURI, String localName) native "XSLTProcessor_getParameter_Callback";

  void importStylesheet(Node stylesheet) native "XSLTProcessor_importStylesheet_Callback";

  void removeParameter(String namespaceURI, String localName) native "XSLTProcessor_removeParameter_Callback";

  void reset() {
    _reset();
    return;
  }

  void _reset() native "XSLTProcessor_reset_Callback";

  void setParameter(String namespaceURI, String localName, String value) native "XSLTProcessor_setParameter_Callback";

  Document transformToDocument(Node source) native "XSLTProcessor_transformToDocument_Callback";

  DocumentFragment transformToFragment(Node source, Document docVal) native "XSLTProcessor_transformToFragment_Callback";

}

class _AbstractWorkerImpl extends _EventTargetImpl implements AbstractWorker {
  _AbstractWorkerImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _AnchorElementImpl extends _ElementImpl implements AnchorElement {
  _AnchorElementImpl._wrap(ptr) : super._wrap(ptr);

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get coords() => _wrap(_ptr.coords);

  void set coords(String value) { _ptr.coords = _unwrap(value); }

  String get download() => _wrap(_ptr.download);

  void set download(String value) { _ptr.download = _unwrap(value); }

  String get hash() => _wrap(_ptr.hash);

  void set hash(String value) { _ptr.hash = _unwrap(value); }

  String get host() => _wrap(_ptr.host);

  void set host(String value) { _ptr.host = _unwrap(value); }

  String get hostname() => _wrap(_ptr.hostname);

  void set hostname(String value) { _ptr.hostname = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get hreflang() => _wrap(_ptr.hreflang);

  void set hreflang(String value) { _ptr.hreflang = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get origin() => _wrap(_ptr.origin);

  String get pathname() => _wrap(_ptr.pathname);

  void set pathname(String value) { _ptr.pathname = _unwrap(value); }

  String get ping() => _wrap(_ptr.ping);

  void set ping(String value) { _ptr.ping = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  void set port(String value) { _ptr.port = _unwrap(value); }

  String get protocol() => _wrap(_ptr.protocol);

  void set protocol(String value) { _ptr.protocol = _unwrap(value); }

  String get rel() => _wrap(_ptr.rel);

  void set rel(String value) { _ptr.rel = _unwrap(value); }

  String get rev() => _wrap(_ptr.rev);

  void set rev(String value) { _ptr.rev = _unwrap(value); }

  String get search() => _wrap(_ptr.search);

  void set search(String value) { _ptr.search = _unwrap(value); }

  String get shape() => _wrap(_ptr.shape);

  void set shape(String value) { _ptr.shape = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String toString() => _wrap(_ptr.toString());
}

class _AnimationImpl extends _DOMTypeBase implements Animation {
  _AnimationImpl._wrap(ptr) : super._wrap(ptr);

  num get delay() => _wrap(_ptr.delay);

  int get direction() => _wrap(_ptr.direction);

  num get duration() => _wrap(_ptr.duration);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);

  void set elapsedTime(num value) { _ptr.elapsedTime = _unwrap(value); }

  bool get ended() => _wrap(_ptr.ended);

  int get fillMode() => _wrap(_ptr.fillMode);

  int get iterationCount() => _wrap(_ptr.iterationCount);

  String get name() => _wrap(_ptr.name);

  bool get paused() => _wrap(_ptr.paused);

  void pause() => _ptr.pause();

  void play() => _ptr.play();
}

class _AnimationEventImpl extends _EventImpl implements AnimationEvent {
  _AnimationEventImpl._wrap(ptr) : super._wrap(ptr);

  String get animationName() => _wrap(_ptr.animationName);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);
}

class _AnimationListImpl extends _DOMTypeBase implements AnimationList {
  _AnimationListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Animation item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _AppletElementImpl extends _ElementImpl implements AppletElement {
  _AppletElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get archive() => _wrap(_ptr.archive);

  void set archive(String value) { _ptr.archive = _unwrap(value); }

  String get code() => _wrap(_ptr.code);

  void set code(String value) { _ptr.code = _unwrap(value); }

  String get codeBase() => _wrap(_ptr.codeBase);

  void set codeBase(String value) { _ptr.codeBase = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get hspace() => _wrap(_ptr.hspace);

  void set hspace(String value) { _ptr.hspace = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get object() => _wrap(_ptr.object);

  void set object(String value) { _ptr.object = _unwrap(value); }

  String get vspace() => _wrap(_ptr.vspace);

  void set vspace(String value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _AreaElementImpl extends _ElementImpl implements AreaElement {
  _AreaElementImpl._wrap(ptr) : super._wrap(ptr);

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get coords() => _wrap(_ptr.coords);

  void set coords(String value) { _ptr.coords = _unwrap(value); }

  String get hash() => _wrap(_ptr.hash);

  String get host() => _wrap(_ptr.host);

  String get hostname() => _wrap(_ptr.hostname);

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  bool get noHref() => _wrap(_ptr.noHref);

  void set noHref(bool value) { _ptr.noHref = _unwrap(value); }

  String get pathname() => _wrap(_ptr.pathname);

  String get ping() => _wrap(_ptr.ping);

  void set ping(String value) { _ptr.ping = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  String get protocol() => _wrap(_ptr.protocol);

  String get search() => _wrap(_ptr.search);

  String get shape() => _wrap(_ptr.shape);

  void set shape(String value) { _ptr.shape = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }
}

class _ArrayBufferImpl extends _DOMTypeBase implements ArrayBuffer {
  _ArrayBufferImpl._wrap(ptr) : super._wrap(ptr);

  int get byteLength() => _wrap(_ptr.byteLength);

  ArrayBuffer slice(int begin, [int end = null]) => _wrap(_ptr.slice(_unwrap(begin), _unwrap(end)));
}

class _ArrayBufferViewImpl extends _DOMTypeBase implements ArrayBufferView {
  _ArrayBufferViewImpl._wrap(ptr) : super._wrap(ptr);

  ArrayBuffer get buffer() => _wrap(_ptr.buffer);

  int get byteLength() => _wrap(_ptr.byteLength);

  int get byteOffset() => _wrap(_ptr.byteOffset);
}

class _AttrImpl extends _NodeImpl implements Attr {
  _AttrImpl._wrap(ptr) : super._wrap(ptr);

  bool get isId() => _wrap(_ptr.isId);

  String get name() => _wrap(_ptr.name);

  Element get ownerElement() => _wrap(_ptr.ownerElement);

  bool get specified() => _wrap(_ptr.specified);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _AudioBufferImpl extends _DOMTypeBase implements AudioBuffer {
  _AudioBufferImpl._wrap(ptr) : super._wrap(ptr);

  num get duration() => _wrap(_ptr.duration);

  num get gain() => _wrap(_ptr.gain);

  void set gain(num value) { _ptr.gain = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  int get numberOfChannels() => _wrap(_ptr.numberOfChannels);

  num get sampleRate() => _wrap(_ptr.sampleRate);

  Float32Array getChannelData(int channelIndex) => _wrap(_ptr.getChannelData(_unwrap(channelIndex)));
}

class _AudioBufferSourceNodeImpl extends _AudioSourceNodeImpl implements AudioBufferSourceNode {
  _AudioBufferSourceNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get buffer() => _wrap(_ptr.buffer);

  void set buffer(AudioBuffer value) { _ptr.buffer = _unwrap(value); }

  AudioGain get gain() => _wrap(_ptr.gain);

  bool get loop() => _wrap(_ptr.loop);

  void set loop(bool value) { _ptr.loop = _unwrap(value); }

  bool get looping() => _wrap(_ptr.looping);

  void set looping(bool value) { _ptr.looping = _unwrap(value); }

  AudioParam get playbackRate() => _wrap(_ptr.playbackRate);

  int get playbackState() => _wrap(_ptr.playbackState);

  void noteGrainOn(num when, num grainOffset, num grainDuration) => _ptr.noteGrainOn(_unwrap(when), _unwrap(grainOffset), _unwrap(grainDuration));

  void noteOff(num when) => _ptr.noteOff(_unwrap(when));

  void noteOn(num when) => _ptr.noteOn(_unwrap(when));
}

class _AudioChannelMergerImpl extends _AudioNodeImpl implements AudioChannelMerger {
  _AudioChannelMergerImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioChannelSplitterImpl extends _AudioNodeImpl implements AudioChannelSplitter {
  _AudioChannelSplitterImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioContextImpl extends _EventTargetImpl implements AudioContext {
  _AudioContextImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get activeSourceCount() => _wrap(_ptr.activeSourceCount);

  num get currentTime() => _wrap(_ptr.currentTime);

  AudioDestinationNode get destination() => _wrap(_ptr.destination);

  AudioListener get listener() => _wrap(_ptr.listener);

  num get sampleRate() => _wrap(_ptr.sampleRate);

  RealtimeAnalyserNode createAnalyser() => _wrap(_ptr.createAnalyser());

  BiquadFilterNode createBiquadFilter() => _wrap(_ptr.createBiquadFilter());

  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate = null]) => _wrap(_ptr.createBuffer(_unwrap(buffer_OR_numberOfChannels), _unwrap(mixToMono_OR_numberOfFrames), _unwrap(sampleRate)));

  AudioBufferSourceNode createBufferSource() => _wrap(_ptr.createBufferSource());

  AudioChannelMerger createChannelMerger([int numberOfInputs = null]) => _wrap(_ptr.createChannelMerger(_unwrap(numberOfInputs)));

  AudioChannelSplitter createChannelSplitter([int numberOfOutputs = null]) => _wrap(_ptr.createChannelSplitter(_unwrap(numberOfOutputs)));

  ConvolverNode createConvolver() => _wrap(_ptr.createConvolver());

  DelayNode createDelayNode([num maxDelayTime = null]) => _wrap(_ptr.createDelayNode(_unwrap(maxDelayTime)));

  DynamicsCompressorNode createDynamicsCompressor() => _wrap(_ptr.createDynamicsCompressor());

  AudioGainNode createGainNode() => _wrap(_ptr.createGainNode());

  JavaScriptAudioNode createJavaScriptNode(int bufferSize, [int numberOfInputChannels = null, int numberOfOutputChannels = null]) => _wrap(_ptr.createJavaScriptNode(_unwrap(bufferSize), _unwrap(numberOfInputChannels), _unwrap(numberOfOutputChannels)));

  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement) => _wrap(_ptr.createMediaElementSource(_unwrap(mediaElement)));

  Oscillator createOscillator() => _wrap(_ptr.createOscillator());

  AudioPannerNode createPanner() => _wrap(_ptr.createPanner());

  WaveShaperNode createWaveShaper() => _wrap(_ptr.createWaveShaper());

  WaveTable createWaveTable(Float32Array real, Float32Array imag) => _wrap(_ptr.createWaveTable(_unwrap(real), _unwrap(imag)));

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback = null]) => _ptr.decodeAudioData(_unwrap(audioData), _unwrap(successCallback), _unwrap(errorCallback));

  void startRendering() => _ptr.startRendering();
}

class _AudioDestinationNodeImpl extends _AudioNodeImpl implements AudioDestinationNode {
  _AudioDestinationNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfChannels() => _wrap(_ptr.numberOfChannels);
}

class _AudioElementImpl extends _MediaElementImpl implements AudioElement {
  _AudioElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioGainImpl extends _AudioParamImpl implements AudioGain {
  _AudioGainImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioGainNodeImpl extends _AudioNodeImpl implements AudioGainNode {
  _AudioGainNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioGain get gain() => _wrap(_ptr.gain);
}

class _AudioListenerImpl extends _DOMTypeBase implements AudioListener {
  _AudioListenerImpl._wrap(ptr) : super._wrap(ptr);

  num get dopplerFactor() => _wrap(_ptr.dopplerFactor);

  void set dopplerFactor(num value) { _ptr.dopplerFactor = _unwrap(value); }

  num get speedOfSound() => _wrap(_ptr.speedOfSound);

  void set speedOfSound(num value) { _ptr.speedOfSound = _unwrap(value); }

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) => _ptr.setOrientation(_unwrap(x), _unwrap(y), _unwrap(z), _unwrap(xUp), _unwrap(yUp), _unwrap(zUp));

  void setPosition(num x, num y, num z) => _ptr.setPosition(_unwrap(x), _unwrap(y), _unwrap(z));

  void setVelocity(num x, num y, num z) => _ptr.setVelocity(_unwrap(x), _unwrap(y), _unwrap(z));
}

class _AudioNodeImpl extends _DOMTypeBase implements AudioNode {
  _AudioNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioContext get context() => _wrap(_ptr.context);

  int get numberOfInputs() => _wrap(_ptr.numberOfInputs);

  int get numberOfOutputs() => _wrap(_ptr.numberOfOutputs);

  void connect(destination, int output, [int input = null]) => _ptr.connect(_unwrap(destination), _unwrap(output), _unwrap(input));

  void disconnect(int output) => _ptr.disconnect(_unwrap(output));
}

class _AudioPannerNodeImpl extends _AudioNodeImpl implements AudioPannerNode {
  _AudioPannerNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioGain get coneGain() => _wrap(_ptr.coneGain);

  num get coneInnerAngle() => _wrap(_ptr.coneInnerAngle);

  void set coneInnerAngle(num value) { _ptr.coneInnerAngle = _unwrap(value); }

  num get coneOuterAngle() => _wrap(_ptr.coneOuterAngle);

  void set coneOuterAngle(num value) { _ptr.coneOuterAngle = _unwrap(value); }

  num get coneOuterGain() => _wrap(_ptr.coneOuterGain);

  void set coneOuterGain(num value) { _ptr.coneOuterGain = _unwrap(value); }

  AudioGain get distanceGain() => _wrap(_ptr.distanceGain);

  int get distanceModel() => _wrap(_ptr.distanceModel);

  void set distanceModel(int value) { _ptr.distanceModel = _unwrap(value); }

  num get maxDistance() => _wrap(_ptr.maxDistance);

  void set maxDistance(num value) { _ptr.maxDistance = _unwrap(value); }

  int get panningModel() => _wrap(_ptr.panningModel);

  void set panningModel(int value) { _ptr.panningModel = _unwrap(value); }

  num get refDistance() => _wrap(_ptr.refDistance);

  void set refDistance(num value) { _ptr.refDistance = _unwrap(value); }

  num get rolloffFactor() => _wrap(_ptr.rolloffFactor);

  void set rolloffFactor(num value) { _ptr.rolloffFactor = _unwrap(value); }

  void setOrientation(num x, num y, num z) => _ptr.setOrientation(_unwrap(x), _unwrap(y), _unwrap(z));

  void setPosition(num x, num y, num z) => _ptr.setPosition(_unwrap(x), _unwrap(y), _unwrap(z));

  void setVelocity(num x, num y, num z) => _ptr.setVelocity(_unwrap(x), _unwrap(y), _unwrap(z));
}

class _AudioParamImpl extends _DOMTypeBase implements AudioParam {
  _AudioParamImpl._wrap(ptr) : super._wrap(ptr);

  num get defaultValue() => _wrap(_ptr.defaultValue);

  num get maxValue() => _wrap(_ptr.maxValue);

  num get minValue() => _wrap(_ptr.minValue);

  String get name() => _wrap(_ptr.name);

  int get units() => _wrap(_ptr.units);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  void cancelScheduledValues(num startTime) => _ptr.cancelScheduledValues(_unwrap(startTime));

  void exponentialRampToValueAtTime(num value, num time) => _ptr.exponentialRampToValueAtTime(_unwrap(value), _unwrap(time));

  void linearRampToValueAtTime(num value, num time) => _ptr.linearRampToValueAtTime(_unwrap(value), _unwrap(time));

  void setTargetValueAtTime(num targetValue, num time, num timeConstant) => _ptr.setTargetValueAtTime(_unwrap(targetValue), _unwrap(time), _unwrap(timeConstant));

  void setValueAtTime(num value, num time) => _ptr.setValueAtTime(_unwrap(value), _unwrap(time));

  void setValueCurveAtTime(Float32Array values, num time, num duration) => _ptr.setValueCurveAtTime(_unwrap(values), _unwrap(time), _unwrap(duration));
}

class _AudioProcessingEventImpl extends _EventImpl implements AudioProcessingEvent {
  _AudioProcessingEventImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get inputBuffer() => _wrap(_ptr.inputBuffer);

  AudioBuffer get outputBuffer() => _wrap(_ptr.outputBuffer);
}

class _AudioSourceNodeImpl extends _AudioNodeImpl implements AudioSourceNode {
  _AudioSourceNodeImpl._wrap(ptr) : super._wrap(ptr);
}

class _BRElementImpl extends _ElementImpl implements BRElement {
  _BRElementImpl._wrap(ptr) : super._wrap(ptr);

  String get clear() => _wrap(_ptr.clear);

  void set clear(String value) { _ptr.clear = _unwrap(value); }
}

class _BarInfoImpl extends _DOMTypeBase implements BarInfo {
  _BarInfoImpl._wrap(ptr) : super._wrap(ptr);

  bool get visible() => _wrap(_ptr.visible);
}

class _BaseElementImpl extends _ElementImpl implements BaseElement {
  _BaseElementImpl._wrap(ptr) : super._wrap(ptr);

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }
}

class _BaseFontElementImpl extends _ElementImpl implements BaseFontElement {
  _BaseFontElementImpl._wrap(ptr) : super._wrap(ptr);

  String get color() => _wrap(_ptr.color);

  void set color(String value) { _ptr.color = _unwrap(value); }

  String get face() => _wrap(_ptr.face);

  void set face(String value) { _ptr.face = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }
}

class _BatteryManagerImpl extends _EventTargetImpl implements BatteryManager {
  _BatteryManagerImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  bool get charging() => _wrap(_ptr.charging);

  num get chargingTime() => _wrap(_ptr.chargingTime);

  num get dischargingTime() => _wrap(_ptr.dischargingTime);

  num get level() => _wrap(_ptr.level);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _BeforeLoadEventImpl extends _EventImpl implements BeforeLoadEvent {
  _BeforeLoadEventImpl._wrap(ptr) : super._wrap(ptr);

  String get url() => _wrap(_ptr.url);
}

class _BiquadFilterNodeImpl extends _AudioNodeImpl implements BiquadFilterNode {
  _BiquadFilterNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get Q() => _wrap(_ptr.Q);

  AudioParam get frequency() => _wrap(_ptr.frequency);

  AudioParam get gain() => _wrap(_ptr.gain);

  int get type() => _wrap(_ptr.type);

  void set type(int value) { _ptr.type = _unwrap(value); }

  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse) => _ptr.getFrequencyResponse(_unwrap(frequencyHz), _unwrap(magResponse), _unwrap(phaseResponse));
}

class _BlobImpl extends _DOMTypeBase implements Blob {
  _BlobImpl._wrap(ptr) : super._wrap(ptr);

  int get size() => _wrap(_ptr.size);

  String get type() => _wrap(_ptr.type);

  Blob webkitSlice([int start = null, int end = null, String contentType = null]) => _wrap(_ptr.webkitSlice(_unwrap(start), _unwrap(end), _unwrap(contentType)));
}

class _BodyElementImpl extends _ElementImpl implements BodyElement {
  _BodyElementImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get aLink() => _wrap(_ptr.aLink);

  void set aLink(String value) { _ptr.aLink = _unwrap(value); }

  String get background() => _wrap(_ptr.background);

  void set background(String value) { _ptr.background = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get link() => _wrap(_ptr.link);

  void set link(String value) { _ptr.link = _unwrap(value); }

  String get vLink() => _wrap(_ptr.vLink);

  void set vLink(String value) { _ptr.vLink = _unwrap(value); }
}

class _ButtonElementImpl extends _ElementImpl implements ButtonElement {
  _ButtonElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get formAction() => _wrap(_ptr.formAction);

  void set formAction(String value) { _ptr.formAction = _unwrap(value); }

  String get formEnctype() => _wrap(_ptr.formEnctype);

  void set formEnctype(String value) { _ptr.formEnctype = _unwrap(value); }

  String get formMethod() => _wrap(_ptr.formMethod);

  void set formMethod(String value) { _ptr.formMethod = _unwrap(value); }

  bool get formNoValidate() => _wrap(_ptr.formNoValidate);

  void set formNoValidate(bool value) { _ptr.formNoValidate = _unwrap(value); }

  String get formTarget() => _wrap(_ptr.formTarget);

  void set formTarget(String value) { _ptr.formTarget = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));
}

class _CDATASectionImpl extends _TextImpl implements CDATASection {
  _CDATASectionImpl._wrap(ptr) : super._wrap(ptr);
}

class _CSSCharsetRuleImpl extends _CSSRuleImpl implements CSSCharsetRule {
  _CSSCharsetRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get encoding() => _wrap(_ptr.encoding);

  void set encoding(String value) { _ptr.encoding = _unwrap(value); }
}

class _CSSFontFaceRuleImpl extends _CSSRuleImpl implements CSSFontFaceRule {
  _CSSFontFaceRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSImportRuleImpl extends _CSSRuleImpl implements CSSImportRule {
  _CSSImportRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get href() => _wrap(_ptr.href);

  MediaList get media() => _wrap(_ptr.media);

  CSSStyleSheet get styleSheet() => _wrap(_ptr.styleSheet);
}

class _CSSKeyframeRuleImpl extends _CSSRuleImpl implements CSSKeyframeRule {
  _CSSKeyframeRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get keyText() => _wrap(_ptr.keyText);

  void set keyText(String value) { _ptr.keyText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSKeyframesRuleImpl extends _CSSRuleImpl implements CSSKeyframesRule {
  _CSSKeyframesRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  void deleteRule(String key) => _ptr.deleteRule(_unwrap(key));

  CSSKeyframeRule findRule(String key) => _wrap(_ptr.findRule(_unwrap(key)));

  void insertRule(String rule) => _ptr.insertRule(_unwrap(rule));
}

class _CSSMatrixImpl extends _DOMTypeBase implements CSSMatrix {
  _CSSMatrixImpl._wrap(ptr) : super._wrap(ptr);

  num get a() => _wrap(_ptr.a);

  void set a(num value) { _ptr.a = _unwrap(value); }

  num get b() => _wrap(_ptr.b);

  void set b(num value) { _ptr.b = _unwrap(value); }

  num get c() => _wrap(_ptr.c);

  void set c(num value) { _ptr.c = _unwrap(value); }

  num get d() => _wrap(_ptr.d);

  void set d(num value) { _ptr.d = _unwrap(value); }

  num get e() => _wrap(_ptr.e);

  void set e(num value) { _ptr.e = _unwrap(value); }

  num get f() => _wrap(_ptr.f);

  void set f(num value) { _ptr.f = _unwrap(value); }

  num get m11() => _wrap(_ptr.m11);

  void set m11(num value) { _ptr.m11 = _unwrap(value); }

  num get m12() => _wrap(_ptr.m12);

  void set m12(num value) { _ptr.m12 = _unwrap(value); }

  num get m13() => _wrap(_ptr.m13);

  void set m13(num value) { _ptr.m13 = _unwrap(value); }

  num get m14() => _wrap(_ptr.m14);

  void set m14(num value) { _ptr.m14 = _unwrap(value); }

  num get m21() => _wrap(_ptr.m21);

  void set m21(num value) { _ptr.m21 = _unwrap(value); }

  num get m22() => _wrap(_ptr.m22);

  void set m22(num value) { _ptr.m22 = _unwrap(value); }

  num get m23() => _wrap(_ptr.m23);

  void set m23(num value) { _ptr.m23 = _unwrap(value); }

  num get m24() => _wrap(_ptr.m24);

  void set m24(num value) { _ptr.m24 = _unwrap(value); }

  num get m31() => _wrap(_ptr.m31);

  void set m31(num value) { _ptr.m31 = _unwrap(value); }

  num get m32() => _wrap(_ptr.m32);

  void set m32(num value) { _ptr.m32 = _unwrap(value); }

  num get m33() => _wrap(_ptr.m33);

  void set m33(num value) { _ptr.m33 = _unwrap(value); }

  num get m34() => _wrap(_ptr.m34);

  void set m34(num value) { _ptr.m34 = _unwrap(value); }

  num get m41() => _wrap(_ptr.m41);

  void set m41(num value) { _ptr.m41 = _unwrap(value); }

  num get m42() => _wrap(_ptr.m42);

  void set m42(num value) { _ptr.m42 = _unwrap(value); }

  num get m43() => _wrap(_ptr.m43);

  void set m43(num value) { _ptr.m43 = _unwrap(value); }

  num get m44() => _wrap(_ptr.m44);

  void set m44(num value) { _ptr.m44 = _unwrap(value); }

  CSSMatrix inverse() => _wrap(_ptr.inverse());

  CSSMatrix multiply(CSSMatrix secondMatrix) => _wrap(_ptr.multiply(_unwrap(secondMatrix)));

  CSSMatrix rotate(num rotX, num rotY, num rotZ) => _wrap(_ptr.rotate(_unwrap(rotX), _unwrap(rotY), _unwrap(rotZ)));

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle) => _wrap(_ptr.rotateAxisAngle(_unwrap(x), _unwrap(y), _unwrap(z), _unwrap(angle)));

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ) => _wrap(_ptr.scale(_unwrap(scaleX), _unwrap(scaleY), _unwrap(scaleZ)));

  void setMatrixValue(String string) => _ptr.setMatrixValue(_unwrap(string));

  CSSMatrix skewX(num angle) => _wrap(_ptr.skewX(_unwrap(angle)));

  CSSMatrix skewY(num angle) => _wrap(_ptr.skewY(_unwrap(angle)));

  String toString() => _wrap(_ptr.toString());

  CSSMatrix translate(num x, num y, num z) => _wrap(_ptr.translate(_unwrap(x), _unwrap(y), _unwrap(z)));
}

class _CSSMediaRuleImpl extends _CSSRuleImpl implements CSSMediaRule {
  _CSSMediaRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  MediaList get media() => _wrap(_ptr.media);

  void deleteRule(int index) => _ptr.deleteRule(_unwrap(index));

  int insertRule(String rule, int index) => _wrap(_ptr.insertRule(_unwrap(rule), _unwrap(index)));
}

class _CSSPageRuleImpl extends _CSSRuleImpl implements CSSPageRule {
  _CSSPageRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get selectorText() => _wrap(_ptr.selectorText);

  void set selectorText(String value) { _ptr.selectorText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSPrimitiveValueImpl extends _CSSValueImpl implements CSSPrimitiveValue {
  _CSSPrimitiveValueImpl._wrap(ptr) : super._wrap(ptr);

  int get primitiveType() => _wrap(_ptr.primitiveType);

  Counter getCounterValue() => _wrap(_ptr.getCounterValue());

  num getFloatValue(int unitType) => _wrap(_ptr.getFloatValue(_unwrap(unitType)));

  RGBColor getRGBColorValue() => _wrap(_ptr.getRGBColorValue());

  Rect getRectValue() => _wrap(_ptr.getRectValue());

  String getStringValue() => _wrap(_ptr.getStringValue());

  void setFloatValue(int unitType, num floatValue) => _ptr.setFloatValue(_unwrap(unitType), _unwrap(floatValue));

  void setStringValue(int stringType, String stringValue) => _ptr.setStringValue(_unwrap(stringType), _unwrap(stringValue));
}

class _CSSRuleImpl extends _DOMTypeBase implements CSSRule {
  _CSSRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  CSSRule get parentRule() => _wrap(_ptr.parentRule);

  CSSStyleSheet get parentStyleSheet() => _wrap(_ptr.parentStyleSheet);

  int get type() => _wrap(_ptr.type);
}

class _CSSRuleListImpl extends _DOMTypeBase implements CSSRuleList {
  _CSSRuleListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  CSSRule item(int index) => _wrap(_ptr.item(_unwrap(index)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

String _cachedBrowserPrefix;

String get _browserPrefix() {
  if (_cachedBrowserPrefix === null) {
    if (_Device.isFirefox) {
      _cachedBrowserPrefix = '-moz-';
    } else {
      _cachedBrowserPrefix = '-webkit-';
    }
    // TODO(jacobr): support IE 9.0 and Opera as well.
  }
  return _cachedBrowserPrefix;
}

class _CSSStyleDeclarationImpl extends _DOMTypeBase implements CSSStyleDeclaration {

  _CSSStyleDeclarationImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  CSSRule get parentRule() => _wrap(_ptr.parentRule);

  CSSValue getPropertyCSSValue(String propertyName) => _wrap(_ptr.getPropertyCSSValue(_unwrap(propertyName)));

  String getPropertyPriority(String propertyName) => _wrap(_ptr.getPropertyPriority(_unwrap(propertyName)));

  String getPropertyShorthand(String propertyName) => _wrap(_ptr.getPropertyShorthand(_unwrap(propertyName)));

  String getPropertyValue(String propertyName) => _wrap(_ptr.getPropertyValue(_unwrap(propertyName)));

  bool isPropertyImplicit(String propertyName) => _wrap(_ptr.isPropertyImplicit(_unwrap(propertyName)));

  String item(int index) => _wrap(_ptr.item(_unwrap(index)));

  String removeProperty(String propertyName) => _wrap(_ptr.removeProperty(_unwrap(propertyName)));

  void setProperty(String propertyName, String value, [String priority = null]) => _ptr.setProperty(_unwrap(propertyName), _unwrap(value), _unwrap(priority));


  // TODO(jacobr): generate this list of properties using the existing script.
    /** Gets the value of "animation" */
  String get animation() =>
    getPropertyValue('${_browserPrefix}animation');

  /** Sets the value of "animation" */
  void set animation(var value) {
    setProperty('${_browserPrefix}animation', value, '');
  }

  /** Gets the value of "animation-delay" */
  String get animationDelay() =>
    getPropertyValue('${_browserPrefix}animation-delay');

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value) {
    setProperty('${_browserPrefix}animation-delay', value, '');
  }

  /** Gets the value of "animation-direction" */
  String get animationDirection() =>
    getPropertyValue('${_browserPrefix}animation-direction');

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value) {
    setProperty('${_browserPrefix}animation-direction', value, '');
  }

  /** Gets the value of "animation-duration" */
  String get animationDuration() =>
    getPropertyValue('${_browserPrefix}animation-duration');

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value) {
    setProperty('${_browserPrefix}animation-duration', value, '');
  }

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode() =>
    getPropertyValue('${_browserPrefix}animation-fill-mode');

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value) {
    setProperty('${_browserPrefix}animation-fill-mode', value, '');
  }

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount() =>
    getPropertyValue('${_browserPrefix}animation-iteration-count');

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value) {
    setProperty('${_browserPrefix}animation-iteration-count', value, '');
  }

  /** Gets the value of "animation-name" */
  String get animationName() =>
    getPropertyValue('${_browserPrefix}animation-name');

  /** Sets the value of "animation-name" */
  void set animationName(var value) {
    setProperty('${_browserPrefix}animation-name', value, '');
  }

  /** Gets the value of "animation-play-state" */
  String get animationPlayState() =>
    getPropertyValue('${_browserPrefix}animation-play-state');

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value) {
    setProperty('${_browserPrefix}animation-play-state', value, '');
  }

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction() =>
    getPropertyValue('${_browserPrefix}animation-timing-function');

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value) {
    setProperty('${_browserPrefix}animation-timing-function', value, '');
  }

  /** Gets the value of "appearance" */
  String get appearance() =>
    getPropertyValue('${_browserPrefix}appearance');

  /** Sets the value of "appearance" */
  void set appearance(var value) {
    setProperty('${_browserPrefix}appearance', value, '');
  }

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility() =>
    getPropertyValue('${_browserPrefix}backface-visibility');

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value) {
    setProperty('${_browserPrefix}backface-visibility', value, '');
  }

  /** Gets the value of "background" */
  String get background() =>
    getPropertyValue('background');

  /** Sets the value of "background" */
  void set background(var value) {
    setProperty('background', value, '');
  }

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment() =>
    getPropertyValue('background-attachment');

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value) {
    setProperty('background-attachment', value, '');
  }

  /** Gets the value of "background-clip" */
  String get backgroundClip() =>
    getPropertyValue('background-clip');

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value) {
    setProperty('background-clip', value, '');
  }

  /** Gets the value of "background-color" */
  String get backgroundColor() =>
    getPropertyValue('background-color');

  /** Sets the value of "background-color" */
  void set backgroundColor(var value) {
    setProperty('background-color', value, '');
  }

  /** Gets the value of "background-composite" */
  String get backgroundComposite() =>
    getPropertyValue('${_browserPrefix}background-composite');

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value) {
    setProperty('${_browserPrefix}background-composite', value, '');
  }

  /** Gets the value of "background-image" */
  String get backgroundImage() =>
    getPropertyValue('background-image');

  /** Sets the value of "background-image" */
  void set backgroundImage(var value) {
    setProperty('background-image', value, '');
  }

  /** Gets the value of "background-origin" */
  String get backgroundOrigin() =>
    getPropertyValue('background-origin');

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value) {
    setProperty('background-origin', value, '');
  }

  /** Gets the value of "background-position" */
  String get backgroundPosition() =>
    getPropertyValue('background-position');

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value) {
    setProperty('background-position', value, '');
  }

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX() =>
    getPropertyValue('background-position-x');

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value) {
    setProperty('background-position-x', value, '');
  }

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY() =>
    getPropertyValue('background-position-y');

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value) {
    setProperty('background-position-y', value, '');
  }

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat() =>
    getPropertyValue('background-repeat');

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value) {
    setProperty('background-repeat', value, '');
  }

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX() =>
    getPropertyValue('background-repeat-x');

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value) {
    setProperty('background-repeat-x', value, '');
  }

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY() =>
    getPropertyValue('background-repeat-y');

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value) {
    setProperty('background-repeat-y', value, '');
  }

  /** Gets the value of "background-size" */
  String get backgroundSize() =>
    getPropertyValue('background-size');

  /** Sets the value of "background-size" */
  void set backgroundSize(var value) {
    setProperty('background-size', value, '');
  }

  /** Gets the value of "border" */
  String get border() =>
    getPropertyValue('border');

  /** Sets the value of "border" */
  void set border(var value) {
    setProperty('border', value, '');
  }

  /** Gets the value of "border-after" */
  String get borderAfter() =>
    getPropertyValue('${_browserPrefix}border-after');

  /** Sets the value of "border-after" */
  void set borderAfter(var value) {
    setProperty('${_browserPrefix}border-after', value, '');
  }

  /** Gets the value of "border-after-color" */
  String get borderAfterColor() =>
    getPropertyValue('${_browserPrefix}border-after-color');

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value) {
    setProperty('${_browserPrefix}border-after-color', value, '');
  }

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle() =>
    getPropertyValue('${_browserPrefix}border-after-style');

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value) {
    setProperty('${_browserPrefix}border-after-style', value, '');
  }

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth() =>
    getPropertyValue('${_browserPrefix}border-after-width');

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value) {
    setProperty('${_browserPrefix}border-after-width', value, '');
  }

  /** Gets the value of "border-before" */
  String get borderBefore() =>
    getPropertyValue('${_browserPrefix}border-before');

  /** Sets the value of "border-before" */
  void set borderBefore(var value) {
    setProperty('${_browserPrefix}border-before', value, '');
  }

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor() =>
    getPropertyValue('${_browserPrefix}border-before-color');

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value) {
    setProperty('${_browserPrefix}border-before-color', value, '');
  }

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle() =>
    getPropertyValue('${_browserPrefix}border-before-style');

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value) {
    setProperty('${_browserPrefix}border-before-style', value, '');
  }

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth() =>
    getPropertyValue('${_browserPrefix}border-before-width');

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value) {
    setProperty('${_browserPrefix}border-before-width', value, '');
  }

  /** Gets the value of "border-bottom" */
  String get borderBottom() =>
    getPropertyValue('border-bottom');

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value) {
    setProperty('border-bottom', value, '');
  }

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor() =>
    getPropertyValue('border-bottom-color');

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value) {
    setProperty('border-bottom-color', value, '');
  }

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius() =>
    getPropertyValue('border-bottom-left-radius');

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value) {
    setProperty('border-bottom-left-radius', value, '');
  }

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius() =>
    getPropertyValue('border-bottom-right-radius');

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value) {
    setProperty('border-bottom-right-radius', value, '');
  }

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle() =>
    getPropertyValue('border-bottom-style');

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value) {
    setProperty('border-bottom-style', value, '');
  }

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth() =>
    getPropertyValue('border-bottom-width');

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value) {
    setProperty('border-bottom-width', value, '');
  }

  /** Gets the value of "border-collapse" */
  String get borderCollapse() =>
    getPropertyValue('border-collapse');

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value) {
    setProperty('border-collapse', value, '');
  }

  /** Gets the value of "border-color" */
  String get borderColor() =>
    getPropertyValue('border-color');

  /** Sets the value of "border-color" */
  void set borderColor(var value) {
    setProperty('border-color', value, '');
  }

  /** Gets the value of "border-end" */
  String get borderEnd() =>
    getPropertyValue('${_browserPrefix}border-end');

  /** Sets the value of "border-end" */
  void set borderEnd(var value) {
    setProperty('${_browserPrefix}border-end', value, '');
  }

  /** Gets the value of "border-end-color" */
  String get borderEndColor() =>
    getPropertyValue('${_browserPrefix}border-end-color');

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value) {
    setProperty('${_browserPrefix}border-end-color', value, '');
  }

  /** Gets the value of "border-end-style" */
  String get borderEndStyle() =>
    getPropertyValue('${_browserPrefix}border-end-style');

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value) {
    setProperty('${_browserPrefix}border-end-style', value, '');
  }

  /** Gets the value of "border-end-width" */
  String get borderEndWidth() =>
    getPropertyValue('${_browserPrefix}border-end-width');

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value) {
    setProperty('${_browserPrefix}border-end-width', value, '');
  }

  /** Gets the value of "border-fit" */
  String get borderFit() =>
    getPropertyValue('${_browserPrefix}border-fit');

  /** Sets the value of "border-fit" */
  void set borderFit(var value) {
    setProperty('${_browserPrefix}border-fit', value, '');
  }

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing() =>
    getPropertyValue('${_browserPrefix}border-horizontal-spacing');

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value) {
    setProperty('${_browserPrefix}border-horizontal-spacing', value, '');
  }

  /** Gets the value of "border-image" */
  String get borderImage() =>
    getPropertyValue('border-image');

  /** Sets the value of "border-image" */
  void set borderImage(var value) {
    setProperty('border-image', value, '');
  }

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset() =>
    getPropertyValue('border-image-outset');

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value) {
    setProperty('border-image-outset', value, '');
  }

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat() =>
    getPropertyValue('border-image-repeat');

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value) {
    setProperty('border-image-repeat', value, '');
  }

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice() =>
    getPropertyValue('border-image-slice');

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value) {
    setProperty('border-image-slice', value, '');
  }

  /** Gets the value of "border-image-source" */
  String get borderImageSource() =>
    getPropertyValue('border-image-source');

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value) {
    setProperty('border-image-source', value, '');
  }

  /** Gets the value of "border-image-width" */
  String get borderImageWidth() =>
    getPropertyValue('border-image-width');

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value) {
    setProperty('border-image-width', value, '');
  }

  /** Gets the value of "border-left" */
  String get borderLeft() =>
    getPropertyValue('border-left');

  /** Sets the value of "border-left" */
  void set borderLeft(var value) {
    setProperty('border-left', value, '');
  }

  /** Gets the value of "border-left-color" */
  String get borderLeftColor() =>
    getPropertyValue('border-left-color');

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value) {
    setProperty('border-left-color', value, '');
  }

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle() =>
    getPropertyValue('border-left-style');

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value) {
    setProperty('border-left-style', value, '');
  }

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth() =>
    getPropertyValue('border-left-width');

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value) {
    setProperty('border-left-width', value, '');
  }

  /** Gets the value of "border-radius" */
  String get borderRadius() =>
    getPropertyValue('border-radius');

  /** Sets the value of "border-radius" */
  void set borderRadius(var value) {
    setProperty('border-radius', value, '');
  }

  /** Gets the value of "border-right" */
  String get borderRight() =>
    getPropertyValue('border-right');

  /** Sets the value of "border-right" */
  void set borderRight(var value) {
    setProperty('border-right', value, '');
  }

  /** Gets the value of "border-right-color" */
  String get borderRightColor() =>
    getPropertyValue('border-right-color');

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value) {
    setProperty('border-right-color', value, '');
  }

  /** Gets the value of "border-right-style" */
  String get borderRightStyle() =>
    getPropertyValue('border-right-style');

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value) {
    setProperty('border-right-style', value, '');
  }

  /** Gets the value of "border-right-width" */
  String get borderRightWidth() =>
    getPropertyValue('border-right-width');

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value) {
    setProperty('border-right-width', value, '');
  }

  /** Gets the value of "border-spacing" */
  String get borderSpacing() =>
    getPropertyValue('border-spacing');

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value) {
    setProperty('border-spacing', value, '');
  }

  /** Gets the value of "border-start" */
  String get borderStart() =>
    getPropertyValue('${_browserPrefix}border-start');

  /** Sets the value of "border-start" */
  void set borderStart(var value) {
    setProperty('${_browserPrefix}border-start', value, '');
  }

  /** Gets the value of "border-start-color" */
  String get borderStartColor() =>
    getPropertyValue('${_browserPrefix}border-start-color');

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value) {
    setProperty('${_browserPrefix}border-start-color', value, '');
  }

  /** Gets the value of "border-start-style" */
  String get borderStartStyle() =>
    getPropertyValue('${_browserPrefix}border-start-style');

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value) {
    setProperty('${_browserPrefix}border-start-style', value, '');
  }

  /** Gets the value of "border-start-width" */
  String get borderStartWidth() =>
    getPropertyValue('${_browserPrefix}border-start-width');

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value) {
    setProperty('${_browserPrefix}border-start-width', value, '');
  }

  /** Gets the value of "border-style" */
  String get borderStyle() =>
    getPropertyValue('border-style');

  /** Sets the value of "border-style" */
  void set borderStyle(var value) {
    setProperty('border-style', value, '');
  }

  /** Gets the value of "border-top" */
  String get borderTop() =>
    getPropertyValue('border-top');

  /** Sets the value of "border-top" */
  void set borderTop(var value) {
    setProperty('border-top', value, '');
  }

  /** Gets the value of "border-top-color" */
  String get borderTopColor() =>
    getPropertyValue('border-top-color');

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value) {
    setProperty('border-top-color', value, '');
  }

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius() =>
    getPropertyValue('border-top-left-radius');

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value) {
    setProperty('border-top-left-radius', value, '');
  }

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius() =>
    getPropertyValue('border-top-right-radius');

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value) {
    setProperty('border-top-right-radius', value, '');
  }

  /** Gets the value of "border-top-style" */
  String get borderTopStyle() =>
    getPropertyValue('border-top-style');

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value) {
    setProperty('border-top-style', value, '');
  }

  /** Gets the value of "border-top-width" */
  String get borderTopWidth() =>
    getPropertyValue('border-top-width');

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value) {
    setProperty('border-top-width', value, '');
  }

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing() =>
    getPropertyValue('${_browserPrefix}border-vertical-spacing');

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value) {
    setProperty('${_browserPrefix}border-vertical-spacing', value, '');
  }

  /** Gets the value of "border-width" */
  String get borderWidth() =>
    getPropertyValue('border-width');

  /** Sets the value of "border-width" */
  void set borderWidth(var value) {
    setProperty('border-width', value, '');
  }

  /** Gets the value of "bottom" */
  String get bottom() =>
    getPropertyValue('bottom');

  /** Sets the value of "bottom" */
  void set bottom(var value) {
    setProperty('bottom', value, '');
  }

  /** Gets the value of "box-align" */
  String get boxAlign() =>
    getPropertyValue('${_browserPrefix}box-align');

  /** Sets the value of "box-align" */
  void set boxAlign(var value) {
    setProperty('${_browserPrefix}box-align', value, '');
  }

  /** Gets the value of "box-direction" */
  String get boxDirection() =>
    getPropertyValue('${_browserPrefix}box-direction');

  /** Sets the value of "box-direction" */
  void set boxDirection(var value) {
    setProperty('${_browserPrefix}box-direction', value, '');
  }

  /** Gets the value of "box-flex" */
  String get boxFlex() =>
    getPropertyValue('${_browserPrefix}box-flex');

  /** Sets the value of "box-flex" */
  void set boxFlex(var value) {
    setProperty('${_browserPrefix}box-flex', value, '');
  }

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup() =>
    getPropertyValue('${_browserPrefix}box-flex-group');

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value) {
    setProperty('${_browserPrefix}box-flex-group', value, '');
  }

  /** Gets the value of "box-lines" */
  String get boxLines() =>
    getPropertyValue('${_browserPrefix}box-lines');

  /** Sets the value of "box-lines" */
  void set boxLines(var value) {
    setProperty('${_browserPrefix}box-lines', value, '');
  }

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup() =>
    getPropertyValue('${_browserPrefix}box-ordinal-group');

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value) {
    setProperty('${_browserPrefix}box-ordinal-group', value, '');
  }

  /** Gets the value of "box-orient" */
  String get boxOrient() =>
    getPropertyValue('${_browserPrefix}box-orient');

  /** Sets the value of "box-orient" */
  void set boxOrient(var value) {
    setProperty('${_browserPrefix}box-orient', value, '');
  }

  /** Gets the value of "box-pack" */
  String get boxPack() =>
    getPropertyValue('${_browserPrefix}box-pack');

  /** Sets the value of "box-pack" */
  void set boxPack(var value) {
    setProperty('${_browserPrefix}box-pack', value, '');
  }

  /** Gets the value of "box-reflect" */
  String get boxReflect() =>
    getPropertyValue('${_browserPrefix}box-reflect');

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value) {
    setProperty('${_browserPrefix}box-reflect', value, '');
  }

  /** Gets the value of "box-shadow" */
  String get boxShadow() =>
    getPropertyValue('box-shadow');

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value) {
    setProperty('box-shadow', value, '');
  }

  /** Gets the value of "box-sizing" */
  String get boxSizing() =>
    getPropertyValue('box-sizing');

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value) {
    setProperty('box-sizing', value, '');
  }

  /** Gets the value of "caption-side" */
  String get captionSide() =>
    getPropertyValue('caption-side');

  /** Sets the value of "caption-side" */
  void set captionSide(var value) {
    setProperty('caption-side', value, '');
  }

  /** Gets the value of "clear" */
  String get clear() =>
    getPropertyValue('clear');

  /** Sets the value of "clear" */
  void set clear(var value) {
    setProperty('clear', value, '');
  }

  /** Gets the value of "clip" */
  String get clip() =>
    getPropertyValue('clip');

  /** Sets the value of "clip" */
  void set clip(var value) {
    setProperty('clip', value, '');
  }

  /** Gets the value of "color" */
  String get color() =>
    getPropertyValue('color');

  /** Sets the value of "color" */
  void set color(var value) {
    setProperty('color', value, '');
  }

  /** Gets the value of "color-correction" */
  String get colorCorrection() =>
    getPropertyValue('${_browserPrefix}color-correction');

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value) {
    setProperty('${_browserPrefix}color-correction', value, '');
  }

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter() =>
    getPropertyValue('${_browserPrefix}column-break-after');

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value) {
    setProperty('${_browserPrefix}column-break-after', value, '');
  }

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore() =>
    getPropertyValue('${_browserPrefix}column-break-before');

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value) {
    setProperty('${_browserPrefix}column-break-before', value, '');
  }

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside() =>
    getPropertyValue('${_browserPrefix}column-break-inside');

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value) {
    setProperty('${_browserPrefix}column-break-inside', value, '');
  }

  /** Gets the value of "column-count" */
  String get columnCount() =>
    getPropertyValue('${_browserPrefix}column-count');

  /** Sets the value of "column-count" */
  void set columnCount(var value) {
    setProperty('${_browserPrefix}column-count', value, '');
  }

  /** Gets the value of "column-gap" */
  String get columnGap() =>
    getPropertyValue('${_browserPrefix}column-gap');

  /** Sets the value of "column-gap" */
  void set columnGap(var value) {
    setProperty('${_browserPrefix}column-gap', value, '');
  }

  /** Gets the value of "column-rule" */
  String get columnRule() =>
    getPropertyValue('${_browserPrefix}column-rule');

  /** Sets the value of "column-rule" */
  void set columnRule(var value) {
    setProperty('${_browserPrefix}column-rule', value, '');
  }

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor() =>
    getPropertyValue('${_browserPrefix}column-rule-color');

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value) {
    setProperty('${_browserPrefix}column-rule-color', value, '');
  }

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle() =>
    getPropertyValue('${_browserPrefix}column-rule-style');

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value) {
    setProperty('${_browserPrefix}column-rule-style', value, '');
  }

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth() =>
    getPropertyValue('${_browserPrefix}column-rule-width');

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value) {
    setProperty('${_browserPrefix}column-rule-width', value, '');
  }

  /** Gets the value of "column-span" */
  String get columnSpan() =>
    getPropertyValue('${_browserPrefix}column-span');

  /** Sets the value of "column-span" */
  void set columnSpan(var value) {
    setProperty('${_browserPrefix}column-span', value, '');
  }

  /** Gets the value of "column-width" */
  String get columnWidth() =>
    getPropertyValue('${_browserPrefix}column-width');

  /** Sets the value of "column-width" */
  void set columnWidth(var value) {
    setProperty('${_browserPrefix}column-width', value, '');
  }

  /** Gets the value of "columns" */
  String get columns() =>
    getPropertyValue('${_browserPrefix}columns');

  /** Sets the value of "columns" */
  void set columns(var value) {
    setProperty('${_browserPrefix}columns', value, '');
  }

  /** Gets the value of "content" */
  String get content() =>
    getPropertyValue('content');

  /** Sets the value of "content" */
  void set content(var value) {
    setProperty('content', value, '');
  }

  /** Gets the value of "counter-increment" */
  String get counterIncrement() =>
    getPropertyValue('counter-increment');

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value) {
    setProperty('counter-increment', value, '');
  }

  /** Gets the value of "counter-reset" */
  String get counterReset() =>
    getPropertyValue('counter-reset');

  /** Sets the value of "counter-reset" */
  void set counterReset(var value) {
    setProperty('counter-reset', value, '');
  }

  /** Gets the value of "cursor" */
  String get cursor() =>
    getPropertyValue('cursor');

  /** Sets the value of "cursor" */
  void set cursor(var value) {
    setProperty('cursor', value, '');
  }

  /** Gets the value of "direction" */
  String get direction() =>
    getPropertyValue('direction');

  /** Sets the value of "direction" */
  void set direction(var value) {
    setProperty('direction', value, '');
  }

  /** Gets the value of "display" */
  String get display() =>
    getPropertyValue('display');

  /** Sets the value of "display" */
  void set display(var value) {
    setProperty('display', value, '');
  }

  /** Gets the value of "empty-cells" */
  String get emptyCells() =>
    getPropertyValue('empty-cells');

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value) {
    setProperty('empty-cells', value, '');
  }

  /** Gets the value of "filter" */
  String get filter() =>
    getPropertyValue('${_browserPrefix}filter');

  /** Sets the value of "filter" */
  void set filter(var value) {
    setProperty('${_browserPrefix}filter', value, '');
  }

  /** Gets the value of "flex-align" */
  String get flexAlign() =>
    getPropertyValue('${_browserPrefix}flex-align');

  /** Sets the value of "flex-align" */
  void set flexAlign(var value) {
    setProperty('${_browserPrefix}flex-align', value, '');
  }

  /** Gets the value of "flex-flow" */
  String get flexFlow() =>
    getPropertyValue('${_browserPrefix}flex-flow');

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value) {
    setProperty('${_browserPrefix}flex-flow', value, '');
  }

  /** Gets the value of "flex-order" */
  String get flexOrder() =>
    getPropertyValue('${_browserPrefix}flex-order');

  /** Sets the value of "flex-order" */
  void set flexOrder(var value) {
    setProperty('${_browserPrefix}flex-order', value, '');
  }

  /** Gets the value of "flex-pack" */
  String get flexPack() =>
    getPropertyValue('${_browserPrefix}flex-pack');

  /** Sets the value of "flex-pack" */
  void set flexPack(var value) {
    setProperty('${_browserPrefix}flex-pack', value, '');
  }

  /** Gets the value of "float" */
  String get float() =>
    getPropertyValue('float');

  /** Sets the value of "float" */
  void set float(var value) {
    setProperty('float', value, '');
  }

  /** Gets the value of "flow-from" */
  String get flowFrom() =>
    getPropertyValue('${_browserPrefix}flow-from');

  /** Sets the value of "flow-from" */
  void set flowFrom(var value) {
    setProperty('${_browserPrefix}flow-from', value, '');
  }

  /** Gets the value of "flow-into" */
  String get flowInto() =>
    getPropertyValue('${_browserPrefix}flow-into');

  /** Sets the value of "flow-into" */
  void set flowInto(var value) {
    setProperty('${_browserPrefix}flow-into', value, '');
  }

  /** Gets the value of "font" */
  String get font() =>
    getPropertyValue('font');

  /** Sets the value of "font" */
  void set font(var value) {
    setProperty('font', value, '');
  }

  /** Gets the value of "font-family" */
  String get fontFamily() =>
    getPropertyValue('font-family');

  /** Sets the value of "font-family" */
  void set fontFamily(var value) {
    setProperty('font-family', value, '');
  }

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings() =>
    getPropertyValue('${_browserPrefix}font-feature-settings');

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value) {
    setProperty('${_browserPrefix}font-feature-settings', value, '');
  }

  /** Gets the value of "font-size" */
  String get fontSize() =>
    getPropertyValue('font-size');

  /** Sets the value of "font-size" */
  void set fontSize(var value) {
    setProperty('font-size', value, '');
  }

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta() =>
    getPropertyValue('${_browserPrefix}font-size-delta');

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value) {
    setProperty('${_browserPrefix}font-size-delta', value, '');
  }

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing() =>
    getPropertyValue('${_browserPrefix}font-smoothing');

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value) {
    setProperty('${_browserPrefix}font-smoothing', value, '');
  }

  /** Gets the value of "font-stretch" */
  String get fontStretch() =>
    getPropertyValue('font-stretch');

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value) {
    setProperty('font-stretch', value, '');
  }

  /** Gets the value of "font-style" */
  String get fontStyle() =>
    getPropertyValue('font-style');

  /** Sets the value of "font-style" */
  void set fontStyle(var value) {
    setProperty('font-style', value, '');
  }

  /** Gets the value of "font-variant" */
  String get fontVariant() =>
    getPropertyValue('font-variant');

  /** Sets the value of "font-variant" */
  void set fontVariant(var value) {
    setProperty('font-variant', value, '');
  }

  /** Gets the value of "font-weight" */
  String get fontWeight() =>
    getPropertyValue('font-weight');

  /** Sets the value of "font-weight" */
  void set fontWeight(var value) {
    setProperty('font-weight', value, '');
  }

  /** Gets the value of "height" */
  String get height() =>
    getPropertyValue('height');

  /** Sets the value of "height" */
  void set height(var value) {
    setProperty('height', value, '');
  }

  /** Gets the value of "highlight" */
  String get highlight() =>
    getPropertyValue('${_browserPrefix}highlight');

  /** Sets the value of "highlight" */
  void set highlight(var value) {
    setProperty('${_browserPrefix}highlight', value, '');
  }

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter() =>
    getPropertyValue('${_browserPrefix}hyphenate-character');

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value) {
    setProperty('${_browserPrefix}hyphenate-character', value, '');
  }

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-after');

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-after', value, '');
  }

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-before');

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-before', value, '');
  }

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-lines');

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-lines', value, '');
  }

  /** Gets the value of "hyphens" */
  String get hyphens() =>
    getPropertyValue('${_browserPrefix}hyphens');

  /** Sets the value of "hyphens" */
  void set hyphens(var value) {
    setProperty('${_browserPrefix}hyphens', value, '');
  }

  /** Gets the value of "image-rendering" */
  String get imageRendering() =>
    getPropertyValue('image-rendering');

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value) {
    setProperty('image-rendering', value, '');
  }

  /** Gets the value of "left" */
  String get left() =>
    getPropertyValue('left');

  /** Sets the value of "left" */
  void set left(var value) {
    setProperty('left', value, '');
  }

  /** Gets the value of "letter-spacing" */
  String get letterSpacing() =>
    getPropertyValue('letter-spacing');

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value) {
    setProperty('letter-spacing', value, '');
  }

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain() =>
    getPropertyValue('${_browserPrefix}line-box-contain');

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value) {
    setProperty('${_browserPrefix}line-box-contain', value, '');
  }

  /** Gets the value of "line-break" */
  String get lineBreak() =>
    getPropertyValue('${_browserPrefix}line-break');

  /** Sets the value of "line-break" */
  void set lineBreak(var value) {
    setProperty('${_browserPrefix}line-break', value, '');
  }

  /** Gets the value of "line-clamp" */
  String get lineClamp() =>
    getPropertyValue('${_browserPrefix}line-clamp');

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value) {
    setProperty('${_browserPrefix}line-clamp', value, '');
  }

  /** Gets the value of "line-height" */
  String get lineHeight() =>
    getPropertyValue('line-height');

  /** Sets the value of "line-height" */
  void set lineHeight(var value) {
    setProperty('line-height', value, '');
  }

  /** Gets the value of "list-style" */
  String get listStyle() =>
    getPropertyValue('list-style');

  /** Sets the value of "list-style" */
  void set listStyle(var value) {
    setProperty('list-style', value, '');
  }

  /** Gets the value of "list-style-image" */
  String get listStyleImage() =>
    getPropertyValue('list-style-image');

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value) {
    setProperty('list-style-image', value, '');
  }

  /** Gets the value of "list-style-position" */
  String get listStylePosition() =>
    getPropertyValue('list-style-position');

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value) {
    setProperty('list-style-position', value, '');
  }

  /** Gets the value of "list-style-type" */
  String get listStyleType() =>
    getPropertyValue('list-style-type');

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value) {
    setProperty('list-style-type', value, '');
  }

  /** Gets the value of "locale" */
  String get locale() =>
    getPropertyValue('${_browserPrefix}locale');

  /** Sets the value of "locale" */
  void set locale(var value) {
    setProperty('${_browserPrefix}locale', value, '');
  }

  /** Gets the value of "logical-height" */
  String get logicalHeight() =>
    getPropertyValue('${_browserPrefix}logical-height');

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value) {
    setProperty('${_browserPrefix}logical-height', value, '');
  }

  /** Gets the value of "logical-width" */
  String get logicalWidth() =>
    getPropertyValue('${_browserPrefix}logical-width');

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value) {
    setProperty('${_browserPrefix}logical-width', value, '');
  }

  /** Gets the value of "margin" */
  String get margin() =>
    getPropertyValue('margin');

  /** Sets the value of "margin" */
  void set margin(var value) {
    setProperty('margin', value, '');
  }

  /** Gets the value of "margin-after" */
  String get marginAfter() =>
    getPropertyValue('${_browserPrefix}margin-after');

  /** Sets the value of "margin-after" */
  void set marginAfter(var value) {
    setProperty('${_browserPrefix}margin-after', value, '');
  }

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse() =>
    getPropertyValue('${_browserPrefix}margin-after-collapse');

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value) {
    setProperty('${_browserPrefix}margin-after-collapse', value, '');
  }

  /** Gets the value of "margin-before" */
  String get marginBefore() =>
    getPropertyValue('${_browserPrefix}margin-before');

  /** Sets the value of "margin-before" */
  void set marginBefore(var value) {
    setProperty('${_browserPrefix}margin-before', value, '');
  }

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse() =>
    getPropertyValue('${_browserPrefix}margin-before-collapse');

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value) {
    setProperty('${_browserPrefix}margin-before-collapse', value, '');
  }

  /** Gets the value of "margin-bottom" */
  String get marginBottom() =>
    getPropertyValue('margin-bottom');

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value) {
    setProperty('margin-bottom', value, '');
  }

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse() =>
    getPropertyValue('${_browserPrefix}margin-bottom-collapse');

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value) {
    setProperty('${_browserPrefix}margin-bottom-collapse', value, '');
  }

  /** Gets the value of "margin-collapse" */
  String get marginCollapse() =>
    getPropertyValue('${_browserPrefix}margin-collapse');

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value) {
    setProperty('${_browserPrefix}margin-collapse', value, '');
  }

  /** Gets the value of "margin-end" */
  String get marginEnd() =>
    getPropertyValue('${_browserPrefix}margin-end');

  /** Sets the value of "margin-end" */
  void set marginEnd(var value) {
    setProperty('${_browserPrefix}margin-end', value, '');
  }

  /** Gets the value of "margin-left" */
  String get marginLeft() =>
    getPropertyValue('margin-left');

  /** Sets the value of "margin-left" */
  void set marginLeft(var value) {
    setProperty('margin-left', value, '');
  }

  /** Gets the value of "margin-right" */
  String get marginRight() =>
    getPropertyValue('margin-right');

  /** Sets the value of "margin-right" */
  void set marginRight(var value) {
    setProperty('margin-right', value, '');
  }

  /** Gets the value of "margin-start" */
  String get marginStart() =>
    getPropertyValue('${_browserPrefix}margin-start');

  /** Sets the value of "margin-start" */
  void set marginStart(var value) {
    setProperty('${_browserPrefix}margin-start', value, '');
  }

  /** Gets the value of "margin-top" */
  String get marginTop() =>
    getPropertyValue('margin-top');

  /** Sets the value of "margin-top" */
  void set marginTop(var value) {
    setProperty('margin-top', value, '');
  }

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse() =>
    getPropertyValue('${_browserPrefix}margin-top-collapse');

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value) {
    setProperty('${_browserPrefix}margin-top-collapse', value, '');
  }

  /** Gets the value of "marquee" */
  String get marquee() =>
    getPropertyValue('${_browserPrefix}marquee');

  /** Sets the value of "marquee" */
  void set marquee(var value) {
    setProperty('${_browserPrefix}marquee', value, '');
  }

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection() =>
    getPropertyValue('${_browserPrefix}marquee-direction');

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value) {
    setProperty('${_browserPrefix}marquee-direction', value, '');
  }

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement() =>
    getPropertyValue('${_browserPrefix}marquee-increment');

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value) {
    setProperty('${_browserPrefix}marquee-increment', value, '');
  }

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition() =>
    getPropertyValue('${_browserPrefix}marquee-repetition');

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value) {
    setProperty('${_browserPrefix}marquee-repetition', value, '');
  }

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed() =>
    getPropertyValue('${_browserPrefix}marquee-speed');

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value) {
    setProperty('${_browserPrefix}marquee-speed', value, '');
  }

  /** Gets the value of "marquee-style" */
  String get marqueeStyle() =>
    getPropertyValue('${_browserPrefix}marquee-style');

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value) {
    setProperty('${_browserPrefix}marquee-style', value, '');
  }

  /** Gets the value of "mask" */
  String get mask() =>
    getPropertyValue('${_browserPrefix}mask');

  /** Sets the value of "mask" */
  void set mask(var value) {
    setProperty('${_browserPrefix}mask', value, '');
  }

  /** Gets the value of "mask-attachment" */
  String get maskAttachment() =>
    getPropertyValue('${_browserPrefix}mask-attachment');

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value) {
    setProperty('${_browserPrefix}mask-attachment', value, '');
  }

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage() =>
    getPropertyValue('${_browserPrefix}mask-box-image');

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value) {
    setProperty('${_browserPrefix}mask-box-image', value, '');
  }

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset() =>
    getPropertyValue('${_browserPrefix}mask-box-image-outset');

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value) {
    setProperty('${_browserPrefix}mask-box-image-outset', value, '');
  }

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat() =>
    getPropertyValue('${_browserPrefix}mask-box-image-repeat');

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value) {
    setProperty('${_browserPrefix}mask-box-image-repeat', value, '');
  }

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice() =>
    getPropertyValue('${_browserPrefix}mask-box-image-slice');

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value) {
    setProperty('${_browserPrefix}mask-box-image-slice', value, '');
  }

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource() =>
    getPropertyValue('${_browserPrefix}mask-box-image-source');

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value) {
    setProperty('${_browserPrefix}mask-box-image-source', value, '');
  }

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth() =>
    getPropertyValue('${_browserPrefix}mask-box-image-width');

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value) {
    setProperty('${_browserPrefix}mask-box-image-width', value, '');
  }

  /** Gets the value of "mask-clip" */
  String get maskClip() =>
    getPropertyValue('${_browserPrefix}mask-clip');

  /** Sets the value of "mask-clip" */
  void set maskClip(var value) {
    setProperty('${_browserPrefix}mask-clip', value, '');
  }

  /** Gets the value of "mask-composite" */
  String get maskComposite() =>
    getPropertyValue('${_browserPrefix}mask-composite');

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value) {
    setProperty('${_browserPrefix}mask-composite', value, '');
  }

  /** Gets the value of "mask-image" */
  String get maskImage() =>
    getPropertyValue('${_browserPrefix}mask-image');

  /** Sets the value of "mask-image" */
  void set maskImage(var value) {
    setProperty('${_browserPrefix}mask-image', value, '');
  }

  /** Gets the value of "mask-origin" */
  String get maskOrigin() =>
    getPropertyValue('${_browserPrefix}mask-origin');

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value) {
    setProperty('${_browserPrefix}mask-origin', value, '');
  }

  /** Gets the value of "mask-position" */
  String get maskPosition() =>
    getPropertyValue('${_browserPrefix}mask-position');

  /** Sets the value of "mask-position" */
  void set maskPosition(var value) {
    setProperty('${_browserPrefix}mask-position', value, '');
  }

  /** Gets the value of "mask-position-x" */
  String get maskPositionX() =>
    getPropertyValue('${_browserPrefix}mask-position-x');

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value) {
    setProperty('${_browserPrefix}mask-position-x', value, '');
  }

  /** Gets the value of "mask-position-y" */
  String get maskPositionY() =>
    getPropertyValue('${_browserPrefix}mask-position-y');

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value) {
    setProperty('${_browserPrefix}mask-position-y', value, '');
  }

  /** Gets the value of "mask-repeat" */
  String get maskRepeat() =>
    getPropertyValue('${_browserPrefix}mask-repeat');

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value) {
    setProperty('${_browserPrefix}mask-repeat', value, '');
  }

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX() =>
    getPropertyValue('${_browserPrefix}mask-repeat-x');

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value) {
    setProperty('${_browserPrefix}mask-repeat-x', value, '');
  }

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY() =>
    getPropertyValue('${_browserPrefix}mask-repeat-y');

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value) {
    setProperty('${_browserPrefix}mask-repeat-y', value, '');
  }

  /** Gets the value of "mask-size" */
  String get maskSize() =>
    getPropertyValue('${_browserPrefix}mask-size');

  /** Sets the value of "mask-size" */
  void set maskSize(var value) {
    setProperty('${_browserPrefix}mask-size', value, '');
  }

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor() =>
    getPropertyValue('${_browserPrefix}match-nearest-mail-blockquote-color');

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value) {
    setProperty('${_browserPrefix}match-nearest-mail-blockquote-color', value, '');
  }

  /** Gets the value of "max-height" */
  String get maxHeight() =>
    getPropertyValue('max-height');

  /** Sets the value of "max-height" */
  void set maxHeight(var value) {
    setProperty('max-height', value, '');
  }

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight() =>
    getPropertyValue('${_browserPrefix}max-logical-height');

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value) {
    setProperty('${_browserPrefix}max-logical-height', value, '');
  }

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth() =>
    getPropertyValue('${_browserPrefix}max-logical-width');

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value) {
    setProperty('${_browserPrefix}max-logical-width', value, '');
  }

  /** Gets the value of "max-width" */
  String get maxWidth() =>
    getPropertyValue('max-width');

  /** Sets the value of "max-width" */
  void set maxWidth(var value) {
    setProperty('max-width', value, '');
  }

  /** Gets the value of "min-height" */
  String get minHeight() =>
    getPropertyValue('min-height');

  /** Sets the value of "min-height" */
  void set minHeight(var value) {
    setProperty('min-height', value, '');
  }

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight() =>
    getPropertyValue('${_browserPrefix}min-logical-height');

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value) {
    setProperty('${_browserPrefix}min-logical-height', value, '');
  }

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth() =>
    getPropertyValue('${_browserPrefix}min-logical-width');

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value) {
    setProperty('${_browserPrefix}min-logical-width', value, '');
  }

  /** Gets the value of "min-width" */
  String get minWidth() =>
    getPropertyValue('min-width');

  /** Sets the value of "min-width" */
  void set minWidth(var value) {
    setProperty('min-width', value, '');
  }

  /** Gets the value of "nbsp-mode" */
  String get nbspMode() =>
    getPropertyValue('${_browserPrefix}nbsp-mode');

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value) {
    setProperty('${_browserPrefix}nbsp-mode', value, '');
  }

  /** Gets the value of "opacity" */
  String get opacity() =>
    getPropertyValue('opacity');

  /** Sets the value of "opacity" */
  void set opacity(var value) {
    setProperty('opacity', value, '');
  }

  /** Gets the value of "orphans" */
  String get orphans() =>
    getPropertyValue('orphans');

  /** Sets the value of "orphans" */
  void set orphans(var value) {
    setProperty('orphans', value, '');
  }

  /** Gets the value of "outline" */
  String get outline() =>
    getPropertyValue('outline');

  /** Sets the value of "outline" */
  void set outline(var value) {
    setProperty('outline', value, '');
  }

  /** Gets the value of "outline-color" */
  String get outlineColor() =>
    getPropertyValue('outline-color');

  /** Sets the value of "outline-color" */
  void set outlineColor(var value) {
    setProperty('outline-color', value, '');
  }

  /** Gets the value of "outline-offset" */
  String get outlineOffset() =>
    getPropertyValue('outline-offset');

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value) {
    setProperty('outline-offset', value, '');
  }

  /** Gets the value of "outline-style" */
  String get outlineStyle() =>
    getPropertyValue('outline-style');

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value) {
    setProperty('outline-style', value, '');
  }

  /** Gets the value of "outline-width" */
  String get outlineWidth() =>
    getPropertyValue('outline-width');

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value) {
    setProperty('outline-width', value, '');
  }

  /** Gets the value of "overflow" */
  String get overflow() =>
    getPropertyValue('overflow');

  /** Sets the value of "overflow" */
  void set overflow(var value) {
    setProperty('overflow', value, '');
  }

  /** Gets the value of "overflow-x" */
  String get overflowX() =>
    getPropertyValue('overflow-x');

  /** Sets the value of "overflow-x" */
  void set overflowX(var value) {
    setProperty('overflow-x', value, '');
  }

  /** Gets the value of "overflow-y" */
  String get overflowY() =>
    getPropertyValue('overflow-y');

  /** Sets the value of "overflow-y" */
  void set overflowY(var value) {
    setProperty('overflow-y', value, '');
  }

  /** Gets the value of "padding" */
  String get padding() =>
    getPropertyValue('padding');

  /** Sets the value of "padding" */
  void set padding(var value) {
    setProperty('padding', value, '');
  }

  /** Gets the value of "padding-after" */
  String get paddingAfter() =>
    getPropertyValue('${_browserPrefix}padding-after');

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value) {
    setProperty('${_browserPrefix}padding-after', value, '');
  }

  /** Gets the value of "padding-before" */
  String get paddingBefore() =>
    getPropertyValue('${_browserPrefix}padding-before');

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value) {
    setProperty('${_browserPrefix}padding-before', value, '');
  }

  /** Gets the value of "padding-bottom" */
  String get paddingBottom() =>
    getPropertyValue('padding-bottom');

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value) {
    setProperty('padding-bottom', value, '');
  }

  /** Gets the value of "padding-end" */
  String get paddingEnd() =>
    getPropertyValue('${_browserPrefix}padding-end');

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value) {
    setProperty('${_browserPrefix}padding-end', value, '');
  }

  /** Gets the value of "padding-left" */
  String get paddingLeft() =>
    getPropertyValue('padding-left');

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value) {
    setProperty('padding-left', value, '');
  }

  /** Gets the value of "padding-right" */
  String get paddingRight() =>
    getPropertyValue('padding-right');

  /** Sets the value of "padding-right" */
  void set paddingRight(var value) {
    setProperty('padding-right', value, '');
  }

  /** Gets the value of "padding-start" */
  String get paddingStart() =>
    getPropertyValue('${_browserPrefix}padding-start');

  /** Sets the value of "padding-start" */
  void set paddingStart(var value) {
    setProperty('${_browserPrefix}padding-start', value, '');
  }

  /** Gets the value of "padding-top" */
  String get paddingTop() =>
    getPropertyValue('padding-top');

  /** Sets the value of "padding-top" */
  void set paddingTop(var value) {
    setProperty('padding-top', value, '');
  }

  /** Gets the value of "page" */
  String get page() =>
    getPropertyValue('page');

  /** Sets the value of "page" */
  void set page(var value) {
    setProperty('page', value, '');
  }

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter() =>
    getPropertyValue('page-break-after');

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value) {
    setProperty('page-break-after', value, '');
  }

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore() =>
    getPropertyValue('page-break-before');

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value) {
    setProperty('page-break-before', value, '');
  }

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside() =>
    getPropertyValue('page-break-inside');

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value) {
    setProperty('page-break-inside', value, '');
  }

  /** Gets the value of "perspective" */
  String get perspective() =>
    getPropertyValue('${_browserPrefix}perspective');

  /** Sets the value of "perspective" */
  void set perspective(var value) {
    setProperty('${_browserPrefix}perspective', value, '');
  }

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin() =>
    getPropertyValue('${_browserPrefix}perspective-origin');

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value) {
    setProperty('${_browserPrefix}perspective-origin', value, '');
  }

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX() =>
    getPropertyValue('${_browserPrefix}perspective-origin-x');

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value) {
    setProperty('${_browserPrefix}perspective-origin-x', value, '');
  }

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY() =>
    getPropertyValue('${_browserPrefix}perspective-origin-y');

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value) {
    setProperty('${_browserPrefix}perspective-origin-y', value, '');
  }

  /** Gets the value of "pointer-events" */
  String get pointerEvents() =>
    getPropertyValue('pointer-events');

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value) {
    setProperty('pointer-events', value, '');
  }

  /** Gets the value of "position" */
  String get position() =>
    getPropertyValue('position');

  /** Sets the value of "position" */
  void set position(var value) {
    setProperty('position', value, '');
  }

  /** Gets the value of "quotes" */
  String get quotes() =>
    getPropertyValue('quotes');

  /** Sets the value of "quotes" */
  void set quotes(var value) {
    setProperty('quotes', value, '');
  }

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter() =>
    getPropertyValue('${_browserPrefix}region-break-after');

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value) {
    setProperty('${_browserPrefix}region-break-after', value, '');
  }

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore() =>
    getPropertyValue('${_browserPrefix}region-break-before');

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value) {
    setProperty('${_browserPrefix}region-break-before', value, '');
  }

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside() =>
    getPropertyValue('${_browserPrefix}region-break-inside');

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value) {
    setProperty('${_browserPrefix}region-break-inside', value, '');
  }

  /** Gets the value of "region-overflow" */
  String get regionOverflow() =>
    getPropertyValue('${_browserPrefix}region-overflow');

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value) {
    setProperty('${_browserPrefix}region-overflow', value, '');
  }

  /** Gets the value of "resize" */
  String get resize() =>
    getPropertyValue('resize');

  /** Sets the value of "resize" */
  void set resize(var value) {
    setProperty('resize', value, '');
  }

  /** Gets the value of "right" */
  String get right() =>
    getPropertyValue('right');

  /** Sets the value of "right" */
  void set right(var value) {
    setProperty('right', value, '');
  }

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering() =>
    getPropertyValue('${_browserPrefix}rtl-ordering');

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value) {
    setProperty('${_browserPrefix}rtl-ordering', value, '');
  }

  /** Gets the value of "size" */
  String get size() =>
    getPropertyValue('size');

  /** Sets the value of "size" */
  void set size(var value) {
    setProperty('size', value, '');
  }

  /** Gets the value of "speak" */
  String get speak() =>
    getPropertyValue('speak');

  /** Sets the value of "speak" */
  void set speak(var value) {
    setProperty('speak', value, '');
  }

  /** Gets the value of "src" */
  String get src() =>
    getPropertyValue('src');

  /** Sets the value of "src" */
  void set src(var value) {
    setProperty('src', value, '');
  }

  /** Gets the value of "table-layout" */
  String get tableLayout() =>
    getPropertyValue('table-layout');

  /** Sets the value of "table-layout" */
  void set tableLayout(var value) {
    setProperty('table-layout', value, '');
  }

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor() =>
    getPropertyValue('${_browserPrefix}tap-highlight-color');

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value) {
    setProperty('${_browserPrefix}tap-highlight-color', value, '');
  }

  /** Gets the value of "text-align" */
  String get textAlign() =>
    getPropertyValue('text-align');

  /** Sets the value of "text-align" */
  void set textAlign(var value) {
    setProperty('text-align', value, '');
  }

  /** Gets the value of "text-combine" */
  String get textCombine() =>
    getPropertyValue('${_browserPrefix}text-combine');

  /** Sets the value of "text-combine" */
  void set textCombine(var value) {
    setProperty('${_browserPrefix}text-combine', value, '');
  }

  /** Gets the value of "text-decoration" */
  String get textDecoration() =>
    getPropertyValue('text-decoration');

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value) {
    setProperty('text-decoration', value, '');
  }

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect() =>
    getPropertyValue('${_browserPrefix}text-decorations-in-effect');

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value) {
    setProperty('${_browserPrefix}text-decorations-in-effect', value, '');
  }

  /** Gets the value of "text-emphasis" */
  String get textEmphasis() =>
    getPropertyValue('${_browserPrefix}text-emphasis');

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value) {
    setProperty('${_browserPrefix}text-emphasis', value, '');
  }

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor() =>
    getPropertyValue('${_browserPrefix}text-emphasis-color');

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value) {
    setProperty('${_browserPrefix}text-emphasis-color', value, '');
  }

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition() =>
    getPropertyValue('${_browserPrefix}text-emphasis-position');

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value) {
    setProperty('${_browserPrefix}text-emphasis-position', value, '');
  }

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle() =>
    getPropertyValue('${_browserPrefix}text-emphasis-style');

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value) {
    setProperty('${_browserPrefix}text-emphasis-style', value, '');
  }

  /** Gets the value of "text-fill-color" */
  String get textFillColor() =>
    getPropertyValue('${_browserPrefix}text-fill-color');

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value) {
    setProperty('${_browserPrefix}text-fill-color', value, '');
  }

  /** Gets the value of "text-indent" */
  String get textIndent() =>
    getPropertyValue('text-indent');

  /** Sets the value of "text-indent" */
  void set textIndent(var value) {
    setProperty('text-indent', value, '');
  }

  /** Gets the value of "text-line-through" */
  String get textLineThrough() =>
    getPropertyValue('text-line-through');

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value) {
    setProperty('text-line-through', value, '');
  }

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor() =>
    getPropertyValue('text-line-through-color');

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value) {
    setProperty('text-line-through-color', value, '');
  }

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode() =>
    getPropertyValue('text-line-through-mode');

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value) {
    setProperty('text-line-through-mode', value, '');
  }

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle() =>
    getPropertyValue('text-line-through-style');

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value) {
    setProperty('text-line-through-style', value, '');
  }

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth() =>
    getPropertyValue('text-line-through-width');

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value) {
    setProperty('text-line-through-width', value, '');
  }

  /** Gets the value of "text-orientation" */
  String get textOrientation() =>
    getPropertyValue('${_browserPrefix}text-orientation');

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value) {
    setProperty('${_browserPrefix}text-orientation', value, '');
  }

  /** Gets the value of "text-overflow" */
  String get textOverflow() =>
    getPropertyValue('text-overflow');

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value) {
    setProperty('text-overflow', value, '');
  }

  /** Gets the value of "text-overline" */
  String get textOverline() =>
    getPropertyValue('text-overline');

  /** Sets the value of "text-overline" */
  void set textOverline(var value) {
    setProperty('text-overline', value, '');
  }

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor() =>
    getPropertyValue('text-overline-color');

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value) {
    setProperty('text-overline-color', value, '');
  }

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode() =>
    getPropertyValue('text-overline-mode');

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value) {
    setProperty('text-overline-mode', value, '');
  }

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle() =>
    getPropertyValue('text-overline-style');

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value) {
    setProperty('text-overline-style', value, '');
  }

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth() =>
    getPropertyValue('text-overline-width');

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value) {
    setProperty('text-overline-width', value, '');
  }

  /** Gets the value of "text-rendering" */
  String get textRendering() =>
    getPropertyValue('text-rendering');

  /** Sets the value of "text-rendering" */
  void set textRendering(var value) {
    setProperty('text-rendering', value, '');
  }

  /** Gets the value of "text-security" */
  String get textSecurity() =>
    getPropertyValue('${_browserPrefix}text-security');

  /** Sets the value of "text-security" */
  void set textSecurity(var value) {
    setProperty('${_browserPrefix}text-security', value, '');
  }

  /** Gets the value of "text-shadow" */
  String get textShadow() =>
    getPropertyValue('text-shadow');

  /** Sets the value of "text-shadow" */
  void set textShadow(var value) {
    setProperty('text-shadow', value, '');
  }

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust() =>
    getPropertyValue('${_browserPrefix}text-size-adjust');

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value) {
    setProperty('${_browserPrefix}text-size-adjust', value, '');
  }

  /** Gets the value of "text-stroke" */
  String get textStroke() =>
    getPropertyValue('${_browserPrefix}text-stroke');

  /** Sets the value of "text-stroke" */
  void set textStroke(var value) {
    setProperty('${_browserPrefix}text-stroke', value, '');
  }

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor() =>
    getPropertyValue('${_browserPrefix}text-stroke-color');

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value) {
    setProperty('${_browserPrefix}text-stroke-color', value, '');
  }

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth() =>
    getPropertyValue('${_browserPrefix}text-stroke-width');

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value) {
    setProperty('${_browserPrefix}text-stroke-width', value, '');
  }

  /** Gets the value of "text-transform" */
  String get textTransform() =>
    getPropertyValue('text-transform');

  /** Sets the value of "text-transform" */
  void set textTransform(var value) {
    setProperty('text-transform', value, '');
  }

  /** Gets the value of "text-underline" */
  String get textUnderline() =>
    getPropertyValue('text-underline');

  /** Sets the value of "text-underline" */
  void set textUnderline(var value) {
    setProperty('text-underline', value, '');
  }

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor() =>
    getPropertyValue('text-underline-color');

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value) {
    setProperty('text-underline-color', value, '');
  }

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode() =>
    getPropertyValue('text-underline-mode');

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value) {
    setProperty('text-underline-mode', value, '');
  }

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle() =>
    getPropertyValue('text-underline-style');

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value) {
    setProperty('text-underline-style', value, '');
  }

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth() =>
    getPropertyValue('text-underline-width');

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value) {
    setProperty('text-underline-width', value, '');
  }

  /** Gets the value of "top" */
  String get top() =>
    getPropertyValue('top');

  /** Sets the value of "top" */
  void set top(var value) {
    setProperty('top', value, '');
  }

  /** Gets the value of "transform" */
  String get transform() =>
    getPropertyValue('${_browserPrefix}transform');

  /** Sets the value of "transform" */
  void set transform(var value) {
    setProperty('${_browserPrefix}transform', value, '');
  }

  /** Gets the value of "transform-origin" */
  String get transformOrigin() =>
    getPropertyValue('${_browserPrefix}transform-origin');

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value) {
    setProperty('${_browserPrefix}transform-origin', value, '');
  }

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX() =>
    getPropertyValue('${_browserPrefix}transform-origin-x');

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value) {
    setProperty('${_browserPrefix}transform-origin-x', value, '');
  }

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY() =>
    getPropertyValue('${_browserPrefix}transform-origin-y');

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value) {
    setProperty('${_browserPrefix}transform-origin-y', value, '');
  }

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ() =>
    getPropertyValue('${_browserPrefix}transform-origin-z');

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value) {
    setProperty('${_browserPrefix}transform-origin-z', value, '');
  }

  /** Gets the value of "transform-style" */
  String get transformStyle() =>
    getPropertyValue('${_browserPrefix}transform-style');

  /** Sets the value of "transform-style" */
  void set transformStyle(var value) {
    setProperty('${_browserPrefix}transform-style', value, '');
  }

  /** Gets the value of "transition" */
  String get transition() =>
    getPropertyValue('${_browserPrefix}transition');

  /** Sets the value of "transition" */
  void set transition(var value) {
    setProperty('${_browserPrefix}transition', value, '');
  }

  /** Gets the value of "transition-delay" */
  String get transitionDelay() =>
    getPropertyValue('${_browserPrefix}transition-delay');

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value) {
    setProperty('${_browserPrefix}transition-delay', value, '');
  }

  /** Gets the value of "transition-duration" */
  String get transitionDuration() =>
    getPropertyValue('${_browserPrefix}transition-duration');

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value) {
    setProperty('${_browserPrefix}transition-duration', value, '');
  }

  /** Gets the value of "transition-property" */
  String get transitionProperty() =>
    getPropertyValue('${_browserPrefix}transition-property');

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value) {
    setProperty('${_browserPrefix}transition-property', value, '');
  }

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction() =>
    getPropertyValue('${_browserPrefix}transition-timing-function');

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value) {
    setProperty('${_browserPrefix}transition-timing-function', value, '');
  }

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi() =>
    getPropertyValue('unicode-bidi');

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value) {
    setProperty('unicode-bidi', value, '');
  }

  /** Gets the value of "unicode-range" */
  String get unicodeRange() =>
    getPropertyValue('unicode-range');

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value) {
    setProperty('unicode-range', value, '');
  }

  /** Gets the value of "user-drag" */
  String get userDrag() =>
    getPropertyValue('${_browserPrefix}user-drag');

  /** Sets the value of "user-drag" */
  void set userDrag(var value) {
    setProperty('${_browserPrefix}user-drag', value, '');
  }

  /** Gets the value of "user-modify" */
  String get userModify() =>
    getPropertyValue('${_browserPrefix}user-modify');

  /** Sets the value of "user-modify" */
  void set userModify(var value) {
    setProperty('${_browserPrefix}user-modify', value, '');
  }

  /** Gets the value of "user-select" */
  String get userSelect() =>
    getPropertyValue('${_browserPrefix}user-select');

  /** Sets the value of "user-select" */
  void set userSelect(var value) {
    setProperty('${_browserPrefix}user-select', value, '');
  }

  /** Gets the value of "vertical-align" */
  String get verticalAlign() =>
    getPropertyValue('vertical-align');

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value) {
    setProperty('vertical-align', value, '');
  }

  /** Gets the value of "visibility" */
  String get visibility() =>
    getPropertyValue('visibility');

  /** Sets the value of "visibility" */
  void set visibility(var value) {
    setProperty('visibility', value, '');
  }

  /** Gets the value of "white-space" */
  String get whiteSpace() =>
    getPropertyValue('white-space');

  /** Sets the value of "white-space" */
  void set whiteSpace(var value) {
    setProperty('white-space', value, '');
  }

  /** Gets the value of "widows" */
  String get widows() =>
    getPropertyValue('widows');

  /** Sets the value of "widows" */
  void set widows(var value) {
    setProperty('widows', value, '');
  }

  /** Gets the value of "width" */
  String get width() =>
    getPropertyValue('width');

  /** Sets the value of "width" */
  void set width(var value) {
    setProperty('width', value, '');
  }

  /** Gets the value of "word-break" */
  String get wordBreak() =>
    getPropertyValue('word-break');

  /** Sets the value of "word-break" */
  void set wordBreak(var value) {
    setProperty('word-break', value, '');
  }

  /** Gets the value of "word-spacing" */
  String get wordSpacing() =>
    getPropertyValue('word-spacing');

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value) {
    setProperty('word-spacing', value, '');
  }

  /** Gets the value of "word-wrap" */
  String get wordWrap() =>
    getPropertyValue('word-wrap');

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value) {
    setProperty('word-wrap', value, '');
  }

  /** Gets the value of "wrap-shape" */
  String get wrapShape() =>
    getPropertyValue('${_browserPrefix}wrap-shape');

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value) {
    setProperty('${_browserPrefix}wrap-shape', value, '');
  }

  /** Gets the value of "writing-mode" */
  String get writingMode() =>
    getPropertyValue('${_browserPrefix}writing-mode');

  /** Sets the value of "writing-mode" */
  void set writingMode(var value) {
    setProperty('${_browserPrefix}writing-mode', value, '');
  }

  /** Gets the value of "z-index" */
  String get zIndex() =>
    getPropertyValue('z-index');

  /** Sets the value of "z-index" */
  void set zIndex(var value) {
    setProperty('z-index', value, '');
  }

  /** Gets the value of "zoom" */
  String get zoom() =>
    getPropertyValue('zoom');

  /** Sets the value of "zoom" */
  void set zoom(var value) {
    setProperty('zoom', value, '');
  }
}

class _CSSStyleRuleImpl extends _CSSRuleImpl implements CSSStyleRule {
  _CSSStyleRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get selectorText() => _wrap(_ptr.selectorText);

  void set selectorText(String value) { _ptr.selectorText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSStyleSheetImpl extends _StyleSheetImpl implements CSSStyleSheet {
  _CSSStyleSheetImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  CSSRule get ownerRule() => _wrap(_ptr.ownerRule);

  CSSRuleList get rules() => _wrap(_ptr.rules);

  int addRule(String selector, String style, [int index = null]) => _wrap(_ptr.addRule(_unwrap(selector), _unwrap(style), _unwrap(index)));

  void deleteRule(int index) => _ptr.deleteRule(_unwrap(index));

  int insertRule(String rule, int index) => _wrap(_ptr.insertRule(_unwrap(rule), _unwrap(index)));

  void removeRule(int index) => _ptr.removeRule(_unwrap(index));
}

class _CSSTransformValueImpl extends _CSSValueListImpl implements CSSTransformValue {
  _CSSTransformValueImpl._wrap(ptr) : super._wrap(ptr);

  int get operationType() => _wrap(_ptr.operationType);
}

class _CSSUnknownRuleImpl extends _CSSRuleImpl implements CSSUnknownRule {
  _CSSUnknownRuleImpl._wrap(ptr) : super._wrap(ptr);
}

class _CSSValueImpl extends _DOMTypeBase implements CSSValue {
  _CSSValueImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  int get cssValueType() => _wrap(_ptr.cssValueType);
}

class _CSSValueListImpl extends _CSSValueImpl implements CSSValueList {
  _CSSValueListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  CSSValue item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _CanvasElementImpl extends _ElementImpl implements CanvasElement {
  _CanvasElementImpl._wrap(ptr) : super._wrap(ptr);

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  Object getContext(String contextId) => _wrap(_ptr.getContext(_unwrap(contextId)));

  String toDataURL(String type) => _wrap(_ptr.toDataURL(_unwrap(type)));
}

class _CanvasGradientImpl extends _DOMTypeBase implements CanvasGradient {
  _CanvasGradientImpl._wrap(ptr) : super._wrap(ptr);

  void addColorStop(num offset, String color) => _ptr.addColorStop(_unwrap(offset), _unwrap(color));
}

class _CanvasPatternImpl extends _DOMTypeBase implements CanvasPattern {
  _CanvasPatternImpl._wrap(ptr) : super._wrap(ptr);
}

class _CanvasRenderingContextImpl extends _DOMTypeBase implements CanvasRenderingContext {
  _CanvasRenderingContextImpl._wrap(ptr) : super._wrap(ptr);

  CanvasElement get canvas() => _wrap(_ptr.canvas);
}

class _CanvasRenderingContext2DImpl extends _CanvasRenderingContextImpl implements CanvasRenderingContext2D {
  _CanvasRenderingContext2DImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get fillStyle() => _wrap(_ptr.fillStyle);

  void set fillStyle(Dynamic value) { _ptr.fillStyle = _unwrap(value); }

  String get font() => _wrap(_ptr.font);

  void set font(String value) { _ptr.font = _unwrap(value); }

  num get globalAlpha() => _wrap(_ptr.globalAlpha);

  void set globalAlpha(num value) { _ptr.globalAlpha = _unwrap(value); }

  String get globalCompositeOperation() => _wrap(_ptr.globalCompositeOperation);

  void set globalCompositeOperation(String value) { _ptr.globalCompositeOperation = _unwrap(value); }

  String get lineCap() => _wrap(_ptr.lineCap);

  void set lineCap(String value) { _ptr.lineCap = _unwrap(value); }

  String get lineJoin() => _wrap(_ptr.lineJoin);

  void set lineJoin(String value) { _ptr.lineJoin = _unwrap(value); }

  num get lineWidth() => _wrap(_ptr.lineWidth);

  void set lineWidth(num value) { _ptr.lineWidth = _unwrap(value); }

  num get miterLimit() => _wrap(_ptr.miterLimit);

  void set miterLimit(num value) { _ptr.miterLimit = _unwrap(value); }

  num get shadowBlur() => _wrap(_ptr.shadowBlur);

  void set shadowBlur(num value) { _ptr.shadowBlur = _unwrap(value); }

  String get shadowColor() => _wrap(_ptr.shadowColor);

  void set shadowColor(String value) { _ptr.shadowColor = _unwrap(value); }

  num get shadowOffsetX() => _wrap(_ptr.shadowOffsetX);

  void set shadowOffsetX(num value) { _ptr.shadowOffsetX = _unwrap(value); }

  num get shadowOffsetY() => _wrap(_ptr.shadowOffsetY);

  void set shadowOffsetY(num value) { _ptr.shadowOffsetY = _unwrap(value); }

  Dynamic get strokeStyle() => _wrap(_ptr.strokeStyle);

  void set strokeStyle(Dynamic value) { _ptr.strokeStyle = _unwrap(value); }

  String get textAlign() => _wrap(_ptr.textAlign);

  void set textAlign(String value) { _ptr.textAlign = _unwrap(value); }

  String get textBaseline() => _wrap(_ptr.textBaseline);

  void set textBaseline(String value) { _ptr.textBaseline = _unwrap(value); }

  num get webkitBackingStorePixelRatio() => _wrap(_ptr.webkitBackingStorePixelRatio);

  List get webkitLineDash() => _wrap(_ptr.webkitLineDash);

  void set webkitLineDash(List value) { _ptr.webkitLineDash = _unwrap(value); }

  num get webkitLineDashOffset() => _wrap(_ptr.webkitLineDashOffset);

  void set webkitLineDashOffset(num value) { _ptr.webkitLineDashOffset = _unwrap(value); }

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) => _ptr.arc(_unwrap(x), _unwrap(y), _unwrap(radius), _unwrap(startAngle), _unwrap(endAngle), _unwrap(anticlockwise));

  void arcTo(num x1, num y1, num x2, num y2, num radius) => _ptr.arcTo(_unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2), _unwrap(radius));

  void beginPath() => _ptr.beginPath();

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) => _ptr.bezierCurveTo(_unwrap(cp1x), _unwrap(cp1y), _unwrap(cp2x), _unwrap(cp2y), _unwrap(x), _unwrap(y));

  void clearRect(num x, num y, num width, num height) => _ptr.clearRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));

  void clearShadow() => _ptr.clearShadow();

  void clip() => _ptr.clip();

  void closePath() => _ptr.closePath();

  ImageData createImageData(imagedata_OR_sw, [num sh = null]) => _wrap(_ptr.createImageData(_unwrap(imagedata_OR_sw), _unwrap(sh)));

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) => _wrap(_ptr.createLinearGradient(_unwrap(x0), _unwrap(y0), _unwrap(x1), _unwrap(y1)));

  CanvasPattern createPattern(canvas_OR_image, String repetitionType) => _wrap(_ptr.createPattern(_unwrap(canvas_OR_image), _unwrap(repetitionType)));

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) => _wrap(_ptr.createRadialGradient(_unwrap(x0), _unwrap(y0), _unwrap(r0), _unwrap(x1), _unwrap(y1), _unwrap(r1)));

  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width = null, num height_OR_sh = null, num dx = null, num dy = null, num dw = null, num dh = null]) => _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));

  void drawImageFromRect(ImageElement image, [num sx = null, num sy = null, num sw = null, num sh = null, num dx = null, num dy = null, num dw = null, num dh = null, String compositeOperation = null]) => _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh), _unwrap(compositeOperation));

  void fill() => _ptr.fill();

  void fillRect(num x, num y, num width, num height) => _ptr.fillRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));

  void fillText(String text, num x, num y, [num maxWidth = null]) => _ptr.fillText(_unwrap(text), _unwrap(x), _unwrap(y), _unwrap(maxWidth));

  ImageData getImageData(num sx, num sy, num sw, num sh) => _wrap(_ptr.getImageData(_unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh)));

  bool isPointInPath(num x, num y) => _wrap(_ptr.isPointInPath(_unwrap(x), _unwrap(y)));

  void lineTo(num x, num y) => _ptr.lineTo(_unwrap(x), _unwrap(y));

  TextMetrics measureText(String text) => _wrap(_ptr.measureText(_unwrap(text)));

  void moveTo(num x, num y) => _ptr.moveTo(_unwrap(x), _unwrap(y));

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) => _ptr.putImageData(_unwrap(imagedata), _unwrap(dx), _unwrap(dy), _unwrap(dirtyX), _unwrap(dirtyY), _unwrap(dirtyWidth), _unwrap(dirtyHeight));

  void quadraticCurveTo(num cpx, num cpy, num x, num y) => _ptr.quadraticCurveTo(_unwrap(cpx), _unwrap(cpy), _unwrap(x), _unwrap(y));

  void rect(num x, num y, num width, num height) => _ptr.rect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));

  void restore() => _ptr.restore();

  void rotate(num angle) => _ptr.rotate(_unwrap(angle));

  void save() => _ptr.save();

  void scale(num sx, num sy) => _ptr.scale(_unwrap(sx), _unwrap(sy));

  void setAlpha(num alpha) => _ptr.setAlpha(_unwrap(alpha));

  void setCompositeOperation(String compositeOperation) => _ptr.setCompositeOperation(_unwrap(compositeOperation));

  void setFillColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) => _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));

  void setLineCap(String cap) => _ptr.setLineCap(_unwrap(cap));

  void setLineJoin(String join) => _ptr.setLineJoin(_unwrap(join));

  void setLineWidth(num width) => _ptr.setLineWidth(_unwrap(width));

  void setMiterLimit(num limit) => _ptr.setMiterLimit(_unwrap(limit));

  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r = null, num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) => _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));

  void setStrokeColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) => _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) => _ptr.setTransform(_unwrap(m11), _unwrap(m12), _unwrap(m21), _unwrap(m22), _unwrap(dx), _unwrap(dy));

  void stroke() => _ptr.stroke();

  void strokeRect(num x, num y, num width, num height, [num lineWidth = null]) => _ptr.strokeRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(lineWidth));

  void strokeText(String text, num x, num y, [num maxWidth = null]) => _ptr.strokeText(_unwrap(text), _unwrap(x), _unwrap(y), _unwrap(maxWidth));

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) => _ptr.transform(_unwrap(m11), _unwrap(m12), _unwrap(m21), _unwrap(m22), _unwrap(dx), _unwrap(dy));

  void translate(num tx, num ty) => _ptr.translate(_unwrap(tx), _unwrap(ty));

  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh) => _wrap(_ptr.webkitGetImageDataHD(_unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh)));

  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) => _ptr.webkitPutImageDataHD(_unwrap(imagedata), _unwrap(dx), _unwrap(dy), _unwrap(dirtyX), _unwrap(dirtyY), _unwrap(dirtyWidth), _unwrap(dirtyHeight));
}

class _CharacterDataImpl extends _NodeImpl implements CharacterData {
  _CharacterDataImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  void appendData(String data) => _ptr.appendData(_unwrap(data));

  void deleteData(int offset, int length) => _ptr.deleteData(_unwrap(offset), _unwrap(length));

  void insertData(int offset, String data) => _ptr.insertData(_unwrap(offset), _unwrap(data));

  void replaceData(int offset, int length, String data) => _ptr.replaceData(_unwrap(offset), _unwrap(length), _unwrap(data));

  String substringData(int offset, int length) => _wrap(_ptr.substringData(_unwrap(offset), _unwrap(length)));
}

class _ClientRectImpl extends _DOMTypeBase implements ClientRect {
  _ClientRectImpl._wrap(ptr) : super._wrap(ptr);

  num get bottom() => _wrap(_ptr.bottom);

  num get height() => _wrap(_ptr.height);

  num get left() => _wrap(_ptr.left);

  num get right() => _wrap(_ptr.right);

  num get top() => _wrap(_ptr.top);

  num get width() => _wrap(_ptr.width);
}

class _ClientRectListImpl extends _DOMTypeBase implements ClientRectList {
  _ClientRectListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  ClientRect item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _ClipboardImpl extends _DOMTypeBase implements Clipboard {
  _ClipboardImpl._wrap(ptr) : super._wrap(ptr);

  String get dropEffect() => _wrap(_ptr.dropEffect);

  void set dropEffect(String value) { _ptr.dropEffect = _unwrap(value); }

  String get effectAllowed() => _wrap(_ptr.effectAllowed);

  void set effectAllowed(String value) { _ptr.effectAllowed = _unwrap(value); }

  FileList get files() => _wrap(_ptr.files);

  DataTransferItemList get items() => _wrap(_ptr.items);

  List get types() => _wrap(_ptr.types);

  void clearData([String type = null]) => _ptr.clearData(_unwrap(type));

  String getData(String type) => _wrap(_ptr.getData(_unwrap(type)));

  bool setData(String type, String data) => _wrap(_ptr.setData(_unwrap(type), _unwrap(data)));

  void setDragImage(ImageElement image, int x, int y) => _ptr.setDragImage(_unwrap(image), _unwrap(x), _unwrap(y));
}

class _CloseEventImpl extends _EventImpl implements CloseEvent {
  _CloseEventImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get reason() => _wrap(_ptr.reason);

  bool get wasClean() => _wrap(_ptr.wasClean);
}

class _CommentImpl extends _CharacterDataImpl implements Comment {
  _CommentImpl._wrap(ptr) : super._wrap(ptr);
}

class _CompositionEventImpl extends _UIEventImpl implements CompositionEvent {
  _CompositionEventImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) => _ptr.initCompositionEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(viewArg), _unwrap(dataArg));
}

class _ConsoleImpl extends _DOMTypeBase implements Console {
  _ConsoleImpl._wrap(ptr) : super._wrap(ptr);

  MemoryInfo get memory() => _wrap(_ptr.memory);

  List<ScriptProfile> get profiles() => _wrap(_ptr.profiles);

  void assertCondition(bool condition, Object arg) => _ptr.assertCondition(_unwrap(condition), _unwrap(arg));

  void count() => _ptr.count();

  void debug(Object arg) => _ptr.debug(_unwrap(arg));

  void dir() => _ptr.dir();

  void dirxml() => _ptr.dirxml();

  void error(Object arg) => _ptr.error(_unwrap(arg));

  void group(Object arg) => _ptr.group(_unwrap(arg));

  void groupCollapsed(Object arg) => _ptr.groupCollapsed(_unwrap(arg));

  void groupEnd() => _ptr.groupEnd();

  void info(Object arg) => _ptr.info(_unwrap(arg));

  void log(Object arg) => _ptr.log(_unwrap(arg));

  void markTimeline() => _ptr.markTimeline();

  void profile(String title) => _ptr.profile(_unwrap(title));

  void profileEnd(String title) => _ptr.profileEnd(_unwrap(title));

  void time(String title) => _ptr.time(_unwrap(title));

  void timeEnd(String title, Object arg) => _ptr.timeEnd(_unwrap(title), _unwrap(arg));

  void timeStamp(Object arg) => _ptr.timeStamp(_unwrap(arg));

  void trace(Object arg) => _ptr.trace(_unwrap(arg));

  void warn(Object arg) => _ptr.warn(_unwrap(arg));
}

class _ContentElementImpl extends _ElementImpl implements ContentElement {
  _ContentElementImpl._wrap(ptr) : super._wrap(ptr);

  String get select() => _wrap(_ptr.select);

  void set select(String value) { _ptr.select = _unwrap(value); }
}

class _ConvolverNodeImpl extends _AudioNodeImpl implements ConvolverNode {
  _ConvolverNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get buffer() => _wrap(_ptr.buffer);

  void set buffer(AudioBuffer value) { _ptr.buffer = _unwrap(value); }

  bool get normalize() => _wrap(_ptr.normalize);

  void set normalize(bool value) { _ptr.normalize = _unwrap(value); }
}

class _CoordinatesImpl extends _DOMTypeBase implements Coordinates {
  _CoordinatesImpl._wrap(ptr) : super._wrap(ptr);

  num get accuracy() => _wrap(_ptr.accuracy);

  num get altitude() => _wrap(_ptr.altitude);

  num get altitudeAccuracy() => _wrap(_ptr.altitudeAccuracy);

  num get heading() => _wrap(_ptr.heading);

  num get latitude() => _wrap(_ptr.latitude);

  num get longitude() => _wrap(_ptr.longitude);

  num get speed() => _wrap(_ptr.speed);
}

class _CounterImpl extends _DOMTypeBase implements Counter {
  _CounterImpl._wrap(ptr) : super._wrap(ptr);

  String get identifier() => _wrap(_ptr.identifier);

  String get listStyle() => _wrap(_ptr.listStyle);

  String get separator() => _wrap(_ptr.separator);
}

class _CryptoImpl extends _DOMTypeBase implements Crypto {
  _CryptoImpl._wrap(ptr) : super._wrap(ptr);

  void getRandomValues(ArrayBufferView array) => _ptr.getRandomValues(_unwrap(array));
}

class _CustomEventImpl extends _EventImpl implements CustomEvent {
  _CustomEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get detail() => _wrap(_ptr.detail);

  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) => _ptr.initCustomEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(detailArg));
}

class _DListElementImpl extends _ElementImpl implements DListElement {
  _DListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _DOMApplicationCacheImpl extends _EventTargetImpl implements DOMApplicationCache {
  _DOMApplicationCacheImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get status() => _wrap(_ptr.status);

  void abort() => _ptr.abort();

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void swapCache() => _ptr.swapCache();

  void update() => _ptr.update();
}

class _DOMExceptionImpl extends _DOMTypeBase implements DOMException {
  _DOMExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _DOMFileSystemImpl extends _DOMTypeBase implements DOMFileSystem {
  _DOMFileSystemImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  DirectoryEntry get root() => _wrap(_ptr.root);
}

class _DOMFileSystemSyncImpl extends _DOMTypeBase implements DOMFileSystemSync {
  _DOMFileSystemSyncImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  DirectoryEntrySync get root() => _wrap(_ptr.root);
}

class _DOMFormDataImpl extends _DOMTypeBase implements DOMFormData {
  _DOMFormDataImpl._wrap(ptr) : super._wrap(ptr);

  void append(String name, String value, String filename) => _ptr.append(_unwrap(name), _unwrap(value), _unwrap(filename));
}

class _DOMImplementationImpl extends _DOMTypeBase implements DOMImplementation {
  _DOMImplementationImpl._wrap(ptr) : super._wrap(ptr);

  CSSStyleSheet createCSSStyleSheet(String title, String media) => _wrap(_ptr.createCSSStyleSheet(_unwrap(title), _unwrap(media)));

  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) => _wrap(_ptr.createDocument(_unwrap(namespaceURI), _unwrap(qualifiedName), _unwrap(doctype)));

  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) => _wrap(_ptr.createDocumentType(_unwrap(qualifiedName), _unwrap(publicId), _unwrap(systemId)));

  Document createHTMLDocument(String title) => _wrap(_ptr.createHTMLDocument(_unwrap(title)));

  bool hasFeature(String feature, String version) => _wrap(_ptr.hasFeature(_unwrap(feature), _unwrap(version)));
}

class _DOMMimeTypeImpl extends _DOMTypeBase implements DOMMimeType {
  _DOMMimeTypeImpl._wrap(ptr) : super._wrap(ptr);

  String get description() => _wrap(_ptr.description);

  DOMPlugin get enabledPlugin() => _wrap(_ptr.enabledPlugin);

  String get suffixes() => _wrap(_ptr.suffixes);

  String get type() => _wrap(_ptr.type);
}

class _DOMMimeTypeArrayImpl extends _DOMTypeBase implements DOMMimeTypeArray {
  _DOMMimeTypeArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  DOMMimeType item(int index) => _wrap(_ptr.item(_unwrap(index)));

  DOMMimeType namedItem(String name) => _wrap(_ptr.namedItem(_unwrap(name)));
}

class _DOMParserImpl extends _DOMTypeBase implements DOMParser {
  _DOMParserImpl._wrap(ptr) : super._wrap(ptr);

  Document parseFromString(String str, String contentType) => _wrap(_ptr.parseFromString(_unwrap(str), _unwrap(contentType)));
}

class _DOMPluginImpl extends _DOMTypeBase implements DOMPlugin {
  _DOMPluginImpl._wrap(ptr) : super._wrap(ptr);

  String get description() => _wrap(_ptr.description);

  String get filename() => _wrap(_ptr.filename);

  int get length() => _wrap(_ptr.length);

  String get name() => _wrap(_ptr.name);

  DOMMimeType item(int index) => _wrap(_ptr.item(_unwrap(index)));

  DOMMimeType namedItem(String name) => _wrap(_ptr.namedItem(_unwrap(name)));
}

class _DOMPluginArrayImpl extends _DOMTypeBase implements DOMPluginArray {
  _DOMPluginArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  DOMPlugin item(int index) => _wrap(_ptr.item(_unwrap(index)));

  DOMPlugin namedItem(String name) => _wrap(_ptr.namedItem(_unwrap(name)));

  void refresh(bool reload) => _ptr.refresh(_unwrap(reload));
}

class _DOMSelectionImpl extends _DOMTypeBase implements DOMSelection {
  _DOMSelectionImpl._wrap(ptr) : super._wrap(ptr);

  Node get anchorNode() => _wrap(_ptr.anchorNode);

  int get anchorOffset() => _wrap(_ptr.anchorOffset);

  Node get baseNode() => _wrap(_ptr.baseNode);

  int get baseOffset() => _wrap(_ptr.baseOffset);

  Node get extentNode() => _wrap(_ptr.extentNode);

  int get extentOffset() => _wrap(_ptr.extentOffset);

  Node get focusNode() => _wrap(_ptr.focusNode);

  int get focusOffset() => _wrap(_ptr.focusOffset);

  bool get isCollapsed() => _wrap(_ptr.isCollapsed);

  int get rangeCount() => _wrap(_ptr.rangeCount);

  String get type() => _wrap(_ptr.type);

  void addRange(Range range) => _ptr.addRange(_unwrap(range));

  void collapse(Node node, int index) => _ptr.collapse(_unwrap(node), _unwrap(index));

  void collapseToEnd() => _ptr.collapseToEnd();

  void collapseToStart() => _ptr.collapseToStart();

  bool containsNode(Node node, bool allowPartial) => _wrap(_ptr.containsNode(_unwrap(node), _unwrap(allowPartial)));

  void deleteFromDocument() => _ptr.deleteFromDocument();

  void empty() => _ptr.empty();

  void extend(Node node, int offset) => _ptr.extend(_unwrap(node), _unwrap(offset));

  Range getRangeAt(int index) => _wrap(_ptr.getRangeAt(_unwrap(index)));

  void modify(String alter, String direction, String granularity) => _ptr.modify(_unwrap(alter), _unwrap(direction), _unwrap(granularity));

  void removeAllRanges() => _ptr.removeAllRanges();

  void selectAllChildren(Node node) => _ptr.selectAllChildren(_unwrap(node));

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) => _ptr.setBaseAndExtent(_unwrap(baseNode), _unwrap(baseOffset), _unwrap(extentNode), _unwrap(extentOffset));

  void setPosition(Node node, int offset) => _ptr.setPosition(_unwrap(node), _unwrap(offset));

  String toString() => _wrap(_ptr.toString());
}

class _DOMSettableTokenListImpl extends _DOMTokenListImpl implements DOMSettableTokenList {
  _DOMSettableTokenListImpl._wrap(ptr) : super._wrap(ptr);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _DOMStringListImpl extends _DOMTypeBase implements DOMStringList {
  _DOMStringListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  String operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<String>(this);
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(String element)) => _Collections.forEach(this, f);

  Collection map(f(String element)) => _Collections.map(this, [], f);

  Collection<String> filter(bool f(String element)) =>
     _Collections.filter(this, <String>[], f);

  bool every(bool f(String element)) => _Collections.every(this, f);

  bool some(bool f(String element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<String>:

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  String last() => this[length - 1];

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  bool contains(String string) => _wrap(_ptr.contains(_unwrap(string)));

  String item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _DOMStringMapImpl extends _DOMTypeBase implements DOMStringMap {
  _DOMStringMapImpl._wrap(ptr) : super._wrap(ptr);
}

class _DOMTokenListImpl extends _DOMTypeBase implements DOMTokenList {
  _DOMTokenListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void add(String token) => _ptr.add(_unwrap(token));

  bool contains(String token) => _wrap(_ptr.contains(_unwrap(token)));

  String item(int index) => _wrap(_ptr.item(_unwrap(index)));

  void remove(String token) => _ptr.remove(_unwrap(token));

  String toString() => _wrap(_ptr.toString());

  bool toggle(String token) => _wrap(_ptr.toggle(_unwrap(token)));
}

class _DOMURLImpl extends _DOMTypeBase implements DOMURL {
  _DOMURLImpl._wrap(ptr) : super._wrap(ptr);
}

class _DataTransferItemImpl extends _DOMTypeBase implements DataTransferItem {
  _DataTransferItemImpl._wrap(ptr) : super._wrap(ptr);

  String get kind() => _wrap(_ptr.kind);

  String get type() => _wrap(_ptr.type);

  Blob getAsFile() => _wrap(_ptr.getAsFile());

  void getAsString([StringCallback callback = null]) => _ptr.getAsString(_unwrap(callback));

  void webkitGetAsEntry([EntryCallback callback = null]) => _ptr.webkitGetAsEntry(_unwrap(callback));
}

class _DataTransferItemListImpl extends _DOMTypeBase implements DataTransferItemList {
  _DataTransferItemListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void add(data_OR_file, [String type = null]) => _ptr.add(_unwrap(data_OR_file), _unwrap(type));

  void clear() => _ptr.clear();

  DataTransferItem item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _DataViewImpl extends _ArrayBufferViewImpl implements DataView {
  _DataViewImpl._wrap(ptr) : super._wrap(ptr);

  num getFloat32(int byteOffset, [bool littleEndian = null]) => _wrap(_ptr.getFloat32(_unwrap(byteOffset), _unwrap(littleEndian)));

  num getFloat64(int byteOffset, [bool littleEndian = null]) => _wrap(_ptr.getFloat64(_unwrap(byteOffset), _unwrap(littleEndian)));

  int getInt16(int byteOffset, [bool littleEndian = null]) => _wrap(_ptr.getInt16(_unwrap(byteOffset), _unwrap(littleEndian)));

  int getInt32(int byteOffset, [bool littleEndian = null]) => _wrap(_ptr.getInt32(_unwrap(byteOffset), _unwrap(littleEndian)));

  Object getInt8() => _wrap(_ptr.getInt8());

  int getUint16(int byteOffset, [bool littleEndian = null]) => _wrap(_ptr.getUint16(_unwrap(byteOffset), _unwrap(littleEndian)));

  int getUint32(int byteOffset, [bool littleEndian = null]) => _wrap(_ptr.getUint32(_unwrap(byteOffset), _unwrap(littleEndian)));

  Object getUint8() => _wrap(_ptr.getUint8());

  void setFloat32(int byteOffset, num value, [bool littleEndian = null]) => _ptr.setFloat32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));

  void setFloat64(int byteOffset, num value, [bool littleEndian = null]) => _ptr.setFloat64(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));

  void setInt16(int byteOffset, int value, [bool littleEndian = null]) => _ptr.setInt16(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));

  void setInt32(int byteOffset, int value, [bool littleEndian = null]) => _ptr.setInt32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));

  void setInt8() => _ptr.setInt8();

  void setUint16(int byteOffset, int value, [bool littleEndian = null]) => _ptr.setUint16(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));

  void setUint32(int byteOffset, int value, [bool littleEndian = null]) => _ptr.setUint32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));

  void setUint8() => _ptr.setUint8();
}

class _DatabaseImpl extends _DOMTypeBase implements Database {
  _DatabaseImpl._wrap(ptr) : super._wrap(ptr);

  String get version() => _wrap(_ptr.version);

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback = null, SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) => _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) => _ptr.readTransaction(_unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) => _ptr.transaction(_unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
}

class _DatabaseSyncImpl extends _DOMTypeBase implements DatabaseSync {
  _DatabaseSyncImpl._wrap(ptr) : super._wrap(ptr);

  String get lastErrorMessage() => _wrap(_ptr.lastErrorMessage);

  String get version() => _wrap(_ptr.version);

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback = null]) => _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback));

  void readTransaction(SQLTransactionSyncCallback callback) => _ptr.readTransaction(_unwrap(callback));

  void transaction(SQLTransactionSyncCallback callback) => _ptr.transaction(_unwrap(callback));
}

class _DedicatedWorkerContextImpl extends _WorkerContextImpl implements DedicatedWorkerContext {
  _DedicatedWorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  void postMessage(Object message, [List messagePorts = null]) => _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));

  void webkitPostMessage(Object message, [List transferList = null]) => _ptr.webkitPostMessage(_unwrap(message), _unwrap(transferList));
}

class _DelayNodeImpl extends _AudioNodeImpl implements DelayNode {
  _DelayNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get delayTime() => _wrap(_ptr.delayTime);
}

class _DeprecatedPeerConnectionImpl extends _EventTargetImpl implements DeprecatedPeerConnection {
  _DeprecatedPeerConnectionImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  MediaStreamList get localStreams() => _wrap(_ptr.localStreams);

  int get readyState() => _wrap(_ptr.readyState);

  MediaStreamList get remoteStreams() => _wrap(_ptr.remoteStreams);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void addStream(MediaStream stream) => _ptr.addStream(_unwrap(stream));

  void close() => _ptr.close();

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  void processSignalingMessage(String message) => _ptr.processSignalingMessage(_unwrap(message));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void removeStream(MediaStream stream) => _ptr.removeStream(_unwrap(stream));

  void send(String text) => _ptr.send(_unwrap(text));
}

class _DetailsElementImpl extends _ElementImpl implements DetailsElement {
  _DetailsElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get open() => _wrap(_ptr.open);

  void set open(bool value) { _ptr.open = _unwrap(value); }
}

class _DeviceMotionEventImpl extends _EventImpl implements DeviceMotionEvent {
  _DeviceMotionEventImpl._wrap(ptr) : super._wrap(ptr);

  num get interval() => _wrap(_ptr.interval);
}

class _DeviceOrientationEventImpl extends _EventImpl implements DeviceOrientationEvent {
  _DeviceOrientationEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get absolute() => _wrap(_ptr.absolute);

  num get alpha() => _wrap(_ptr.alpha);

  num get beta() => _wrap(_ptr.beta);

  num get gamma() => _wrap(_ptr.gamma);

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) => _ptr.initDeviceOrientationEvent(_unwrap(type), _unwrap(bubbles), _unwrap(cancelable), _unwrap(alpha), _unwrap(beta), _unwrap(gamma), _unwrap(absolute));
}

class _DirectoryElementImpl extends _ElementImpl implements DirectoryElement {
  _DirectoryElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _DirectoryEntryImpl extends _EntryImpl implements DirectoryEntry {
  _DirectoryEntryImpl._wrap(ptr) : super._wrap(ptr);

  DirectoryReader createReader() => _wrap(_ptr.createReader());

  void getDirectory(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.getDirectory(_unwrap(path), _unwrap(flags), _unwrap(successCallback), _unwrap(errorCallback));

  void getFile(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.getFile(_unwrap(path), _unwrap(flags), _unwrap(successCallback), _unwrap(errorCallback));

  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.removeRecursively(_unwrap(successCallback), _unwrap(errorCallback));
}

class _DirectoryEntrySyncImpl extends _EntrySyncImpl implements DirectoryEntrySync {
  _DirectoryEntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  DirectoryReaderSync createReader() => _wrap(_ptr.createReader());

  DirectoryEntrySync getDirectory(String path, Object flags) => _wrap(_ptr.getDirectory(_unwrap(path), _unwrap(flags)));

  FileEntrySync getFile(String path, Object flags) => _wrap(_ptr.getFile(_unwrap(path), _unwrap(flags)));

  void removeRecursively() => _ptr.removeRecursively();
}

class _DirectoryReaderImpl extends _DOMTypeBase implements DirectoryReader {
  _DirectoryReaderImpl._wrap(ptr) : super._wrap(ptr);

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.readEntries(_unwrap(successCallback), _unwrap(errorCallback));
}

class _DirectoryReaderSyncImpl extends _DOMTypeBase implements DirectoryReaderSync {
  _DirectoryReaderSyncImpl._wrap(ptr) : super._wrap(ptr);

  EntryArraySync readEntries() => _wrap(_ptr.readEntries());
}

class _DivElementImpl extends _ElementImpl implements DivElement {
  _DivElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DocumentImpl extends _NodeImpl
    implements Document
    {

  _DocumentImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  Element get activeElement() => _wrap(_ptr.activeElement);

  Element get body() => _wrap(_ptr.body);

  void set body(Element value) { _ptr.body = _unwrap(value); }

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get cookie() => _wrap(_ptr.cookie);

  void set cookie(String value) { _ptr.cookie = _unwrap(value); }

  Window get window() => _wrap(_ptr.window);

  Element get documentElement() => _wrap(_ptr.documentElement);

  String get domain() => _wrap(_ptr.domain);

  HeadElement get head() => _wrap(_ptr.head);

  String get lastModified() => _wrap(_ptr.lastModified);

  String get preferredStylesheetSet() => _wrap(_ptr.preferredStylesheetSet);

  String get readyState() => _wrap(_ptr.readyState);

  String get referrer() => _wrap(_ptr.referrer);

  String get selectedStylesheetSet() => _wrap(_ptr.selectedStylesheetSet);

  void set selectedStylesheetSet(String value) { _ptr.selectedStylesheetSet = _unwrap(value); }

  StyleSheetList get styleSheets() => _wrap(_ptr.styleSheets);

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  Element get webkitCurrentFullScreenElement() => _wrap(_ptr.webkitCurrentFullScreenElement);

  bool get webkitFullScreenKeyboardInputAllowed() => _wrap(_ptr.webkitFullScreenKeyboardInputAllowed);

  Element get webkitFullscreenElement() => _wrap(_ptr.webkitFullscreenElement);

  bool get webkitFullscreenEnabled() => _wrap(_ptr.webkitFullscreenEnabled);

  bool get webkitHidden() => _wrap(_ptr.webkitHidden);

  bool get webkitIsFullScreen() => _wrap(_ptr.webkitIsFullScreen);

  String get webkitVisibilityState() => _wrap(_ptr.webkitVisibilityState);

  Range caretRangeFromPoint(int x, int y) => _wrap(_ptr.caretRangeFromPoint(_unwrap(x), _unwrap(y)));

  CDATASection createCDATASection(String data) => _wrap(_ptr.createCDATASection(_unwrap(data)));

  DocumentFragment createDocumentFragment() => _wrap(_ptr.createDocumentFragment());

  Element $dom_createElement(String tagName) => _wrap(_ptr.$dom_createElement(_unwrap(tagName)));

  Element $dom_createElementNS(String namespaceURI, String qualifiedName) => _wrap(_ptr.$dom_createElementNS(_unwrap(namespaceURI), _unwrap(qualifiedName)));

  Event $dom_createEvent(String eventType) => _wrap(_ptr.$dom_createEvent(_unwrap(eventType)));

  Range createRange() => _wrap(_ptr.createRange());

  Text $dom_createTextNode(String data) => _wrap(_ptr.$dom_createTextNode(_unwrap(data)));

  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) => _wrap(_ptr.createTouch(_unwrap(window), _unwrap(target), _unwrap(identifier), _unwrap(pageX), _unwrap(pageY), _unwrap(screenX), _unwrap(screenY), _unwrap(webkitRadiusX), _unwrap(webkitRadiusY), _unwrap(webkitRotationAngle), _unwrap(webkitForce)));

  TouchList $dom_createTouchList() => _wrap(_ptr.$dom_createTouchList());

  Element elementFromPoint(int x, int y) => _wrap(_ptr.elementFromPoint(_unwrap(x), _unwrap(y)));

  bool execCommand(String command, bool userInterface, String value) => _wrap(_ptr.execCommand(_unwrap(command), _unwrap(userInterface), _unwrap(value)));

  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height) => _wrap(_ptr.getCSSCanvasContext(_unwrap(contextId), _unwrap(name), _unwrap(width), _unwrap(height)));

  Element $dom_getElementById(String elementId) => _wrap(_ptr.$dom_getElementById(_unwrap(elementId)));

  NodeList $dom_getElementsByClassName(String tagname) => _wrap(_ptr.$dom_getElementsByClassName(_unwrap(tagname)));

  NodeList $dom_getElementsByName(String elementName) => _wrap(_ptr.$dom_getElementsByName(_unwrap(elementName)));

  NodeList $dom_getElementsByTagName(String tagname) => _wrap(_ptr.$dom_getElementsByTagName(_unwrap(tagname)));

  bool queryCommandEnabled(String command) => _wrap(_ptr.queryCommandEnabled(_unwrap(command)));

  bool queryCommandIndeterm(String command) => _wrap(_ptr.queryCommandIndeterm(_unwrap(command)));

  bool queryCommandState(String command) => _wrap(_ptr.queryCommandState(_unwrap(command)));

  bool queryCommandSupported(String command) => _wrap(_ptr.queryCommandSupported(_unwrap(command)));

  String queryCommandValue(String command) => _wrap(_ptr.queryCommandValue(_unwrap(command)));

  NodeList $dom_querySelectorAll(String selectors) => _wrap(_ptr.$dom_querySelectorAll(_unwrap(selectors)));

  void webkitCancelFullScreen() => _ptr.webkitCancelFullScreen();

  void webkitExitFullscreen() => _ptr.webkitExitFullscreen();

  WebKitNamedFlow webkitGetFlowByName(String name) => _wrap(_ptr.webkitGetFlowByName(_unwrap(name)));

  // TODO(jacobr): implement all Element methods not on Document. 

  _ElementImpl query(String selectors) {
    // It is fine for our RegExp to detect element id query selectors to have
    // false negatives but not false positives.
    if (const RegExp("^#[_a-zA-Z]\\w*\$").hasMatch(selectors)) {
      return $dom_getElementById(selectors.substring(1));
    }
    return $dom_querySelector(selectors);
  }

// TODO(jacobr): autogenerate this method.
  _ElementImpl $dom_querySelector(String selectors) =>
      _wrap(_ptr.query(selectors));

  ElementList queryAll(String selectors) {
    if (const RegExp("""^\\[name=["'][^'"]+['"]\\]\$""").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByName(
          selectors.substring(7,selectors.length - 2));
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else if (const RegExp("^[*a-zA-Z0-9]+\$").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByTagName(selectors);
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else {
      return new _FrozenElementList._wrap($dom_querySelectorAll(selectors));
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class FilteredElementList implements ElementList {
  final Node _node;
  final NodeList _childNodes;

  FilteredElementList(Node node): _childNodes = node.nodes, _node = node;

  // We can't memoize this, since it's possible that children will be messed
  // with externally to this class.
  //
  // TODO(nweiz): Do we really need to copy the list to make the types work out?
  List<Element> get _filtered() =>
    new List.from(_childNodes.filter((n) => n is Element));

  // Don't use _filtered.first so we can short-circuit once we find an element.
  Element get first() {
    for (final node in _childNodes) {
      if (node is Element) {
        return node;
      }
    }
    return null;
  }

  void forEach(void f(Element element)) {
    _filtered.forEach(f);
  }

  void operator []=(int index, Element value) {
    this[index].replaceWith(value);
  }

  void set length(int newLength) {
    final len = this.length;
    if (newLength >= len) {
      return;
    } else if (newLength < 0) {
      throw const IllegalArgumentException("Invalid list length");
    }

    removeRange(newLength - 1, len - newLength);
  }

  void add(Element value) {
    _childNodes.add(value);
  }

  void addAll(Collection<Element> collection) {
    collection.forEach(add);
  }

  void addLast(Element value) {
    add(value);
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw const NotImplementedException();
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int rangeLength) {
    _filtered.getRange(start, rangeLength).forEach((el) => el.remove());
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw const NotImplementedException();
  }

  void clear() {
    // Currently, ElementList#clear clears even non-element nodes, so we follow
    // that behavior.
    _childNodes.clear();
  }

  Element removeLast() {
    final result = this.last();
    if (result != null) {
      result.remove();
    }
    return result;
  }

  Collection map(f(Element element)) => _filtered.map(f);
  Collection<Element> filter(bool f(Element element)) => _filtered.filter(f);
  bool every(bool f(Element element)) => _filtered.every(f);
  bool some(bool f(Element element)) => _filtered.some(f);
  bool isEmpty() => _filtered.isEmpty();
  int get length() => _filtered.length;
  Element operator [](int index) => _filtered[index];
  Iterator<Element> iterator() => _filtered.iterator();
  List<Element> getRange(int start, int rangeLength) =>
    _filtered.getRange(start, rangeLength);
  int indexOf(Element element, [int start = 0]) =>
    _filtered.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _filtered.lastIndexOf(element, start);
  }

  Element last() => _filtered.last();
}

Future<CSSStyleDeclaration> _emptyStyleFuture() {
  return _createMeasurementFuture(() => new Element.tag('div').style,
                                  new Completer<CSSStyleDeclaration>());
}

class EmptyElementRect implements ElementRect {
  final ClientRect client = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect offset = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect scroll = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect bounding = const _SimpleClientRect(0, 0, 0, 0);
  final List<ClientRect> clientRects = const <ClientRect>[];

  const EmptyElementRect();
}

class _DocumentFragmentImpl extends _NodeImpl implements DocumentFragment {
  ElementList _elements;

  ElementList get elements() {
    if (_elements == null) {
      _elements = new FilteredElementList(this);
    }
    return _elements;
  }

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  void set elements(value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    final elements = this.elements;
    elements.clear();
    elements.addAll(copy);
  }

  ElementList queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  String get innerHTML() {
    final e = new Element.tag("div");
    e.nodes.add(this.clone(true));
    return e.innerHTML;
  }

  String get outerHTML() => innerHTML;

  // TODO(nweiz): Do we want to support some variant of innerHTML for XML and/or
  // SVG strings?
  void set innerHTML(String value) {
    this.nodes.clear();

    final e = new Element.tag("div");
    e.innerHTML = value;

    // Copy list first since we don't want liveness during iteration.
    List nodes = new List.from(e.nodes);
    this.nodes.addAll(nodes);
  }

  Node _insertAdjacentNode(String where, Node node) {
    switch (where.toLowerCase()) {
      case "beforebegin": return null;
      case "afterend": return null;
      case "afterbegin":
        this.insertBefore(node, this.nodes.first);
        return node;
      case "beforeend":
        this.nodes.add(node);
        return node;
      default:
        throw new IllegalArgumentException("Invalid position ${where}");
    }
  }

  Element insertAdjacentElement(String where, Element element)
    => this._insertAdjacentNode(where, element);

  void insertAdjacentText(String where, String text) {
    this._insertAdjacentNode(where, new Text(text));
  }

  void insertAdjacentHTML(String where, String text) {
    this._insertAdjacentNode(where, new DocumentFragment.html(text));
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(() => const EmptyElementRect(),
                                    new Completer<ElementRect>());
  }

  // If we can come up with a semi-reasonable default value for an Element
  // getter, we'll use it. In general, these return the same values as an
  // element that has no parent.
  String get contentEditable() => "false";
  bool get isContentEditable() => false;
  bool get draggable() => false;
  bool get hidden() => false;
  bool get spellcheck() => false;
  bool get translate() => false;
  int get tabIndex() => -1;
  String get id() => "";
  String get title() => "";
  String get tagName() => "";
  String get webkitdropzone() => "";
  String get webkitRegionOverflow() => "";
  Element get $dom_firstElementChild() => elements.first();
  Element get $dom_lastElementChild() => elements.last();
  Element get nextElementSibling() => null;
  Element get previousElementSibling() => null;
  Element get offsetParent() => null;
  Element get parent() => null;
  Map<String, String> get attributes() => const {};
  // Issue 174: this should be a const set.
  Set<String> get classes() => new Set<String>();
  Map<String, String> get dataAttributes() => const {};
  CSSStyleDeclaration get style() => new Element.tag('div').style;
  Future<CSSStyleDeclaration> get computedStyle() =>
      _emptyStyleFuture();
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) =>
      _emptyStyleFuture();
  bool matchesSelector(String selectors) => false;

  // Imperative Element methods are made into no-ops, as they are on parentless
  // elements.
  void blur() {}
  void focus() {}
  void click() {}
  void scrollByLines(int lines) {}
  void scrollByPages(int pages) {}
  void scrollIntoView([bool centerIfNeeded]) {}
  void webkitRequestFullScreen(int flags) {}
  void webkitRequestFullscreen() {}

  // Setters throw errors rather than being no-ops because we aren't going to
  // retain the values that were set, and erroring out seems clearer.
  void set attributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Attributes can't be set for document fragments.");
  }

  void set classes(Collection<String> value) {
    throw new UnsupportedOperationException(
      "Classes can't be set for document fragments.");
  }

  void set dataAttributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Data attributes can't be set for document fragments.");
  }

  void set contentEditable(String value) {
    throw new UnsupportedOperationException(
      "Content editable can't be set for document fragments.");
  }

  String get dir() {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set dir(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set draggable(bool value) {
    throw new UnsupportedOperationException(
      "Draggable can't be set for document fragments.");
  }

  void set hidden(bool value) {
    throw new UnsupportedOperationException(
      "Hidden can't be set for document fragments.");
  }

  void set id(String value) {
    throw new UnsupportedOperationException(
      "ID can't be set for document fragments.");
  }

  String get lang() {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set lang(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set scrollLeft(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set scrollTop(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set spellcheck(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set translate(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set tabIndex(int value) {
    throw new UnsupportedOperationException(
      "Tab index can't be set for document fragments.");
  }

  void set title(String value) {
    throw new UnsupportedOperationException(
      "Title can't be set for document fragments.");
  }

  void set webkitdropzone(String value) {
    throw new UnsupportedOperationException(
      "WebKit drop zone can't be set for document fragments.");
  }

  void set webkitRegionOverflow(String value) {
    throw new UnsupportedOperationException(
      "WebKit region overflow can't be set for document fragments.");
  }

  _DocumentFragmentImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  Element query(String selectors) => _wrap(_ptr.query(_unwrap(selectors)));

  NodeList $dom_querySelectorAll(String selectors) => _wrap(_ptr.$dom_querySelectorAll(_unwrap(selectors)));

}

class _DocumentTypeImpl extends _NodeImpl implements DocumentType {
  _DocumentTypeImpl._wrap(ptr) : super._wrap(ptr);

  NamedNodeMap get entities() => _wrap(_ptr.entities);

  String get internalSubset() => _wrap(_ptr.internalSubset);

  String get name() => _wrap(_ptr.name);

  NamedNodeMap get notations() => _wrap(_ptr.notations);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _DynamicsCompressorNodeImpl extends _AudioNodeImpl implements DynamicsCompressorNode {
  _DynamicsCompressorNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get attack() => _wrap(_ptr.attack);

  AudioParam get knee() => _wrap(_ptr.knee);

  AudioParam get ratio() => _wrap(_ptr.ratio);

  AudioParam get reduction() => _wrap(_ptr.reduction);

  AudioParam get release() => _wrap(_ptr.release);

  AudioParam get threshold() => _wrap(_ptr.threshold);
}

class _EXTTextureFilterAnisotropicImpl extends _DOMTypeBase implements EXTTextureFilterAnisotropic {
  _EXTTextureFilterAnisotropicImpl._wrap(ptr) : super._wrap(ptr);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): use _Lists.dart to remove some of the duplicated
// functionality.
class _ChildrenElementList implements ElementList {
  // Raw Element.
  final _ElementImpl _element;
  final _HTMLCollectionImpl _childElements;

  _ChildrenElementList._wrap(_ElementImpl element)
    : _childElements = element.$dom_children,
      _element = element;

  List<Element> _toList() {
    final output = new List(_childElements.length);
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output[i] = _childElements[i];
    }
    return output;
  }

  _ElementImpl get first() {
    return _element.$dom_firstElementChild;
  }

  void forEach(void f(Element element)) {
    for (_ElementImpl element in _childElements) {
      f(element);
    }
  }

  ElementList filter(bool f(Element element)) {
    final output = <Element>[];
    forEach((Element element) {
      if (f(element)) {
        output.add(element);
      }
    });
    return new _FrozenElementList._wrap(output);
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  bool isEmpty() {
    return _element.$dom_firstElementChild == null;
  }

  int get length() {
    return _childElements.length;
  }

  _ElementImpl operator [](int index) {
    return _childElements[index];
  }

  void operator []=(int index, _ElementImpl value) {
    _element.$dom_replaceChild(value, _childElements[index]);
  }

   void set length(int newLength) {
     // TODO(jacobr): remove children when length is reduced.
     throw const UnsupportedOperationException('');
   }

  Element add(_ElementImpl value) {
    _element.$dom_appendChild(value);
    return value;
  }

  Element addLast(_ElementImpl value) => add(value);

  Iterator<Element> iterator() => _toList().iterator();

  void addAll(Collection<Element> collection) {
    for (_ElementImpl element in collection) {
      _element.$dom_appendChild(element);
    }
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int rangeLength) {
    throw const NotImplementedException();
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw const NotImplementedException();
  }

  List getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_Lists.getRange(this, start, rangeLength,
        <Element>[]));

  int indexOf(Element element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    // It is unclear if we want to keep non element nodes?
    _element.text = '';
  }

  Element removeLast() {
    final result = this.last();
    if (result != null) {
      _element.$dom_removeChild(result);
    }
    return result;
  }

  Element last() {
    return _element.$dom_lastElementChild;
  }
}

// TODO(jacobr): this is an inefficient implementation but it is hard to see
// a better option given that we cannot quite force NodeList to be an
// ElementList as there are valid cases where a NodeList JavaScript object
// contains Node objects that are not Elements.
class _FrozenElementList implements ElementList {
  final List<Node> _nodeList;

  _FrozenElementList._wrap(this._nodeList);

  Element get first() {
    return _nodeList[0];
  }

  void forEach(void f(Element element)) {
    for (Element el in this) {
      f(el);
    }
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  ElementList filter(bool f(Element element)) {
    final out = new _ElementList([]);
    for (Element el in this) {
      if (f(el)) out.add(el);
    }
    return out;
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  bool isEmpty() => _nodeList.isEmpty();

  int get length() => _nodeList.length;

  Element operator [](int index) => _nodeList[index];

  void operator []=(int index, Element value) {
    throw const UnsupportedOperationException('');
  }

  void set length(int newLength) {
    _nodeList.length = newLength;
  }

  void add(Element value) {
    throw const UnsupportedOperationException('');
  }

  void addLast(Element value) {
    throw const UnsupportedOperationException('');
  }

  Iterator<Element> iterator() => new _FrozenElementListIterator(this);

  void addAll(Collection<Element> collection) {
    throw const UnsupportedOperationException('');
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('');
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw const UnsupportedOperationException('');
  }

  void removeRange(int start, int rangeLength) {
    throw const UnsupportedOperationException('');
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw const UnsupportedOperationException('');
  }

  ElementList getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_nodeList.getRange(start, rangeLength));

  int indexOf(Element element, [int start = 0]) =>
    _nodeList.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) =>
    _nodeList.lastIndexOf(element, start);

  void clear() {
    throw const UnsupportedOperationException('');
  }

  Element removeLast() {
    throw const UnsupportedOperationException('');
  }

  Element last() => _nodeList.last();
}

class _FrozenElementListIterator implements Iterator<Element> {
  final _FrozenElementList _list;
  int _index = 0;

  _FrozenElementListIterator(this._list);

  /**
   * Gets the next element in the iteration. Throws a
   * [NoMoreElementsException] if no element is left.
   */
  Element next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }

    return _list[_index++];
  }

  /**
   * Returns whether the [Iterator] has elements left.
   */
  bool hasNext() => _index < _list.length;
}

class _ElementList extends _ListWrapper<Element> implements ElementList {
  _ElementList(List<Element> list) : super(list);

  ElementList filter(bool f(Element element)) =>
    new _ElementList(super.filter(f));

  ElementList getRange(int start, int rangeLength) =>
    new _ElementList(super.getRange(start, rangeLength));
}

class _ElementAttributeMap implements AttributeMap {

  final _ElementImpl _element;

  _ElementAttributeMap(this._element);

  bool containsValue(String value) {
    final attributes = _element.$dom_attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      if(value == attributes[i].value) {
        return true;
      }
    }
    return false;
  }

  bool containsKey(String key) {
    return _element.$dom_hasAttribute(key);
  }

  String operator [](String key) {
    return _element.$dom_getAttribute(key);
  }

  void operator []=(String key, value) {
    _element.$dom_setAttribute(key, '$value');
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      this[key] = ifAbsent();
    }
    return this[key];
  }

  String remove(String key) {
    String value = _element.$dom_getAttribute(key);
    _element.$dom_removeAttribute(key);
    return value;
  }

  void clear() {
    final attributes = _element.$dom_attributes;
    for (int i = attributes.length - 1; i >= 0; i--) {
      remove(attributes[i].name);
    }
  }

  void forEach(void f(String key, String value)) {
    final attributes = _element.$dom_attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      final item = attributes[i];
      f(item.name, item.value);
    }
  }

  Collection<String> getKeys() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.$dom_attributes;
    final keys = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      keys[i] = attributes[i].name;
    }
    return keys;
  }

  Collection<String> getValues() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.$dom_attributes;
    final values = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      values[i] = attributes[i].value;
    }
    return values;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length() {
    return _element.$dom_attributes.length;
  }

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool isEmpty() {
    return length == 0;
  }
}

/**
 * Provides a Map abstraction on top of data-* attributes, similar to the
 * dataSet in the old DOM.
 */
class _DataAttributeMap implements AttributeMap {

  final Map<String, String> $dom_attributes;

  _DataAttributeMap(this.$dom_attributes);

  // interface Map

  // TODO: Use lazy iterator when it is available on Map.
  bool containsValue(String value) => getValues().some((v) => v == value);

  bool containsKey(String key) => $dom_attributes.containsKey(_attr(key));

  String operator [](String key) => $dom_attributes[_attr(key)];

  void operator []=(String key, value) {
    $dom_attributes[_attr(key)] = '$value';
  }

  String putIfAbsent(String key, String ifAbsent()) =>
    $dom_attributes.putIfAbsent(_attr(key), ifAbsent);

  String remove(String key) => $dom_attributes.remove(_attr(key));

  void clear() {
    // Needs to operate on a snapshot since we are mutating the collection.
    for (String key in getKeys()) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        f(_strip(key), value);
      }
    });
  }

  Collection<String> getKeys() {
    final keys = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        keys.add(_strip(key));
      }
    });
    return keys;
  }

  Collection<String> getValues() {
    final values = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        values.add(value);
      }
    });
    return values;
  }

  int get length() => getKeys().length;

  // TODO: Use lazy iterator when it is available on Map.
  bool isEmpty() => length == 0;

  // Helpers.
  String _attr(String key) => 'data-$key';
  bool _matches(String key) => key.startsWith('data-');
  String _strip(String key) => key.substring(5);
}

class _CssClassSet implements Set<String> {

  final _ElementImpl _element;

  _CssClassSet(this._element);

  String toString() => _formatSet(_read());

  // interface Iterable - BEGIN
  Iterator<String> iterator() => _read().iterator();
  // interface Iterable - END

  // interface Collection - BEGIN
  void forEach(void f(String element)) {
    _read().forEach(f);
  }

  Collection map(f(String element)) => _read().map(f);

  Collection<String> filter(bool f(String element)) => _read().filter(f);

  bool every(bool f(String element)) => _read().every(f);

  bool some(bool f(String element)) => _read().some(f);

  bool isEmpty() => _read().isEmpty();

  int get length() =>_read().length;

  // interface Collection - END

  // interface Set - BEGIN
  bool contains(String value) => _read().contains(value);

  void add(String value) {
    // TODO - figure out if we need to do any validation here
    // or if the browser natively does enough
    _modify((s) => s.add(value));
  }

  bool remove(String value) {
    Set<String> s = _read();
    bool result = s.remove(value);
    _write(s);
    return result;
  }

  void addAll(Collection<String> collection) {
    // TODO - see comment above about validation
    _modify((s) => s.addAll(collection));
  }

  void removeAll(Collection<String> collection) {
    _modify((s) => s.removeAll(collection));
  }

  bool isSubsetOf(Collection<String> collection) =>
    _read().isSubsetOf(collection);

  bool containsAll(Collection<String> collection) =>
    _read().containsAll(collection);

  Set<String> intersection(Collection<String> other) =>
    _read().intersection(other);

  void clear() {
    _modify((s) => s.clear());
  }
  // interface Set - END

  /**
   * Helper method used to modify the set of css classes on this element.
   *
   *   f - callback with:
   *      s - a Set of all the css class name currently on this element.
   *
   *   After f returns, the modified set is written to the
   *       className property of this element.
   */
  void _modify( f(Set<String> s)) {
    Set<String> s = _read();
    f(s);
    _write(s);
  }

  /**
   * Read the class names from the Element class property,
   * and put them into a set (duplicates are discarded).
   */
  Set<String> _read() {
    // TODO(mattsh) simplify this once split can take regex.
    Set<String> s = new Set<String>();
    for (String name in _classname().split(' ')) {
      String trimmed = name.trim();
      if (!trimmed.isEmpty()) {
        s.add(trimmed);
      }
    }
    return s;
  }

  /**
   * Read the class names as a space-separated string. This is meant to be
   * overridden by subclasses.
   */
  String _classname() => _element.$dom_className;

  /**
   * Join all the elements of a set into one string and write
   * back to the element.
   */
  void _write(Set s) {
    _element.$dom_className = _formatSet(s);
  }

  String _formatSet(Set<String> s) {
    // TODO(mattsh) should be able to pass Set to String.joins http:/b/5398605
    List list = new List.from(s);
    return Strings.join(list, ' ');
  }
}

class _SimpleClientRect implements ClientRect {
  final num left;
  final num top;
  final num width;
  final num height;
  num get right() => left + width;
  num get bottom() => top + height;

  const _SimpleClientRect(this.left, this.top, this.width, this.height);

  bool operator ==(ClientRect other) {
    return other !== null && left == other.left && top == other.top
        && width == other.width && height == other.height;
  }

  String toString() => "($left, $top, $width, $height)";
}

// TODO(jacobr): we cannot currently be lazy about calculating the client
// rects as we must perform all measurement queries at a safe point to avoid
// triggering unneeded layouts.
/**
 * All your element measurement needs in one place
 * @domName none
 */
class _ElementRectImpl implements ElementRect {
  final ClientRect client;
  final ClientRect offset;
  final ClientRect scroll;

  // TODO(jacobr): should we move these outside of ElementRect to avoid the
  // overhead of computing them every time even though they are rarely used.
  final _ClientRectImpl _boundingClientRect; 
  final _ClientRectListImpl _clientRects;

  _ElementRectImpl(_ElementImpl element) :
    client = new _SimpleClientRect(element.$dom_clientLeft,
                                  element.$dom_clientTop,
                                  element.$dom_clientWidth, 
                                  element.$dom_clientHeight), 
    offset = new _SimpleClientRect(element.$dom_offsetLeft,
                                  element.$dom_offsetTop,
                                  element.$dom_offsetWidth,
                                  element.$dom_offsetHeight),
    scroll = new _SimpleClientRect(element.$dom_scrollLeft,
                                  element.$dom_scrollTop,
                                  element.$dom_scrollWidth,
                                  element.$dom_scrollHeight),
    _boundingClientRect = element.$dom_getBoundingClientRect(),
    _clientRects = element.$dom_getClientRects();

  _ClientRectImpl get bounding() => _boundingClientRect;

  // TODO(jacobr): cleanup.
  List<ClientRect> get clientRects() {
    final out = new List(_clientRects.length);
    for (num i = 0; i < _clientRects.length; i++) {
      out[i] = _clientRects.item(i);
    }
    return out;
  }
}

class _ElementImpl extends _NodeImpl implements Element {

  /**
   * @domName Element.hasAttribute, Element.getAttribute, Element.setAttribute,
   *   Element.removeAttribute
   */
  _ElementAttributeMap get attributes() => new _ElementAttributeMap(this);

  void set attributes(Map<String, String> value) {
    Map<String, String> attributes = this.attributes;
    attributes.clear();
    for (String key in value.getKeys()) {
      attributes[key] = value[key];
    }
  }

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  ElementList get elements() => new _ChildrenElementList._wrap(this);

  ElementList queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  _CssClassSet get classes() => new _CssClassSet(this);

  void set classes(Collection<String> value) {
    _CssClassSet classSet = classes;
    classSet.clear();
    classSet.addAll(value);
  }

  Map<String, String> get dataAttributes() =>
    new _DataAttributeMap(attributes);

  void set dataAttributes(Map<String, String> value) {
    final dataAttributes = this.dataAttributes;
    dataAttributes.clear();
    for (String key in value.getKeys()) {
      dataAttributes[key] = value[key];
    }
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(
        () => new _ElementRectImpl(this),
        new Completer<ElementRect>());
  }

  Future<CSSStyleDeclaration> get computedStyle() {
     // TODO(jacobr): last param should be null, see b/5045788
     return getComputedStyle('');
  }

  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) {
    return _createMeasurementFuture(
        () => _window.$dom_getComputedStyle(this, pseudoElement),
        new Completer<CSSStyleDeclaration>());
  }
  _ElementImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get $dom_childElementCount() => _wrap(_ptr.$dom_childElementCount);

  HTMLCollection get $dom_children() => _wrap(_ptr.$dom_children);

  String get $dom_className() => _wrap(_ptr.$dom_className);

  void set $dom_className(String value) { _ptr.$dom_className = _unwrap(value); }

  int get $dom_clientHeight() => _wrap(_ptr.$dom_clientHeight);

  int get $dom_clientLeft() => _wrap(_ptr.$dom_clientLeft);

  int get $dom_clientTop() => _wrap(_ptr.$dom_clientTop);

  int get $dom_clientWidth() => _wrap(_ptr.$dom_clientWidth);

  String get contentEditable() => _wrap(_ptr.contentEditable);

  void set contentEditable(String value) { _ptr.contentEditable = _unwrap(value); }

  Map<String, String> get dataset() => _wrap(_ptr.dataset);

  String get dir() => _wrap(_ptr.dir);

  void set dir(String value) { _ptr.dir = _unwrap(value); }

  bool get draggable() => _wrap(_ptr.draggable);

  void set draggable(bool value) { _ptr.draggable = _unwrap(value); }

  Element get $dom_firstElementChild() => _wrap(_ptr.$dom_firstElementChild);

  bool get hidden() => _wrap(_ptr.hidden);

  void set hidden(bool value) { _ptr.hidden = _unwrap(value); }

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  String get innerHTML() => _wrap(_ptr.innerHTML);

  void set innerHTML(String value) { _ptr.innerHTML = _unwrap(value); }

  bool get isContentEditable() => _wrap(_ptr.isContentEditable);

  String get lang() => _wrap(_ptr.lang);

  void set lang(String value) { _ptr.lang = _unwrap(value); }

  Element get $dom_lastElementChild() => _wrap(_ptr.$dom_lastElementChild);

  Element get nextElementSibling() => _wrap(_ptr.nextElementSibling);

  int get $dom_offsetHeight() => _wrap(_ptr.$dom_offsetHeight);

  int get $dom_offsetLeft() => _wrap(_ptr.$dom_offsetLeft);

  Element get offsetParent() => _wrap(_ptr.offsetParent);

  int get $dom_offsetTop() => _wrap(_ptr.$dom_offsetTop);

  int get $dom_offsetWidth() => _wrap(_ptr.$dom_offsetWidth);

  String get outerHTML() => _wrap(_ptr.outerHTML);

  Element get previousElementSibling() => _wrap(_ptr.previousElementSibling);

  int get $dom_scrollHeight() => _wrap(_ptr.$dom_scrollHeight);

  int get $dom_scrollLeft() => _wrap(_ptr.$dom_scrollLeft);

  void set $dom_scrollLeft(int value) { _ptr.$dom_scrollLeft = _unwrap(value); }

  int get $dom_scrollTop() => _wrap(_ptr.$dom_scrollTop);

  void set $dom_scrollTop(int value) { _ptr.$dom_scrollTop = _unwrap(value); }

  int get $dom_scrollWidth() => _wrap(_ptr.$dom_scrollWidth);

  bool get spellcheck() => _wrap(_ptr.spellcheck);

  void set spellcheck(bool value) { _ptr.spellcheck = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  int get tabIndex() => _wrap(_ptr.tabIndex);

  void set tabIndex(int value) { _ptr.tabIndex = _unwrap(value); }

  String get tagName() => _wrap(_ptr.tagName);

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  bool get translate() => _wrap(_ptr.translate);

  void set translate(bool value) { _ptr.translate = _unwrap(value); }

  String get webkitRegionOverflow() => _wrap(_ptr.webkitRegionOverflow);

  String get webkitdropzone() => _wrap(_ptr.webkitdropzone);

  void set webkitdropzone(String value) { _ptr.webkitdropzone = _unwrap(value); }

  void blur() => _ptr.blur();

  void click() => _ptr.click();

  void focus() => _ptr.focus();

  String $dom_getAttribute(String name) => _wrap(_ptr.$dom_getAttribute(_unwrap(name)));

  ClientRect $dom_getBoundingClientRect() => _wrap(_ptr.$dom_getBoundingClientRect());

  ClientRectList $dom_getClientRects() => _wrap(_ptr.$dom_getClientRects());

  NodeList $dom_getElementsByClassName(String name) => _wrap(_ptr.$dom_getElementsByClassName(_unwrap(name)));

  NodeList $dom_getElementsByTagName(String name) => _wrap(_ptr.$dom_getElementsByTagName(_unwrap(name)));

  bool $dom_hasAttribute(String name) => _wrap(_ptr.$dom_hasAttribute(_unwrap(name)));

  Element insertAdjacentElement(String where, Element element) => _wrap(_ptr.insertAdjacentElement(_unwrap(where), _unwrap(element)));

  void insertAdjacentHTML(String where, String html) => _ptr.insertAdjacentHTML(_unwrap(where), _unwrap(html));

  void insertAdjacentText(String where, String text) => _ptr.insertAdjacentText(_unwrap(where), _unwrap(text));

  Element query(String selectors) => _wrap(_ptr.query(_unwrap(selectors)));

  NodeList $dom_querySelectorAll(String selectors) => _wrap(_ptr.$dom_querySelectorAll(_unwrap(selectors)));

  void $dom_removeAttribute(String name) => _ptr.$dom_removeAttribute(_unwrap(name));

  void scrollByLines(int lines) => _ptr.scrollByLines(_unwrap(lines));

  void scrollByPages(int pages) => _ptr.scrollByPages(_unwrap(pages));

  void scrollIntoView([bool centerIfNeeded = null]) => _ptr.scrollIntoView(_unwrap(centerIfNeeded));

  void $dom_setAttribute(String name, String value) => _ptr.$dom_setAttribute(_unwrap(name), _unwrap(value));

  bool matchesSelector(String selectors) => _wrap(_ptr.matchesSelector(_unwrap(selectors)));

  void webkitRequestFullScreen(int flags) => _ptr.webkitRequestFullScreen(_unwrap(flags));

  void webkitRequestFullscreen() => _ptr.webkitRequestFullscreen();

}

final _START_TAG_REGEXP = const RegExp('<(\\w+)');
class _ElementFactoryProvider {
  static final _CUSTOM_PARENT_TAG_MAP = const {
    'body' : 'html',
    'head' : 'html',
    'caption' : 'table',
    'td': 'tr',
    'colgroup': 'table',
    'col' : 'colgroup',
    'tr' : 'tbody',
    'tbody' : 'table',
    'tfoot' : 'table',
    'thead' : 'table',
    'track' : 'audio',
  };

  /** @domName Document.createElement */
  factory Element.html(String html) {
    // TODO(jacobr): this method can be made more robust and performant.
    // 1) Cache the dummy parent elements required to use innerHTML rather than
    //    creating them every call.
    // 2) Verify that the html does not contain leading or trailing text nodes.
    // 3) Verify that the html does not contain both <head> and <body> tags.
    // 4) Detatch the created element from its dummy parent.
    String parentTag = 'div';
    String tag;
    final match = _START_TAG_REGEXP.firstMatch(html);
    if (match !== null) {
      tag = match.group(1).toLowerCase();
      if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
        parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
      }
    }
    final _ElementImpl temp = new Element.tag(parentTag);
    temp.innerHTML = html;

    Element element;
    if (temp.elements.length == 1) {
      element = temp.elements.first;
    } else if (parentTag == 'html' && temp.elements.length == 2) {
      // Work around for edge case in WebKit and possibly other browsers where
      // both body and head elements are created even though the inner html
      // only contains a head or body element.
      element = temp.elements[tag == 'head' ? 0 : 1];
    } else {
      throw new IllegalArgumentException('HTML had ${temp.elements.length} ' +
          'top level elements but 1 expected');
    }
    element.remove();
    return element;
  }

  /** @domName Document.createElement */
  factory Element.tag(String tag) => _document.$dom_createElement(tag);
}

class _ElementTimeControlImpl extends _DOMTypeBase implements ElementTimeControl {
  _ElementTimeControlImpl._wrap(ptr) : super._wrap(ptr);

  void beginElement() => _ptr.beginElement();

  void beginElementAt(num offset) => _ptr.beginElementAt(_unwrap(offset));

  void endElement() => _ptr.endElement();

  void endElementAt(num offset) => _ptr.endElementAt(_unwrap(offset));
}

class _ElementTraversalImpl extends _DOMTypeBase implements ElementTraversal {
  _ElementTraversalImpl._wrap(ptr) : super._wrap(ptr);

  int get childElementCount() => _wrap(_ptr.childElementCount);

  Element get firstElementChild() => _wrap(_ptr.firstElementChild);

  Element get lastElementChild() => _wrap(_ptr.lastElementChild);

  Element get nextElementSibling() => _wrap(_ptr.nextElementSibling);

  Element get previousElementSibling() => _wrap(_ptr.previousElementSibling);
}

class _EmbedElementImpl extends _ElementImpl implements EmbedElement {
  _EmbedElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _EntityImpl extends _NodeImpl implements Entity {
  _EntityImpl._wrap(ptr) : super._wrap(ptr);

  String get notationName() => _wrap(_ptr.notationName);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _EntityReferenceImpl extends _NodeImpl implements EntityReference {
  _EntityReferenceImpl._wrap(ptr) : super._wrap(ptr);
}

class _EntryImpl extends _DOMTypeBase implements Entry {
  _EntryImpl._wrap(ptr) : super._wrap(ptr);

  DOMFileSystem get filesystem() => _wrap(_ptr.filesystem);

  String get fullPath() => _wrap(_ptr.fullPath);

  bool get isDirectory() => _wrap(_ptr.isDirectory);

  bool get isFile() => _wrap(_ptr.isFile);

  String get name() => _wrap(_ptr.name);

  void copyTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.copyTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback), _unwrap(errorCallback));

  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.getMetadata(_unwrap(successCallback), _unwrap(errorCallback));

  void getParent([EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.getParent(_unwrap(successCallback), _unwrap(errorCallback));

  void moveTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.moveTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback), _unwrap(errorCallback));

  void remove(VoidCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.remove(_unwrap(successCallback), _unwrap(errorCallback));

  String toURL() => _wrap(_ptr.toURL());
}

class _EntryArrayImpl extends _DOMTypeBase implements EntryArray {
  _EntryArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Entry item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _EntryArraySyncImpl extends _DOMTypeBase implements EntryArraySync {
  _EntryArraySyncImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  EntrySync item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _EntrySyncImpl extends _DOMTypeBase implements EntrySync {
  _EntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  DOMFileSystemSync get filesystem() => _wrap(_ptr.filesystem);

  String get fullPath() => _wrap(_ptr.fullPath);

  bool get isDirectory() => _wrap(_ptr.isDirectory);

  bool get isFile() => _wrap(_ptr.isFile);

  String get name() => _wrap(_ptr.name);

  EntrySync copyTo(DirectoryEntrySync parent, String name) => _wrap(_ptr.copyTo(_unwrap(parent), _unwrap(name)));

  Metadata getMetadata() => _wrap(_ptr.getMetadata());

  EntrySync getParent() => _wrap(_ptr.getParent());

  EntrySync moveTo(DirectoryEntrySync parent, String name) => _wrap(_ptr.moveTo(_unwrap(parent), _unwrap(name)));

  void remove() => _ptr.remove();

  String toURL() => _wrap(_ptr.toURL());
}

class _ErrorEventImpl extends _EventImpl implements ErrorEvent {
  _ErrorEventImpl._wrap(ptr) : super._wrap(ptr);

  String get filename() => _wrap(_ptr.filename);

  int get lineno() => _wrap(_ptr.lineno);

  String get message() => _wrap(_ptr.message);
}

class _EventImpl extends _DOMTypeBase implements Event {
  _EventImpl._wrap(ptr) : super._wrap(ptr);

  bool get bubbles() => _wrap(_ptr.bubbles);

  bool get cancelBubble() => _wrap(_ptr.cancelBubble);

  void set cancelBubble(bool value) { _ptr.cancelBubble = _unwrap(value); }

  bool get cancelable() => _wrap(_ptr.cancelable);

  Clipboard get clipboardData() => _wrap(_ptr.clipboardData);

  EventTarget get currentTarget() => _wrap(_ptr.currentTarget);

  bool get defaultPrevented() => _wrap(_ptr.defaultPrevented);

  int get eventPhase() => _wrap(_ptr.eventPhase);

  bool get returnValue() => _wrap(_ptr.returnValue);

  void set returnValue(bool value) { _ptr.returnValue = _unwrap(value); }

  EventTarget get srcElement() => _wrap(_ptr.srcElement);

  EventTarget get target() => _wrap(_ptr.target);

  int get timeStamp() => _wrap(_ptr.timeStamp);

  String get type() => _wrap(_ptr.type);

  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) => _ptr.$dom_initEvent(_unwrap(eventTypeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg));

  void preventDefault() => _ptr.preventDefault();

  void stopImmediatePropagation() => _ptr.stopImmediatePropagation();

  void stopPropagation() => _ptr.stopPropagation();
}

class _EventExceptionImpl extends _DOMTypeBase implements EventException {
  _EventExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _EventSourceImpl extends _EventTargetImpl implements EventSource {
  _EventSourceImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get URL() => _wrap(_ptr.URL);

  int get readyState() => _wrap(_ptr.readyState);

  String get url() => _wrap(_ptr.url);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void close() => _ptr.close();

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventsImpl implements Events {
  // TODO(podivilov): add type.
  final _ptr;

  final Map<String, EventListenerList> _listenerMap;

  _EventsImpl(this._ptr) : _listenerMap = <EventListenerList>{};

  EventListenerList operator [](String type) {
    return _get(type.toLowerCase());
  }

  EventListenerList _get(String type) {
    return _listenerMap.putIfAbsent(type,
      () => new _EventListenerListImpl(_ptr, type));
  }
}

class _EventListenerWrapper {
  final EventListener raw;
  final Function wrapped;
  final bool useCapture;
  _EventListenerWrapper(this.raw, this.wrapped, this.useCapture);
}

class _EventListenerListImpl implements EventListenerList {
  // TODO(podivilov): add type.
  final _ptr;
  final String _type;
  List<_EventListenerWrapper> _wrappers;

  _EventListenerListImpl(this._ptr, this._type) :
    // TODO(jacobr): switch to <_EventListenerWrapper>[] when the VM allow it.
    _wrappers = new List<_EventListenerWrapper>();

  EventListenerList add(EventListener listener, [bool useCapture = false]) {
    _add(listener, useCapture);
    return this;
  }

  EventListenerList remove(EventListener listener, [bool useCapture = false]) {
    _remove(listener, useCapture);
    return this;
  }

  bool dispatch(Event evt) {
    // TODO(jacobr): what is the correct behavior here. We could alternately
    // force the event to have the expected type.
    assert(evt.type == _type);
    return _ptr.$dom_dispatchEvent(_unwrap(evt));
  }

  void _add(EventListener listener, bool useCapture) {
    _ptr.$dom_addEventListener(_type,
                          _findOrAddWrapper(listener, useCapture),
                          useCapture);
  }

  void _remove(EventListener listener, bool useCapture) {
    Function wrapper = _removeWrapper(listener, useCapture);
    if (wrapper !== null) {
      _ptr.$dom_removeEventListener(_type, wrapper, useCapture);
    }
  }

  Function _removeWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      return null;
    }
    for (int i = 0; i < _wrappers.length; i++) {
      _EventListenerWrapper wrapper = _wrappers[i];
      if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
        // Order doesn't matter so we swap with the last element instead of
        // performing a more expensive remove from the middle of the list.
        if (i + 1 != _wrappers.length) {
          _wrappers[i] = _wrappers.removeLast();
        } else {
          _wrappers.removeLast();
        }
        return wrapper.wrapped;
      }
    }
    return null;
  }

  Function _findOrAddWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      _wrappers = <_EventListenerWrapper>[];
    } else {
      for (_EventListenerWrapper wrapper in _wrappers) {
        if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
          return wrapper.wrapped;
        }
      }
    }
    final wrapped = (e) { listener(_wrap(e)); };
    _wrappers.add(new _EventListenerWrapper(listener, wrapped, useCapture));
    return wrapped;
  }
}

class _EventTargetImpl extends _DOMTypeBase implements EventTarget {

  Events _on;

  Events get on() {
    if (_on == null) _on = new _EventsImpl(this);
    return _on;
  }

  _EventTargetImpl._wrap(ptr) : super._wrap(ptr);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

}

class _FieldSetElementImpl extends _ElementImpl implements FieldSetElement {
  _FieldSetElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));
}

class _FileImpl extends _BlobImpl implements File {
  _FileImpl._wrap(ptr) : super._wrap(ptr);

  Date get lastModifiedDate() => _wrap(_ptr.lastModifiedDate);

  String get name() => _wrap(_ptr.name);

  String get webkitRelativePath() => _wrap(_ptr.webkitRelativePath);
}

class _FileEntryImpl extends _EntryImpl implements FileEntry {
  _FileEntryImpl._wrap(ptr) : super._wrap(ptr);

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.createWriter(_unwrap(successCallback), _unwrap(errorCallback));

  void file(FileCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.file(_unwrap(successCallback), _unwrap(errorCallback));
}

class _FileEntrySyncImpl extends _EntrySyncImpl implements FileEntrySync {
  _FileEntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  FileWriterSync createWriter() => _wrap(_ptr.createWriter());

  File file() => _wrap(_ptr.file());
}

class _FileErrorImpl extends _DOMTypeBase implements FileError {
  _FileErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _FileExceptionImpl extends _DOMTypeBase implements FileException {
  _FileExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _FileListImpl extends _DOMTypeBase implements FileList {
  _FileListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  File operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, File value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<File> mixins.
  // File is the element type.

  // From Iterable<File>:

  Iterator<File> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<File>(this);
  }

  // From Collection<File>:

  void add(File value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(File value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<File> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(File element)) => _Collections.forEach(this, f);

  Collection map(f(File element)) => _Collections.map(this, [], f);

  Collection<File> filter(bool f(File element)) =>
     _Collections.filter(this, <File>[], f);

  bool every(bool f(File element)) => _Collections.every(this, f);

  bool some(bool f(File element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<File>:

  void sort(int compare(File a, File b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(File element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(File element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  File last() => this[length - 1];

  File removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<File> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [File initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<File> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <File>[]);

  // -- end List<File> mixins.

  File item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _FileReaderImpl extends _EventTargetImpl implements FileReader {
  _FileReaderImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  FileError get error() => _wrap(_ptr.error);

  int get readyState() => _wrap(_ptr.readyState);

  Object get result() => _wrap(_ptr.result);

  void abort() => _ptr.abort();

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void readAsArrayBuffer(Blob blob) => _ptr.readAsArrayBuffer(_unwrap(blob));

  void readAsBinaryString(Blob blob) => _ptr.readAsBinaryString(_unwrap(blob));

  void readAsDataURL(Blob blob) => _ptr.readAsDataURL(_unwrap(blob));

  void readAsText(Blob blob, [String encoding = null]) => _ptr.readAsText(_unwrap(blob), _unwrap(encoding));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _FileReaderSyncImpl extends _DOMTypeBase implements FileReaderSync {
  _FileReaderSyncImpl._wrap(ptr) : super._wrap(ptr);

  ArrayBuffer readAsArrayBuffer(Blob blob) => _wrap(_ptr.readAsArrayBuffer(_unwrap(blob)));

  String readAsBinaryString(Blob blob) => _wrap(_ptr.readAsBinaryString(_unwrap(blob)));

  String readAsDataURL(Blob blob) => _wrap(_ptr.readAsDataURL(_unwrap(blob)));

  String readAsText(Blob blob, [String encoding = null]) => _wrap(_ptr.readAsText(_unwrap(blob), _unwrap(encoding)));
}

class _FileWriterImpl extends _EventTargetImpl implements FileWriter {
  _FileWriterImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  FileError get error() => _wrap(_ptr.error);

  int get length() => _wrap(_ptr.length);

  int get position() => _wrap(_ptr.position);

  int get readyState() => _wrap(_ptr.readyState);

  void abort() => _ptr.abort();

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void seek(int position) => _ptr.seek(_unwrap(position));

  void truncate(int size) => _ptr.truncate(_unwrap(size));

  void write(Blob data) => _ptr.write(_unwrap(data));
}

class _FileWriterSyncImpl extends _DOMTypeBase implements FileWriterSync {
  _FileWriterSyncImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int get position() => _wrap(_ptr.position);

  void seek(int position) => _ptr.seek(_unwrap(position));

  void truncate(int size) => _ptr.truncate(_unwrap(size));

  void write(Blob data) => _ptr.write(_unwrap(data));
}

class _Float32ArrayImpl extends _ArrayBufferViewImpl implements Float32Array, List<num> {
  _Float32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, num value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<num>(this);
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(num element)) => _Collections.forEach(this, f);

  Collection map(f(num element)) => _Collections.map(this, [], f);

  Collection<num> filter(bool f(num element)) =>
     _Collections.filter(this, <num>[], f);

  bool every(bool f(num element)) => _Collections.every(this, f);

  bool some(bool f(num element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<num>:

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  num last() => this[length - 1];

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Float32Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _Float64ArrayImpl extends _ArrayBufferViewImpl implements Float64Array, List<num> {
  _Float64ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, num value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<num>(this);
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(num element)) => _Collections.forEach(this, f);

  Collection map(f(num element)) => _Collections.map(this, [], f);

  Collection<num> filter(bool f(num element)) =>
     _Collections.filter(this, <num>[], f);

  bool every(bool f(num element)) => _Collections.every(this, f);

  bool some(bool f(num element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<num>:

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  num last() => this[length - 1];

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Float64Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _FontElementImpl extends _ElementImpl implements FontElement {
  _FontElementImpl._wrap(ptr) : super._wrap(ptr);

  String get color() => _wrap(_ptr.color);

  void set color(String value) { _ptr.color = _unwrap(value); }

  String get face() => _wrap(_ptr.face);

  void set face(String value) { _ptr.face = _unwrap(value); }

  String get size() => _wrap(_ptr.size);

  void set size(String value) { _ptr.size = _unwrap(value); }
}

class _FormElementImpl extends _ElementImpl implements FormElement {
  _FormElementImpl._wrap(ptr) : super._wrap(ptr);

  String get acceptCharset() => _wrap(_ptr.acceptCharset);

  void set acceptCharset(String value) { _ptr.acceptCharset = _unwrap(value); }

  String get action() => _wrap(_ptr.action);

  void set action(String value) { _ptr.action = _unwrap(value); }

  String get autocomplete() => _wrap(_ptr.autocomplete);

  void set autocomplete(String value) { _ptr.autocomplete = _unwrap(value); }

  String get encoding() => _wrap(_ptr.encoding);

  void set encoding(String value) { _ptr.encoding = _unwrap(value); }

  String get enctype() => _wrap(_ptr.enctype);

  void set enctype(String value) { _ptr.enctype = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  String get method() => _wrap(_ptr.method);

  void set method(String value) { _ptr.method = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  bool get noValidate() => _wrap(_ptr.noValidate);

  void set noValidate(bool value) { _ptr.noValidate = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void reset() => _ptr.reset();

  void submit() => _ptr.submit();
}

class _FrameElementImpl extends _ElementImpl implements FrameElement {
  _FrameElementImpl._wrap(ptr) : super._wrap(ptr);

  Document get contentDocument() => _wrap(_ptr.contentDocument);

  Window get contentWindow() => _wrap(_ptr.contentWindow);

  String get frameBorder() => _wrap(_ptr.frameBorder);

  void set frameBorder(String value) { _ptr.frameBorder = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  String get location() => _wrap(_ptr.location);

  void set location(String value) { _ptr.location = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get marginHeight() => _wrap(_ptr.marginHeight);

  void set marginHeight(String value) { _ptr.marginHeight = _unwrap(value); }

  String get marginWidth() => _wrap(_ptr.marginWidth);

  void set marginWidth(String value) { _ptr.marginWidth = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  bool get noResize() => _wrap(_ptr.noResize);

  void set noResize(bool value) { _ptr.noResize = _unwrap(value); }

  String get scrolling() => _wrap(_ptr.scrolling);

  void set scrolling(String value) { _ptr.scrolling = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  SVGDocument getSVGDocument() => _wrap(_ptr.getSVGDocument());
}

class _FrameSetElementImpl extends _ElementImpl implements FrameSetElement {
  _FrameSetElementImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get cols() => _wrap(_ptr.cols);

  void set cols(String value) { _ptr.cols = _unwrap(value); }

  String get rows() => _wrap(_ptr.rows);

  void set rows(String value) { _ptr.rows = _unwrap(value); }
}

class _GeolocationImpl extends _DOMTypeBase implements Geolocation {
  _GeolocationImpl._wrap(ptr) : super._wrap(ptr);

  void clearWatch(int watchId) => _ptr.clearWatch(_unwrap(watchId));

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) => _ptr.getCurrentPosition(_unwrap(successCallback), _unwrap(errorCallback));

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) => _wrap(_ptr.watchPosition(_unwrap(successCallback), _unwrap(errorCallback)));
}

class _GeopositionImpl extends _DOMTypeBase implements Geoposition {
  _GeopositionImpl._wrap(ptr) : super._wrap(ptr);

  Coordinates get coords() => _wrap(_ptr.coords);

  int get timestamp() => _wrap(_ptr.timestamp);
}

class _HRElementImpl extends _ElementImpl implements HRElement {
  _HRElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  bool get noShade() => _wrap(_ptr.noShade);

  void set noShade(bool value) { _ptr.noShade = _unwrap(value); }

  String get size() => _wrap(_ptr.size);

  void set size(String value) { _ptr.size = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _HTMLAllCollectionImpl extends _DOMTypeBase implements HTMLAllCollection {
  _HTMLAllCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node item(int index) => _wrap(_ptr.item(_unwrap(index)));

  Node namedItem(String name) => _wrap(_ptr.namedItem(_unwrap(name)));

  NodeList tags(String name) => _wrap(_ptr.tags(_unwrap(name)));
}

class _HTMLCollectionImpl extends _DOMTypeBase implements HTMLCollection {
  _HTMLCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node last() => this[length - 1];

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  Node item(int index) => _wrap(_ptr.item(_unwrap(index)));

  Node namedItem(String name) => _wrap(_ptr.namedItem(_unwrap(name)));
}

class _HTMLOptionsCollectionImpl extends _HTMLCollectionImpl implements HTMLOptionsCollection {
  _HTMLOptionsCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void set length(int value) { _ptr.length = _unwrap(value); }

  int get selectedIndex() => _wrap(_ptr.selectedIndex);

  void set selectedIndex(int value) { _ptr.selectedIndex = _unwrap(value); }

  void remove(int index) => _ptr.remove(_unwrap(index));
}

class _HashChangeEventImpl extends _EventImpl implements HashChangeEvent {
  _HashChangeEventImpl._wrap(ptr) : super._wrap(ptr);

  String get newURL() => _wrap(_ptr.newURL);

  String get oldURL() => _wrap(_ptr.oldURL);

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) => _ptr.initHashChangeEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(oldURL), _unwrap(newURL));
}

class _HeadElementImpl extends _ElementImpl implements HeadElement {
  _HeadElementImpl._wrap(ptr) : super._wrap(ptr);

  String get profile() => _wrap(_ptr.profile);

  void set profile(String value) { _ptr.profile = _unwrap(value); }
}

class _HeadingElementImpl extends _ElementImpl implements HeadingElement {
  _HeadingElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _HistoryImpl extends _DOMTypeBase implements History {
  _HistoryImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Dynamic get state() => _wrap(_ptr.state);

  void back() => _ptr.back();

  void forward() => _ptr.forward();

  void go(int distance) => _ptr.go(_unwrap(distance));

  void pushState(Object data, String title, [String url = null]) => _ptr.pushState(_unwrap(data), _unwrap(title), _unwrap(url));

  void replaceState(Object data, String title, [String url = null]) => _ptr.replaceState(_unwrap(data), _unwrap(title), _unwrap(url));
}

class _HtmlElementImpl extends _ElementImpl implements HtmlElement {
  _HtmlElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBAnyImpl extends _DOMTypeBase implements IDBAny {
  _IDBAnyImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBCursorImpl extends _DOMTypeBase implements IDBCursor {
  _IDBCursorImpl._wrap(ptr) : super._wrap(ptr);

  String get direction() => _wrap(_ptr.direction);

  Dynamic get key() => _wrap(_ptr.key);

  Dynamic get primaryKey() => _wrap(_ptr.primaryKey);

  Dynamic get source() => _wrap(_ptr.source);

  void advance(int count) => _ptr.advance(_unwrap(count));

  void continueFunction([/*IDBKey*/ key = null]) => _ptr.continueFunction(_unwrap(key));

  IDBRequest delete() => _wrap(_ptr.delete());

  IDBRequest update(/*SerializedScriptValue*/ value) => _wrap(_ptr.update(_unwrap(value)));
}

class _IDBCursorWithValueImpl extends _IDBCursorImpl implements IDBCursorWithValue {
  _IDBCursorWithValueImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get value() => _wrap(_ptr.value);
}

class _IDBDatabaseImpl extends _EventTargetImpl implements IDBDatabase {
  _IDBDatabaseImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get name() => _wrap(_ptr.name);

  List<String> get objectStoreNames() => _wrap(_ptr.objectStoreNames);

  String get version() => _wrap(_ptr.version);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void close() => _ptr.close();

  IDBObjectStore createObjectStore(String name, [Map options = null]) => _wrap(_ptr.createObjectStore(_unwrap(name), _unwrap(options)));

  void deleteObjectStore(String name) => _ptr.deleteObjectStore(_unwrap(name));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  IDBVersionChangeRequest setVersion(String version) => _wrap(_ptr.setVersion(_unwrap(version)));

  IDBTransaction transaction(storeName_OR_storeNames, mode) => _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames), _unwrap(mode)));
}

class _IDBDatabaseExceptionImpl extends _DOMTypeBase implements IDBDatabaseException {
  _IDBDatabaseExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _IDBFactoryImpl extends _DOMTypeBase implements IDBFactory {
  _IDBFactoryImpl._wrap(ptr) : super._wrap(ptr);

  int cmp(/*IDBKey*/ first, /*IDBKey*/ second) => _wrap(_ptr.cmp(_unwrap(first), _unwrap(second)));

  IDBVersionChangeRequest deleteDatabase(String name) => _wrap(_ptr.deleteDatabase(_unwrap(name)));

  IDBRequest getDatabaseNames() => _wrap(_ptr.getDatabaseNames());

  IDBRequest open(String name) => _wrap(_ptr.open(_unwrap(name)));
}

class _IDBIndexImpl extends _DOMTypeBase implements IDBIndex {
  _IDBIndexImpl._wrap(ptr) : super._wrap(ptr);

  String get keyPath() => _wrap(_ptr.keyPath);

  bool get multiEntry() => _wrap(_ptr.multiEntry);

  String get name() => _wrap(_ptr.name);

  IDBObjectStore get objectStore() => _wrap(_ptr.objectStore);

  bool get unique() => _wrap(_ptr.unique);

  IDBRequest count([key_OR_range = null]) => _wrap(_ptr.count(_unwrap(key_OR_range)));

  IDBRequest get(key) => _wrap(_ptr.get(_unwrap(key)));

  IDBRequest getKey(key) => _wrap(_ptr.getKey(_unwrap(key)));

  IDBRequest openCursor([key_OR_range = null, direction = null]) => _wrap(_ptr.openCursor(_unwrap(key_OR_range), _unwrap(direction)));

  IDBRequest openKeyCursor([key_OR_range = null, direction = null]) => _wrap(_ptr.openKeyCursor(_unwrap(key_OR_range), _unwrap(direction)));
}

class _IDBKeyImpl extends _DOMTypeBase implements IDBKey {
  _IDBKeyImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBKeyRangeImpl extends _DOMTypeBase implements IDBKeyRange {
  _IDBKeyRangeImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get lower() => _wrap(_ptr.lower);

  bool get lowerOpen() => _wrap(_ptr.lowerOpen);

  Dynamic get upper() => _wrap(_ptr.upper);

  bool get upperOpen() => _wrap(_ptr.upperOpen);
}

class _IDBObjectStoreImpl extends _DOMTypeBase implements IDBObjectStore {
  _IDBObjectStoreImpl._wrap(ptr) : super._wrap(ptr);

  List<String> get indexNames() => _wrap(_ptr.indexNames);

  String get keyPath() => _wrap(_ptr.keyPath);

  String get name() => _wrap(_ptr.name);

  IDBTransaction get transaction() => _wrap(_ptr.transaction);

  IDBRequest add(/*SerializedScriptValue*/ value, [/*IDBKey*/ key = null]) => _wrap(_ptr.add(_unwrap(value), _unwrap(key)));

  IDBRequest clear() => _wrap(_ptr.clear());

  IDBRequest count([key_OR_range = null]) => _wrap(_ptr.count(_unwrap(key_OR_range)));

  IDBIndex createIndex(String name, String keyPath, [Map options = null]) => _wrap(_ptr.createIndex(_unwrap(name), _unwrap(keyPath), _unwrap(options)));

  IDBRequest delete(key_OR_keyRange) => _wrap(_ptr.delete(_unwrap(key_OR_keyRange)));

  void deleteIndex(String name) => _ptr.deleteIndex(_unwrap(name));

  IDBRequest getObject(key) => _wrap(_ptr.getObject(_unwrap(key)));

  IDBIndex index(String name) => _wrap(_ptr.index(_unwrap(name)));

  IDBRequest openCursor([key_OR_range = null, direction = null]) => _wrap(_ptr.openCursor(_unwrap(key_OR_range), _unwrap(direction)));

  IDBRequest put(/*SerializedScriptValue*/ value, [/*IDBKey*/ key = null]) => _wrap(_ptr.put(_unwrap(value), _unwrap(key)));
}

class _IDBRequestImpl extends _EventTargetImpl implements IDBRequest {
  _IDBRequestImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get errorCode() => _wrap(_ptr.errorCode);

  String get readyState() => _wrap(_ptr.readyState);

  Dynamic get result() => _wrap(_ptr.result);

  Dynamic get source() => _wrap(_ptr.source);

  IDBTransaction get transaction() => _wrap(_ptr.transaction);

  String get webkitErrorMessage() => _wrap(_ptr.webkitErrorMessage);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _IDBTransactionImpl extends _EventTargetImpl implements IDBTransaction {
  _IDBTransactionImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  IDBDatabase get db() => _wrap(_ptr.db);

  String get mode() => _wrap(_ptr.mode);

  void abort() => _ptr.abort();

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  IDBObjectStore objectStore(String name) => _wrap(_ptr.objectStore(_unwrap(name)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _IDBVersionChangeEventImpl extends _EventImpl implements IDBVersionChangeEvent {
  _IDBVersionChangeEventImpl._wrap(ptr) : super._wrap(ptr);

  String get version() => _wrap(_ptr.version);
}

class _IDBVersionChangeRequestImpl extends _IDBRequestImpl implements IDBVersionChangeRequest {
  _IDBVersionChangeRequestImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  // From EventTarget

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IFrameElementImpl extends _ElementImpl implements IFrameElement {

  Window get contentWindow() => _wrap(_ptr.contentWindow);

  _IFrameElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get frameBorder() => _wrap(_ptr.frameBorder);

  void set frameBorder(String value) { _ptr.frameBorder = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get marginHeight() => _wrap(_ptr.marginHeight);

  void set marginHeight(String value) { _ptr.marginHeight = _unwrap(value); }

  String get marginWidth() => _wrap(_ptr.marginWidth);

  void set marginWidth(String value) { _ptr.marginWidth = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get sandbox() => _wrap(_ptr.sandbox);

  void set sandbox(String value) { _ptr.sandbox = _unwrap(value); }

  String get scrolling() => _wrap(_ptr.scrolling);

  void set scrolling(String value) { _ptr.scrolling = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get srcdoc() => _wrap(_ptr.srcdoc);

  void set srcdoc(String value) { _ptr.srcdoc = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  SVGDocument getSVGDocument() => _wrap(_ptr.getSVGDocument());

}

class _IceCandidateImpl extends _DOMTypeBase implements IceCandidate {
  _IceCandidateImpl._wrap(ptr) : super._wrap(ptr);

  String get label() => _wrap(_ptr.label);

  String toSdp() => _wrap(_ptr.toSdp());
}

class _ImageDataImpl extends _DOMTypeBase implements ImageData {
  _ImageDataImpl._wrap(ptr) : super._wrap(ptr);

  Uint8ClampedArray get data() => _wrap(_ptr.data);

  int get height() => _wrap(_ptr.height);

  int get width() => _wrap(_ptr.width);
}

class _ImageElementImpl extends _ElementImpl implements ImageElement {
  _ImageElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  bool get complete() => _wrap(_ptr.complete);

  String get crossOrigin() => _wrap(_ptr.crossOrigin);

  void set crossOrigin(String value) { _ptr.crossOrigin = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  bool get isMap() => _wrap(_ptr.isMap);

  void set isMap(bool value) { _ptr.isMap = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get lowsrc() => _wrap(_ptr.lowsrc);

  void set lowsrc(String value) { _ptr.lowsrc = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  int get naturalHeight() => _wrap(_ptr.naturalHeight);

  int get naturalWidth() => _wrap(_ptr.naturalWidth);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);
}

class _InputElementImpl extends _ElementImpl implements InputElement {
  _InputElementImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get accept() => _wrap(_ptr.accept);

  void set accept(String value) { _ptr.accept = _unwrap(value); }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get autocomplete() => _wrap(_ptr.autocomplete);

  void set autocomplete(String value) { _ptr.autocomplete = _unwrap(value); }

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get checked() => _wrap(_ptr.checked);

  void set checked(bool value) { _ptr.checked = _unwrap(value); }

  bool get defaultChecked() => _wrap(_ptr.defaultChecked);

  void set defaultChecked(bool value) { _ptr.defaultChecked = _unwrap(value); }

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FileList get files() => _wrap(_ptr.files);

  FormElement get form() => _wrap(_ptr.form);

  String get formAction() => _wrap(_ptr.formAction);

  void set formAction(String value) { _ptr.formAction = _unwrap(value); }

  String get formEnctype() => _wrap(_ptr.formEnctype);

  void set formEnctype(String value) { _ptr.formEnctype = _unwrap(value); }

  String get formMethod() => _wrap(_ptr.formMethod);

  void set formMethod(String value) { _ptr.formMethod = _unwrap(value); }

  bool get formNoValidate() => _wrap(_ptr.formNoValidate);

  void set formNoValidate(bool value) { _ptr.formNoValidate = _unwrap(value); }

  String get formTarget() => _wrap(_ptr.formTarget);

  void set formTarget(String value) { _ptr.formTarget = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  bool get incremental() => _wrap(_ptr.incremental);

  void set incremental(bool value) { _ptr.incremental = _unwrap(value); }

  bool get indeterminate() => _wrap(_ptr.indeterminate);

  void set indeterminate(bool value) { _ptr.indeterminate = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get max() => _wrap(_ptr.max);

  void set max(String value) { _ptr.max = _unwrap(value); }

  int get maxLength() => _wrap(_ptr.maxLength);

  void set maxLength(int value) { _ptr.maxLength = _unwrap(value); }

  String get min() => _wrap(_ptr.min);

  void set min(String value) { _ptr.min = _unwrap(value); }

  bool get multiple() => _wrap(_ptr.multiple);

  void set multiple(bool value) { _ptr.multiple = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get pattern() => _wrap(_ptr.pattern);

  void set pattern(String value) { _ptr.pattern = _unwrap(value); }

  String get placeholder() => _wrap(_ptr.placeholder);

  void set placeholder(String value) { _ptr.placeholder = _unwrap(value); }

  bool get readOnly() => _wrap(_ptr.readOnly);

  void set readOnly(bool value) { _ptr.readOnly = _unwrap(value); }

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  String get selectionDirection() => _wrap(_ptr.selectionDirection);

  void set selectionDirection(String value) { _ptr.selectionDirection = _unwrap(value); }

  int get selectionEnd() => _wrap(_ptr.selectionEnd);

  void set selectionEnd(int value) { _ptr.selectionEnd = _unwrap(value); }

  int get selectionStart() => _wrap(_ptr.selectionStart);

  void set selectionStart(int value) { _ptr.selectionStart = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get step() => _wrap(_ptr.step);

  void set step(String value) { _ptr.step = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  Date get valueAsDate() => _wrap(_ptr.valueAsDate);

  void set valueAsDate(Date value) { _ptr.valueAsDate = _unwrap(value); }

  num get valueAsNumber() => _wrap(_ptr.valueAsNumber);

  void set valueAsNumber(num value) { _ptr.valueAsNumber = _unwrap(value); }

  bool get webkitGrammar() => _wrap(_ptr.webkitGrammar);

  void set webkitGrammar(bool value) { _ptr.webkitGrammar = _unwrap(value); }

  bool get webkitSpeech() => _wrap(_ptr.webkitSpeech);

  void set webkitSpeech(bool value) { _ptr.webkitSpeech = _unwrap(value); }

  bool get webkitdirectory() => _wrap(_ptr.webkitdirectory);

  void set webkitdirectory(bool value) { _ptr.webkitdirectory = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void select() => _ptr.select();

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));

  void setSelectionRange(int start, int end, [String direction = null]) => _ptr.setSelectionRange(_unwrap(start), _unwrap(end), _unwrap(direction));

  void stepDown([int n = null]) => _ptr.stepDown(_unwrap(n));

  void stepUp([int n = null]) => _ptr.stepUp(_unwrap(n));
}

class _Int16ArrayImpl extends _ArrayBufferViewImpl implements Int16Array, List<int> {
  _Int16ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Int16Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _Int32ArrayImpl extends _ArrayBufferViewImpl implements Int32Array, List<int> {
  _Int32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Int32Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _Int8ArrayImpl extends _ArrayBufferViewImpl implements Int8Array, List<int> {
  _Int8ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Int8Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _JavaScriptAudioNodeImpl extends _AudioNodeImpl implements JavaScriptAudioNode {
  _JavaScriptAudioNodeImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get bufferSize() => _wrap(_ptr.bufferSize);

  // From EventTarget

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _JavaScriptCallFrameImpl extends _DOMTypeBase implements JavaScriptCallFrame {
  _JavaScriptCallFrameImpl._wrap(ptr) : super._wrap(ptr);

  JavaScriptCallFrame get caller() => _wrap(_ptr.caller);

  int get column() => _wrap(_ptr.column);

  String get functionName() => _wrap(_ptr.functionName);

  int get line() => _wrap(_ptr.line);

  List get scopeChain() => _wrap(_ptr.scopeChain);

  int get sourceID() => _wrap(_ptr.sourceID);

  Object get thisObject() => _wrap(_ptr.thisObject);

  String get type() => _wrap(_ptr.type);

  void evaluate(String script) => _ptr.evaluate(_unwrap(script));

  int scopeType(int scopeIndex) => _wrap(_ptr.scopeType(_unwrap(scopeIndex)));
}

class _KeyboardEventImpl extends _UIEventImpl implements KeyboardEvent {
  _KeyboardEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altGraphKey() => _wrap(_ptr.altGraphKey);

  bool get altKey() => _wrap(_ptr.altKey);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  String get keyIdentifier() => _wrap(_ptr.keyIdentifier);

  int get keyLocation() => _wrap(_ptr.keyLocation);

  bool get metaKey() => _wrap(_ptr.metaKey);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) => _ptr.initKeyboardEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(keyIdentifier), _unwrap(keyLocation), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey), _unwrap(altGraphKey));
}

class _KeygenElementImpl extends _ElementImpl implements KeygenElement {
  _KeygenElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  String get challenge() => _wrap(_ptr.challenge);

  void set challenge(String value) { _ptr.challenge = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get keytype() => _wrap(_ptr.keytype);

  void set keytype(String value) { _ptr.keytype = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));
}

class _LIElementImpl extends _ElementImpl implements LIElement {
  _LIElementImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  int get value() => _wrap(_ptr.value);

  void set value(int value) { _ptr.value = _unwrap(value); }
}

class _LabelElementImpl extends _ElementImpl implements LabelElement {
  _LabelElementImpl._wrap(ptr) : super._wrap(ptr);

  Element get control() => _wrap(_ptr.control);

  FormElement get form() => _wrap(_ptr.form);

  String get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(String value) { _ptr.htmlFor = _unwrap(value); }
}

class _LegendElementImpl extends _ElementImpl implements LegendElement {
  _LegendElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);
}

class _LinkElementImpl extends _ElementImpl implements LinkElement {
  _LinkElementImpl._wrap(ptr) : super._wrap(ptr);

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get hreflang() => _wrap(_ptr.hreflang);

  void set hreflang(String value) { _ptr.hreflang = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get rel() => _wrap(_ptr.rel);

  void set rel(String value) { _ptr.rel = _unwrap(value); }

  String get rev() => _wrap(_ptr.rev);

  void set rev(String value) { _ptr.rev = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  DOMSettableTokenList get sizes() => _wrap(_ptr.sizes);

  void set sizes(DOMSettableTokenList value) { _ptr.sizes = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _LocalMediaStreamImpl extends _MediaStreamImpl implements LocalMediaStream {
  _LocalMediaStreamImpl._wrap(ptr) : super._wrap(ptr);

  void stop() => _ptr.stop();
}

class _LocationImpl extends _DOMTypeBase implements Location {
  _LocationImpl._wrap(ptr) : super._wrap(ptr);

  List<String> get ancestorOrigins() => _wrap(_ptr.ancestorOrigins);

  String get hash() => _wrap(_ptr.hash);

  void set hash(String value) { _ptr.hash = _unwrap(value); }

  String get host() => _wrap(_ptr.host);

  void set host(String value) { _ptr.host = _unwrap(value); }

  String get hostname() => _wrap(_ptr.hostname);

  void set hostname(String value) { _ptr.hostname = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get origin() => _wrap(_ptr.origin);

  String get pathname() => _wrap(_ptr.pathname);

  void set pathname(String value) { _ptr.pathname = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  void set port(String value) { _ptr.port = _unwrap(value); }

  String get protocol() => _wrap(_ptr.protocol);

  void set protocol(String value) { _ptr.protocol = _unwrap(value); }

  String get search() => _wrap(_ptr.search);

  void set search(String value) { _ptr.search = _unwrap(value); }

  void assign(String url) => _ptr.assign(_unwrap(url));

  void reload() => _ptr.reload();

  void replace(String url) => _ptr.replace(_unwrap(url));

  String toString() => _wrap(_ptr.toString());
}

class _MapElementImpl extends _ElementImpl implements MapElement {
  _MapElementImpl._wrap(ptr) : super._wrap(ptr);

  HTMLCollection get areas() => _wrap(_ptr.areas);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }
}

class _MarqueeElementImpl extends _ElementImpl implements MarqueeElement {
  _MarqueeElementImpl._wrap(ptr) : super._wrap(ptr);

  String get behavior() => _wrap(_ptr.behavior);

  void set behavior(String value) { _ptr.behavior = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get direction() => _wrap(_ptr.direction);

  void set direction(String value) { _ptr.direction = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  int get loop() => _wrap(_ptr.loop);

  void set loop(int value) { _ptr.loop = _unwrap(value); }

  int get scrollAmount() => _wrap(_ptr.scrollAmount);

  void set scrollAmount(int value) { _ptr.scrollAmount = _unwrap(value); }

  int get scrollDelay() => _wrap(_ptr.scrollDelay);

  void set scrollDelay(int value) { _ptr.scrollDelay = _unwrap(value); }

  bool get trueSpeed() => _wrap(_ptr.trueSpeed);

  void set trueSpeed(bool value) { _ptr.trueSpeed = _unwrap(value); }

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  void start() => _ptr.start();

  void stop() => _ptr.stop();
}

class _MediaControllerImpl extends _EventTargetImpl implements MediaController {
  _MediaControllerImpl._wrap(ptr) : super._wrap(ptr);

  TimeRanges get buffered() => _wrap(_ptr.buffered);

  num get currentTime() => _wrap(_ptr.currentTime);

  void set currentTime(num value) { _ptr.currentTime = _unwrap(value); }

  num get defaultPlaybackRate() => _wrap(_ptr.defaultPlaybackRate);

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = _unwrap(value); }

  num get duration() => _wrap(_ptr.duration);

  bool get muted() => _wrap(_ptr.muted);

  void set muted(bool value) { _ptr.muted = _unwrap(value); }

  bool get paused() => _wrap(_ptr.paused);

  num get playbackRate() => _wrap(_ptr.playbackRate);

  void set playbackRate(num value) { _ptr.playbackRate = _unwrap(value); }

  TimeRanges get played() => _wrap(_ptr.played);

  TimeRanges get seekable() => _wrap(_ptr.seekable);

  num get volume() => _wrap(_ptr.volume);

  void set volume(num value) { _ptr.volume = _unwrap(value); }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void pause() => _ptr.pause();

  void play() => _ptr.play();

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _MediaElementImpl extends _ElementImpl implements MediaElement {
  _MediaElementImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  bool get autoplay() => _wrap(_ptr.autoplay);

  void set autoplay(bool value) { _ptr.autoplay = _unwrap(value); }

  TimeRanges get buffered() => _wrap(_ptr.buffered);

  MediaController get controller() => _wrap(_ptr.controller);

  void set controller(MediaController value) { _ptr.controller = _unwrap(value); }

  bool get controls() => _wrap(_ptr.controls);

  void set controls(bool value) { _ptr.controls = _unwrap(value); }

  String get currentSrc() => _wrap(_ptr.currentSrc);

  num get currentTime() => _wrap(_ptr.currentTime);

  void set currentTime(num value) { _ptr.currentTime = _unwrap(value); }

  bool get defaultMuted() => _wrap(_ptr.defaultMuted);

  void set defaultMuted(bool value) { _ptr.defaultMuted = _unwrap(value); }

  num get defaultPlaybackRate() => _wrap(_ptr.defaultPlaybackRate);

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = _unwrap(value); }

  num get duration() => _wrap(_ptr.duration);

  bool get ended() => _wrap(_ptr.ended);

  MediaError get error() => _wrap(_ptr.error);

  num get initialTime() => _wrap(_ptr.initialTime);

  bool get loop() => _wrap(_ptr.loop);

  void set loop(bool value) { _ptr.loop = _unwrap(value); }

  String get mediaGroup() => _wrap(_ptr.mediaGroup);

  void set mediaGroup(String value) { _ptr.mediaGroup = _unwrap(value); }

  bool get muted() => _wrap(_ptr.muted);

  void set muted(bool value) { _ptr.muted = _unwrap(value); }

  int get networkState() => _wrap(_ptr.networkState);

  bool get paused() => _wrap(_ptr.paused);

  num get playbackRate() => _wrap(_ptr.playbackRate);

  void set playbackRate(num value) { _ptr.playbackRate = _unwrap(value); }

  TimeRanges get played() => _wrap(_ptr.played);

  String get preload() => _wrap(_ptr.preload);

  void set preload(String value) { _ptr.preload = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  TimeRanges get seekable() => _wrap(_ptr.seekable);

  bool get seeking() => _wrap(_ptr.seeking);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  num get startTime() => _wrap(_ptr.startTime);

  TextTrackList get textTracks() => _wrap(_ptr.textTracks);

  num get volume() => _wrap(_ptr.volume);

  void set volume(num value) { _ptr.volume = _unwrap(value); }

  int get webkitAudioDecodedByteCount() => _wrap(_ptr.webkitAudioDecodedByteCount);

  bool get webkitClosedCaptionsVisible() => _wrap(_ptr.webkitClosedCaptionsVisible);

  void set webkitClosedCaptionsVisible(bool value) { _ptr.webkitClosedCaptionsVisible = _unwrap(value); }

  bool get webkitHasClosedCaptions() => _wrap(_ptr.webkitHasClosedCaptions);

  String get webkitMediaSourceURL() => _wrap(_ptr.webkitMediaSourceURL);

  bool get webkitPreservesPitch() => _wrap(_ptr.webkitPreservesPitch);

  void set webkitPreservesPitch(bool value) { _ptr.webkitPreservesPitch = _unwrap(value); }

  int get webkitSourceState() => _wrap(_ptr.webkitSourceState);

  int get webkitVideoDecodedByteCount() => _wrap(_ptr.webkitVideoDecodedByteCount);

  TextTrack addTextTrack(String kind, [String label = null, String language = null]) => _wrap(_ptr.addTextTrack(_unwrap(kind), _unwrap(label), _unwrap(language)));

  String canPlayType(String type, String keySystem) => _wrap(_ptr.canPlayType(_unwrap(type), _unwrap(keySystem)));

  void load() => _ptr.load();

  void pause() => _ptr.pause();

  void play() => _ptr.play();

  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData = null, String sessionId = null]) => _ptr.webkitAddKey(_unwrap(keySystem), _unwrap(key), _unwrap(initData), _unwrap(sessionId));

  void webkitCancelKeyRequest(String keySystem, String sessionId) => _ptr.webkitCancelKeyRequest(_unwrap(keySystem), _unwrap(sessionId));

  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData = null]) => _ptr.webkitGenerateKeyRequest(_unwrap(keySystem), _unwrap(initData));

  void webkitSourceAppend(Uint8Array data) => _ptr.webkitSourceAppend(_unwrap(data));

  void webkitSourceEndOfStream(int status) => _ptr.webkitSourceEndOfStream(_unwrap(status));
}

class _MediaElementAudioSourceNodeImpl extends _AudioSourceNodeImpl implements MediaElementAudioSourceNode {
  _MediaElementAudioSourceNodeImpl._wrap(ptr) : super._wrap(ptr);

  MediaElement get mediaElement() => _wrap(_ptr.mediaElement);
}

class _MediaErrorImpl extends _DOMTypeBase implements MediaError {
  _MediaErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _MediaKeyErrorImpl extends _DOMTypeBase implements MediaKeyError {
  _MediaKeyErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _MediaKeyEventImpl extends _EventImpl implements MediaKeyEvent {
  _MediaKeyEventImpl._wrap(ptr) : super._wrap(ptr);

  String get defaultURL() => _wrap(_ptr.defaultURL);

  MediaKeyError get errorCode() => _wrap(_ptr.errorCode);

  Uint8Array get initData() => _wrap(_ptr.initData);

  String get keySystem() => _wrap(_ptr.keySystem);

  Uint8Array get message() => _wrap(_ptr.message);

  String get sessionId() => _wrap(_ptr.sessionId);

  int get systemCode() => _wrap(_ptr.systemCode);
}

class _MediaListImpl extends _DOMTypeBase implements MediaList {
  _MediaListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  String get mediaText() => _wrap(_ptr.mediaText);

  void set mediaText(String value) { _ptr.mediaText = _unwrap(value); }

  String operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<String>(this);
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(String element)) => _Collections.forEach(this, f);

  Collection map(f(String element)) => _Collections.map(this, [], f);

  Collection<String> filter(bool f(String element)) =>
     _Collections.filter(this, <String>[], f);

  bool every(bool f(String element)) => _Collections.every(this, f);

  bool some(bool f(String element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<String>:

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  String last() => this[length - 1];

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  void appendMedium(String newMedium) => _ptr.appendMedium(_unwrap(newMedium));

  void deleteMedium(String oldMedium) => _ptr.deleteMedium(_unwrap(oldMedium));

  String item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _MediaQueryListImpl extends _DOMTypeBase implements MediaQueryList {
  _MediaQueryListImpl._wrap(ptr) : super._wrap(ptr);

  bool get matches() => _wrap(_ptr.matches);

  String get media() => _wrap(_ptr.media);

  void addListener(MediaQueryListListener listener) => _ptr.addListener(_unwrap(listener));

  void removeListener(MediaQueryListListener listener) => _ptr.removeListener(_unwrap(listener));
}

class _MediaQueryListListenerImpl extends _DOMTypeBase implements MediaQueryListListener {
  _MediaQueryListListenerImpl._wrap(ptr) : super._wrap(ptr);

  void queryChanged(MediaQueryList list) => _ptr.queryChanged(_unwrap(list));
}

class _MediaStreamImpl extends _EventTargetImpl implements MediaStream {
  _MediaStreamImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  MediaStreamTrackList get audioTracks() => _wrap(_ptr.audioTracks);

  String get label() => _wrap(_ptr.label);

  int get readyState() => _wrap(_ptr.readyState);

  MediaStreamTrackList get videoTracks() => _wrap(_ptr.videoTracks);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _MediaStreamEventImpl extends _EventImpl implements MediaStreamEvent {
  _MediaStreamEventImpl._wrap(ptr) : super._wrap(ptr);

  MediaStream get stream() => _wrap(_ptr.stream);
}

class _MediaStreamListImpl extends _DOMTypeBase implements MediaStreamList {
  _MediaStreamListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  MediaStream item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _MediaStreamTrackImpl extends _DOMTypeBase implements MediaStreamTrack {
  _MediaStreamTrackImpl._wrap(ptr) : super._wrap(ptr);

  bool get enabled() => _wrap(_ptr.enabled);

  void set enabled(bool value) { _ptr.enabled = _unwrap(value); }

  String get kind() => _wrap(_ptr.kind);

  String get label() => _wrap(_ptr.label);
}

class _MediaStreamTrackListImpl extends _DOMTypeBase implements MediaStreamTrackList {
  _MediaStreamTrackListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  MediaStreamTrack item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _MemoryInfoImpl extends _DOMTypeBase implements MemoryInfo {
  _MemoryInfoImpl._wrap(ptr) : super._wrap(ptr);

  int get jsHeapSizeLimit() => _wrap(_ptr.jsHeapSizeLimit);

  int get totalJSHeapSize() => _wrap(_ptr.totalJSHeapSize);

  int get usedJSHeapSize() => _wrap(_ptr.usedJSHeapSize);
}

class _MenuElementImpl extends _ElementImpl implements MenuElement {
  _MenuElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _MessageChannelImpl extends _DOMTypeBase implements MessageChannel {
  _MessageChannelImpl._wrap(ptr) : super._wrap(ptr);

  MessagePort get port1() => _wrap(_ptr.port1);

  MessagePort get port2() => _wrap(_ptr.port2);
}

class _MessageEventImpl extends _EventImpl implements MessageEvent {
  _MessageEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get data() => _wrap(_ptr.data);

  String get lastEventId() => _wrap(_ptr.lastEventId);

  String get origin() => _wrap(_ptr.origin);

  List get ports() => _wrap(_ptr.ports);

  Window get source() => _wrap(_ptr.source);

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts) => _ptr.initMessageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(dataArg), _unwrap(originArg), _unwrap(lastEventIdArg), _unwrap(sourceArg), _unwrap(messagePorts));

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables) => _ptr.webkitInitMessageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(dataArg), _unwrap(originArg), _unwrap(lastEventIdArg), _unwrap(sourceArg), _unwrap(transferables));
}

class _MessagePortImpl extends _EventTargetImpl implements MessagePort {
  _MessagePortImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void close() => _ptr.close();

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void postMessage(String message, [List messagePorts = null]) => _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void start() => _ptr.start();

  void webkitPostMessage(String message, [List transfer = null]) => _ptr.webkitPostMessage(_unwrap(message), _unwrap(transfer));
}

class _MetaElementImpl extends _ElementImpl implements MetaElement {
  _MetaElementImpl._wrap(ptr) : super._wrap(ptr);

  String get content() => _wrap(_ptr.content);

  void set content(String value) { _ptr.content = _unwrap(value); }

  String get httpEquiv() => _wrap(_ptr.httpEquiv);

  void set httpEquiv(String value) { _ptr.httpEquiv = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get scheme() => _wrap(_ptr.scheme);

  void set scheme(String value) { _ptr.scheme = _unwrap(value); }
}

class _MetadataImpl extends _DOMTypeBase implements Metadata {
  _MetadataImpl._wrap(ptr) : super._wrap(ptr);

  Date get modificationTime() => _wrap(_ptr.modificationTime);

  int get size() => _wrap(_ptr.size);
}

class _MeterElementImpl extends _ElementImpl implements MeterElement {
  _MeterElementImpl._wrap(ptr) : super._wrap(ptr);

  num get high() => _wrap(_ptr.high);

  void set high(num value) { _ptr.high = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  num get low() => _wrap(_ptr.low);

  void set low(num value) { _ptr.low = _unwrap(value); }

  num get max() => _wrap(_ptr.max);

  void set max(num value) { _ptr.max = _unwrap(value); }

  num get min() => _wrap(_ptr.min);

  void set min(num value) { _ptr.min = _unwrap(value); }

  num get optimum() => _wrap(_ptr.optimum);

  void set optimum(num value) { _ptr.optimum = _unwrap(value); }

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _ModElementImpl extends _ElementImpl implements ModElement {
  _ModElementImpl._wrap(ptr) : super._wrap(ptr);

  String get cite() => _wrap(_ptr.cite);

  void set cite(String value) { _ptr.cite = _unwrap(value); }

  String get dateTime() => _wrap(_ptr.dateTime);

  void set dateTime(String value) { _ptr.dateTime = _unwrap(value); }
}

class _MouseEventImpl extends _UIEventImpl implements MouseEvent {
  _MouseEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  int get button() => _wrap(_ptr.button);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  Clipboard get dataTransfer() => _wrap(_ptr.dataTransfer);

  Node get fromElement() => _wrap(_ptr.fromElement);

  bool get metaKey() => _wrap(_ptr.metaKey);

  int get offsetX() => _wrap(_ptr.offsetX);

  int get offsetY() => _wrap(_ptr.offsetY);

  EventTarget get relatedTarget() => _wrap(_ptr.relatedTarget);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  Node get toElement() => _wrap(_ptr.toElement);

  int get webkitMovementX() => _wrap(_ptr.webkitMovementX);

  int get webkitMovementY() => _wrap(_ptr.webkitMovementY);

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);

  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) => _ptr.$dom_initMouseEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(detail), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey), _unwrap(button), _unwrap(relatedTarget));
}

class _MutationCallbackImpl extends _DOMTypeBase implements MutationCallback {
  _MutationCallbackImpl._wrap(ptr) : super._wrap(ptr);
}

class _MutationEventImpl extends _EventImpl implements MutationEvent {
  _MutationEventImpl._wrap(ptr) : super._wrap(ptr);

  int get attrChange() => _wrap(_ptr.attrChange);

  String get attrName() => _wrap(_ptr.attrName);

  String get newValue() => _wrap(_ptr.newValue);

  String get prevValue() => _wrap(_ptr.prevValue);

  Node get relatedNode() => _wrap(_ptr.relatedNode);

  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) => _ptr.initMutationEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(relatedNode), _unwrap(prevValue), _unwrap(newValue), _unwrap(attrName), _unwrap(attrChange));
}

class _MutationRecordImpl extends _DOMTypeBase implements MutationRecord {
  _MutationRecordImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get addedNodes() => _wrap(_ptr.addedNodes);

  String get attributeName() => _wrap(_ptr.attributeName);

  String get attributeNamespace() => _wrap(_ptr.attributeNamespace);

  Node get nextSibling() => _wrap(_ptr.nextSibling);

  String get oldValue() => _wrap(_ptr.oldValue);

  Node get previousSibling() => _wrap(_ptr.previousSibling);

  NodeList get removedNodes() => _wrap(_ptr.removedNodes);

  Node get target() => _wrap(_ptr.target);

  String get type() => _wrap(_ptr.type);
}

class _NamedNodeMapImpl extends _DOMTypeBase implements NamedNodeMap {
  _NamedNodeMapImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node last() => this[length - 1];

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  Node getNamedItem(String name) => _wrap(_ptr.getNamedItem(_unwrap(name)));

  Node getNamedItemNS(String namespaceURI, String localName) => _wrap(_ptr.getNamedItemNS(_unwrap(namespaceURI), _unwrap(localName)));

  Node item(int index) => _wrap(_ptr.item(_unwrap(index)));

  Node removeNamedItem(String name) => _wrap(_ptr.removeNamedItem(_unwrap(name)));

  Node removeNamedItemNS(String namespaceURI, String localName) => _wrap(_ptr.removeNamedItemNS(_unwrap(namespaceURI), _unwrap(localName)));

  Node setNamedItem(Node node) => _wrap(_ptr.setNamedItem(_unwrap(node)));

  Node setNamedItemNS(Node node) => _wrap(_ptr.setNamedItemNS(_unwrap(node)));
}

class _NavigatorImpl extends _DOMTypeBase implements Navigator {
  _NavigatorImpl._wrap(ptr) : super._wrap(ptr);

  String get appCodeName() => _wrap(_ptr.appCodeName);

  String get appName() => _wrap(_ptr.appName);

  String get appVersion() => _wrap(_ptr.appVersion);

  bool get cookieEnabled() => _wrap(_ptr.cookieEnabled);

  Geolocation get geolocation() => _wrap(_ptr.geolocation);

  String get language() => _wrap(_ptr.language);

  DOMMimeTypeArray get mimeTypes() => _wrap(_ptr.mimeTypes);

  bool get onLine() => _wrap(_ptr.onLine);

  String get platform() => _wrap(_ptr.platform);

  DOMPluginArray get plugins() => _wrap(_ptr.plugins);

  String get product() => _wrap(_ptr.product);

  String get productSub() => _wrap(_ptr.productSub);

  String get userAgent() => _wrap(_ptr.userAgent);

  String get vendor() => _wrap(_ptr.vendor);

  String get vendorSub() => _wrap(_ptr.vendorSub);

  BatteryManager get webkitBattery() => _wrap(_ptr.webkitBattery);

  PointerLock get webkitPointer() => _wrap(_ptr.webkitPointer);

  void getStorageUpdates() => _ptr.getStorageUpdates();

  bool javaEnabled() => _wrap(_ptr.javaEnabled());

  void registerProtocolHandler(String scheme, String url, String title) => _ptr.registerProtocolHandler(_unwrap(scheme), _unwrap(url), _unwrap(title));

  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback = null]) => _ptr.webkitGetUserMedia(_unwrap(options), _unwrap(successCallback), _unwrap(errorCallback));
}

class _NavigatorUserMediaErrorImpl extends _DOMTypeBase implements NavigatorUserMediaError {
  _NavigatorUserMediaErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Lazy implementation of the child nodes of an element that does not request
 * the actual child nodes of an element until strictly necessary greatly
 * improving performance for the typical cases where it is not required.
 */
class _ChildNodeListLazy implements NodeList {
  final _NodeImpl _this;

  _ChildNodeListLazy(this._this);


  _NodeImpl get first() => _this.$dom_firstChild;
  _NodeImpl last() => _this.$dom_lastChild;

  void add(_NodeImpl value) {
    _this.$dom_appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _this.$dom_appendChild(value);
  }


  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _this.$dom_appendChild(node);
    }
  }

  _NodeImpl removeLast() {
    final result = last();
    if (result != null) {
      _this.$dom_removeChild(result);
    }
    return result;
  }

  void clear() {
    _this.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _this.$dom_replaceChild(value, this[index]);
  }

  Iterator<Node> iterator() => _this.$dom_childNodes.iterator();

  // TODO(jacobr): We can implement these methods much more efficiently by
  // looking up the nodeList only once instead of once per iteration.
  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  // TODO(jacobr): this could be implemented for child node lists.
  // The exception we throw here is misleading.
  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException(
        "Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException(
        "Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException(
        "Cannot insertRange on immutable List.");
  }
  NodeList getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_Lists.getRange(this, start, rangeLength, <Node>[]));

  // -- end List<Node> mixins.

  // TODO(jacobr): benchmark whether this is more efficient or whether caching
  // a local copy of $dom_childNodes is more efficient.
  int get length() => _this.$dom_childNodes.length;

  _NodeImpl operator[](int index) => _this.$dom_childNodes[index];
}

class _NodeImpl extends _EventTargetImpl implements Node {
  _ChildNodeListLazy get nodes() {
    return new _ChildNodeListLazy(this);
  }

  void set nodes(Collection<Node> value) {
    // Copy list first since we don't want liveness during iteration.
    // TODO(jacobr): there is a better way to do this.
    List copy = new List.from(value);
    text = '';
    for (Node node in copy) {
      $dom_appendChild(node);
    }
  }

  // TODO(jacobr): should we throw an exception if parent is already null?
  _NodeImpl remove() {
    if (this.parent != null) {
      final _NodeImpl parent = this.parent;
      parent.$dom_removeChild(this);
    }
    return this;
  }

  _NodeImpl replaceWith(Node otherNode) {
    try {
      final _NodeImpl parent = this.parent;
      parent.$dom_replaceChild(otherNode, this);
    } catch(var e) {
      
    };
    return this;
  }

  _NodeImpl._wrap(ptr) : super._wrap(ptr);

  NamedNodeMap get $dom_attributes() => _wrap(_ptr.$dom_attributes);

  NodeList get $dom_childNodes() => _wrap(_ptr.$dom_childNodes);

  Node get $dom_firstChild() => _wrap(_ptr.$dom_firstChild);

  Node get $dom_lastChild() => _wrap(_ptr.$dom_lastChild);

  Node get nextNode() => _wrap(_ptr.nextNode);

  int get $dom_nodeType() => _wrap(_ptr.$dom_nodeType);

  Document get document() => _wrap(_ptr.document);

  Node get parent() => _wrap(_ptr.parent);

  Node get previousNode() => _wrap(_ptr.previousNode);

  String get text() => _wrap(_ptr.text);

  void set text(String value) { _ptr.text = _unwrap(value); }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  Node $dom_appendChild(Node newChild) => _wrap(_ptr.$dom_appendChild(_unwrap(newChild)));

  Node clone(bool deep) => _wrap(_ptr.clone(_unwrap(deep)));

  bool contains(Node other) => _wrap(_ptr.contains(_unwrap(other)));

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  bool hasChildNodes() => _wrap(_ptr.hasChildNodes());

  Node insertBefore(Node newChild, Node refChild) => _wrap(_ptr.insertBefore(_unwrap(newChild), _unwrap(refChild)));

  Node $dom_removeChild(Node oldChild) => _wrap(_ptr.$dom_removeChild(_unwrap(oldChild)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  Node $dom_replaceChild(Node newChild, Node oldChild) => _wrap(_ptr.$dom_replaceChild(_unwrap(newChild), _unwrap(oldChild)));

}

class _NodeFilterImpl extends _DOMTypeBase implements NodeFilter {
  _NodeFilterImpl._wrap(ptr) : super._wrap(ptr);

  int acceptNode(Node n) => _wrap(_ptr.acceptNode(_unwrap(n)));
}

class _NodeIteratorImpl extends _DOMTypeBase implements NodeIterator {
  _NodeIteratorImpl._wrap(ptr) : super._wrap(ptr);

  bool get expandEntityReferences() => _wrap(_ptr.expandEntityReferences);

  NodeFilter get filter() => _wrap(_ptr.filter);

  bool get pointerBeforeReferenceNode() => _wrap(_ptr.pointerBeforeReferenceNode);

  Node get referenceNode() => _wrap(_ptr.referenceNode);

  Node get root() => _wrap(_ptr.root);

  int get whatToShow() => _wrap(_ptr.whatToShow);

  void detach() => _ptr.detach();

  Node nextNode() => _wrap(_ptr.nextNode());

  Node previousNode() => _wrap(_ptr.previousNode());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(nweiz): when all implementations we target have the same name for the
// coreimpl implementation of List<E>, extend that rather than wrapping.
class _ListWrapper<E> implements List<E> {
  List _list;

  _ListWrapper(List this._list);

  Iterator<E> iterator() => _list.iterator();

  void forEach(void f(E element)) => _list.forEach(f);

  Collection map(f(E element)) => _list.map(f);

  List<E> filter(bool f(E element)) => _list.filter(f);

  bool every(bool f(E element)) => _list.every(f);

  bool some(bool f(E element)) => _list.some(f);

  bool isEmpty() => _list.isEmpty();

  int get length() => _list.length;

  E operator [](int index) => _list[index];

  void operator []=(int index, E value) { _list[index] = value; }

  void set length(int newLength) { _list.length = newLength; }

  void add(E value) => _list.add(value);

  void addLast(E value) => _list.addLast(value);

  void addAll(Collection<E> collection) => _list.addAll(collection);

  void sort(int compare(E a, E b)) => _list.sort(compare);

  int indexOf(E element, [int start = 0]) => _list.indexOf(element, start);

  int lastIndexOf(E element, [int start = 0]) =>
    _list.lastIndexOf(element, start);

  void clear() => _list.clear();

  E removeLast() => _list.removeLast();

  E last() => _list.last();

  List<E> getRange(int start, int rangeLength) =>
    _list.getRange(start, rangeLength);

  void setRange(int start, int rangeLength, List<E> from, [int startFrom = 0])
      => _list.setRange(start, rangeLength, from, startFrom);

  void removeRange(int start, int rangeLength) =>
    _list.removeRange(start, rangeLength);

  void insertRange(int start, int rangeLength, [E initialValue = null]) =>
    _list.insertRange(start, rangeLength, initialValue);

  E get first() => _list[0];
}

/**
 * This class is used to insure the results of list operations are NodeLists
 * instead of lists.
 */
class _NodeListWrapper extends _ListWrapper<Node> implements NodeList {
  _NodeListWrapper(List list) : super(list);

  NodeList filter(bool f(Node element)) =>
    new _NodeListWrapper(_list.filter(f));

  NodeList getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_list.getRange(start, rangeLength));
}

class _NodeListImpl extends _DOMTypeBase implements NodeList {
  _NodeImpl _parent;

  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(_NodeImpl value) {
    _parent.$dom_appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _parent.$dom_appendChild(value);
  }

  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _parent.$dom_appendChild(node);      
    }
  }

  _NodeImpl removeLast() {
    final result = this.last();
    if (result != null) {
      _parent.$dom_removeChild(result);
    }
    return result;
  }

  void clear() {
    _parent.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _parent.$dom_replaceChild(value, this[index]);
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  Node last() => this[length - 1];
  Node get first() => this[0];

  // FIXME: implement thesee.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }
  NodeList getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_Lists.getRange(this, start, rangeLength, <Node>[]));

  // -- end List<Node> mixins.

  _NodeListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);

}

class _NodeSelectorImpl extends _DOMTypeBase implements NodeSelector {
  _NodeSelectorImpl._wrap(ptr) : super._wrap(ptr);

  Element query(String selectors) => _wrap(_ptr.query(_unwrap(selectors)));

  NodeList $dom_querySelectorAll(String selectors) => _wrap(_ptr.$dom_querySelectorAll(_unwrap(selectors)));
}

class _NotationImpl extends _NodeImpl implements Notation {
  _NotationImpl._wrap(ptr) : super._wrap(ptr);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _NotificationImpl extends _EventTargetImpl implements Notification {
  _NotificationImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get dir() => _wrap(_ptr.dir);

  void set dir(String value) { _ptr.dir = _unwrap(value); }

  String get replaceId() => _wrap(_ptr.replaceId);

  void set replaceId(String value) { _ptr.replaceId = _unwrap(value); }

  String get tag() => _wrap(_ptr.tag);

  void set tag(String value) { _ptr.tag = _unwrap(value); }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void cancel() => _ptr.cancel();

  void close() => _ptr.close();

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void show() => _ptr.show();
}

class _NotificationCenterImpl extends _DOMTypeBase implements NotificationCenter {
  _NotificationCenterImpl._wrap(ptr) : super._wrap(ptr);

  int checkPermission() => _wrap(_ptr.checkPermission());

  Notification createHTMLNotification(String url) => _wrap(_ptr.createHTMLNotification(_unwrap(url)));

  Notification createNotification(String iconUrl, String title, String body) => _wrap(_ptr.createNotification(_unwrap(iconUrl), _unwrap(title), _unwrap(body)));

  void requestPermission(VoidCallback callback) => _ptr.requestPermission(_unwrap(callback));
}

class _OESStandardDerivativesImpl extends _DOMTypeBase implements OESStandardDerivatives {
  _OESStandardDerivativesImpl._wrap(ptr) : super._wrap(ptr);
}

class _OESTextureFloatImpl extends _DOMTypeBase implements OESTextureFloat {
  _OESTextureFloatImpl._wrap(ptr) : super._wrap(ptr);
}

class _OESVertexArrayObjectImpl extends _DOMTypeBase implements OESVertexArrayObject {
  _OESVertexArrayObjectImpl._wrap(ptr) : super._wrap(ptr);

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) => _ptr.bindVertexArrayOES(_unwrap(arrayObject));

  WebGLVertexArrayObjectOES createVertexArrayOES() => _wrap(_ptr.createVertexArrayOES());

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) => _ptr.deleteVertexArrayOES(_unwrap(arrayObject));

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) => _wrap(_ptr.isVertexArrayOES(_unwrap(arrayObject)));
}

class _OListElementImpl extends _ElementImpl implements OListElement {
  _OListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }

  bool get reversed() => _wrap(_ptr.reversed);

  void set reversed(bool value) { _ptr.reversed = _unwrap(value); }

  int get start() => _wrap(_ptr.start);

  void set start(int value) { _ptr.start = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _ObjectElementImpl extends _ElementImpl implements ObjectElement {
  _ObjectElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get archive() => _wrap(_ptr.archive);

  void set archive(String value) { _ptr.archive = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  String get code() => _wrap(_ptr.code);

  void set code(String value) { _ptr.code = _unwrap(value); }

  String get codeBase() => _wrap(_ptr.codeBase);

  void set codeBase(String value) { _ptr.codeBase = _unwrap(value); }

  String get codeType() => _wrap(_ptr.codeType);

  void set codeType(String value) { _ptr.codeType = _unwrap(value); }

  Document get contentDocument() => _wrap(_ptr.contentDocument);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  bool get declare() => _wrap(_ptr.declare);

  void set declare(bool value) { _ptr.declare = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get standby() => _wrap(_ptr.standby);

  void set standby(String value) { _ptr.standby = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));
}

class _OfflineAudioCompletionEventImpl extends _EventImpl implements OfflineAudioCompletionEvent {
  _OfflineAudioCompletionEventImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get renderedBuffer() => _wrap(_ptr.renderedBuffer);
}

class _OperationNotAllowedExceptionImpl extends _DOMTypeBase implements OperationNotAllowedException {
  _OperationNotAllowedExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _OptGroupElementImpl extends _ElementImpl implements OptGroupElement {
  _OptGroupElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }
}

class _OptionElementImpl extends _ElementImpl implements OptionElement {
  _OptionElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get defaultSelected() => _wrap(_ptr.defaultSelected);

  void set defaultSelected(bool value) { _ptr.defaultSelected = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  int get index() => _wrap(_ptr.index);

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }

  bool get selected() => _wrap(_ptr.selected);

  void set selected(bool value) { _ptr.selected = _unwrap(value); }

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _OscillatorImpl extends _AudioSourceNodeImpl implements Oscillator {
  _OscillatorImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get detune() => _wrap(_ptr.detune);

  AudioParam get frequency() => _wrap(_ptr.frequency);

  int get playbackState() => _wrap(_ptr.playbackState);

  int get type() => _wrap(_ptr.type);

  void set type(int value) { _ptr.type = _unwrap(value); }

  void noteOff(num when) => _ptr.noteOff(_unwrap(when));

  void noteOn(num when) => _ptr.noteOn(_unwrap(when));

  void setWaveTable(WaveTable waveTable) => _ptr.setWaveTable(_unwrap(waveTable));
}

class _OutputElementImpl extends _ElementImpl implements OutputElement {
  _OutputElementImpl._wrap(ptr) : super._wrap(ptr);

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  DOMSettableTokenList get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(DOMSettableTokenList value) { _ptr.htmlFor = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));
}

class _OverflowEventImpl extends _EventImpl implements OverflowEvent {
  _OverflowEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get horizontalOverflow() => _wrap(_ptr.horizontalOverflow);

  int get orient() => _wrap(_ptr.orient);

  bool get verticalOverflow() => _wrap(_ptr.verticalOverflow);
}

class _PageTransitionEventImpl extends _EventImpl implements PageTransitionEvent {
  _PageTransitionEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get persisted() => _wrap(_ptr.persisted);
}

class _ParagraphElementImpl extends _ElementImpl implements ParagraphElement {
  _ParagraphElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _ParamElementImpl extends _ElementImpl implements ParamElement {
  _ParamElementImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  String get valueType() => _wrap(_ptr.valueType);

  void set valueType(String value) { _ptr.valueType = _unwrap(value); }
}

class _PeerConnection00Impl extends _EventTargetImpl implements PeerConnection00 {
  _PeerConnection00Impl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get iceState() => _wrap(_ptr.iceState);

  SessionDescription get localDescription() => _wrap(_ptr.localDescription);

  MediaStreamList get localStreams() => _wrap(_ptr.localStreams);

  int get readyState() => _wrap(_ptr.readyState);

  SessionDescription get remoteDescription() => _wrap(_ptr.remoteDescription);

  MediaStreamList get remoteStreams() => _wrap(_ptr.remoteStreams);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void addStream(MediaStream stream, [Map mediaStreamHints = null]) => _ptr.addStream(_unwrap(stream), _unwrap(mediaStreamHints));

  void close() => _ptr.close();

  SessionDescription createAnswer(String offer, [Map mediaHints = null]) => _wrap(_ptr.createAnswer(_unwrap(offer), _unwrap(mediaHints)));

  SessionDescription createOffer([Map mediaHints = null]) => _wrap(_ptr.createOffer(_unwrap(mediaHints)));

  bool $dom_dispatchEvent(Event event) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(event)));

  void processIceMessage(IceCandidate candidate) => _ptr.processIceMessage(_unwrap(candidate));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void removeStream(MediaStream stream) => _ptr.removeStream(_unwrap(stream));

  void setLocalDescription(int action, SessionDescription desc) => _ptr.setLocalDescription(_unwrap(action), _unwrap(desc));

  void setRemoteDescription(int action, SessionDescription desc) => _ptr.setRemoteDescription(_unwrap(action), _unwrap(desc));

  void startIce([Map iceOptions = null]) => _ptr.startIce(_unwrap(iceOptions));
}

class _PerformanceImpl extends _DOMTypeBase implements Performance {
  _PerformanceImpl._wrap(ptr) : super._wrap(ptr);

  MemoryInfo get memory() => _wrap(_ptr.memory);

  PerformanceNavigation get navigation() => _wrap(_ptr.navigation);

  PerformanceTiming get timing() => _wrap(_ptr.timing);

  num webkitNow() => _wrap(_ptr.webkitNow());
}

class _PerformanceNavigationImpl extends _DOMTypeBase implements PerformanceNavigation {
  _PerformanceNavigationImpl._wrap(ptr) : super._wrap(ptr);

  int get redirectCount() => _wrap(_ptr.redirectCount);

  int get type() => _wrap(_ptr.type);
}

class _PerformanceTimingImpl extends _DOMTypeBase implements PerformanceTiming {
  _PerformanceTimingImpl._wrap(ptr) : super._wrap(ptr);

  int get connectEnd() => _wrap(_ptr.connectEnd);

  int get connectStart() => _wrap(_ptr.connectStart);

  int get domComplete() => _wrap(_ptr.domComplete);

  int get domContentLoadedEventEnd() => _wrap(_ptr.domContentLoadedEventEnd);

  int get domContentLoadedEventStart() => _wrap(_ptr.domContentLoadedEventStart);

  int get domInteractive() => _wrap(_ptr.domInteractive);

  int get domLoading() => _wrap(_ptr.domLoading);

  int get domainLookupEnd() => _wrap(_ptr.domainLookupEnd);

  int get domainLookupStart() => _wrap(_ptr.domainLookupStart);

  int get fetchStart() => _wrap(_ptr.fetchStart);

  int get loadEventEnd() => _wrap(_ptr.loadEventEnd);

  int get loadEventStart() => _wrap(_ptr.loadEventStart);

  int get navigationStart() => _wrap(_ptr.navigationStart);

  int get redirectEnd() => _wrap(_ptr.redirectEnd);

  int get redirectStart() => _wrap(_ptr.redirectStart);

  int get requestStart() => _wrap(_ptr.requestStart);

  int get responseEnd() => _wrap(_ptr.responseEnd);

  int get responseStart() => _wrap(_ptr.responseStart);

  int get secureConnectionStart() => _wrap(_ptr.secureConnectionStart);

  int get unloadEventEnd() => _wrap(_ptr.unloadEventEnd);

  int get unloadEventStart() => _wrap(_ptr.unloadEventStart);
}

class _PointImpl extends _DOMTypeBase implements Point {
  _PointImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _PointerLockImpl extends _DOMTypeBase implements PointerLock {
  _PointerLockImpl._wrap(ptr) : super._wrap(ptr);

  bool get isLocked() => _wrap(_ptr.isLocked);

  void lock(Element target, [VoidCallback successCallback = null, VoidCallback failureCallback = null]) => _ptr.lock(_unwrap(target), _unwrap(successCallback), _unwrap(failureCallback));

  void unlock() => _ptr.unlock();
}

class _PopStateEventImpl extends _EventImpl implements PopStateEvent {
  _PopStateEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get state() => _wrap(_ptr.state);
}

class _PositionErrorImpl extends _DOMTypeBase implements PositionError {
  _PositionErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _PreElementImpl extends _ElementImpl implements PreElement {
  _PreElementImpl._wrap(ptr) : super._wrap(ptr);

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  bool get wrap() => _wrap(_ptr.wrap);

  void set wrap(bool value) { _ptr.wrap = _unwrap(value); }
}

class _ProcessingInstructionImpl extends _NodeImpl implements ProcessingInstruction {
  _ProcessingInstructionImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  String get target() => _wrap(_ptr.target);
}

class _ProgressElementImpl extends _ElementImpl implements ProgressElement {
  _ProgressElementImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get labels() => _wrap(_ptr.labels);

  num get max() => _wrap(_ptr.max);

  void set max(num value) { _ptr.max = _unwrap(value); }

  num get position() => _wrap(_ptr.position);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _ProgressEventImpl extends _EventImpl implements ProgressEvent {
  _ProgressEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get lengthComputable() => _wrap(_ptr.lengthComputable);

  int get loaded() => _wrap(_ptr.loaded);

  int get total() => _wrap(_ptr.total);
}

class _QuoteElementImpl extends _ElementImpl implements QuoteElement {
  _QuoteElementImpl._wrap(ptr) : super._wrap(ptr);

  String get cite() => _wrap(_ptr.cite);

  void set cite(String value) { _ptr.cite = _unwrap(value); }
}

class _RGBColorImpl extends _DOMTypeBase implements RGBColor {
  _RGBColorImpl._wrap(ptr) : super._wrap(ptr);

  CSSPrimitiveValue get blue() => _wrap(_ptr.blue);

  CSSPrimitiveValue get green() => _wrap(_ptr.green);

  CSSPrimitiveValue get red() => _wrap(_ptr.red);
}

class _RadioNodeListImpl extends _NodeListImpl implements RadioNodeList {
  _RadioNodeListImpl._wrap(ptr) : super._wrap(ptr);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _RangeImpl extends _DOMTypeBase implements Range {
  _RangeImpl._wrap(ptr) : super._wrap(ptr);

  bool get collapsed() => _wrap(_ptr.collapsed);

  Node get commonAncestorContainer() => _wrap(_ptr.commonAncestorContainer);

  Node get endContainer() => _wrap(_ptr.endContainer);

  int get endOffset() => _wrap(_ptr.endOffset);

  Node get startContainer() => _wrap(_ptr.startContainer);

  int get startOffset() => _wrap(_ptr.startOffset);

  DocumentFragment cloneContents() => _wrap(_ptr.cloneContents());

  Range cloneRange() => _wrap(_ptr.cloneRange());

  void collapse(bool toStart) => _ptr.collapse(_unwrap(toStart));

  int compareNode(Node refNode) => _wrap(_ptr.compareNode(_unwrap(refNode)));

  int comparePoint(Node refNode, int offset) => _wrap(_ptr.comparePoint(_unwrap(refNode), _unwrap(offset)));

  DocumentFragment createContextualFragment(String html) => _wrap(_ptr.createContextualFragment(_unwrap(html)));

  void deleteContents() => _ptr.deleteContents();

  void detach() => _ptr.detach();

  void expand(String unit) => _ptr.expand(_unwrap(unit));

  DocumentFragment extractContents() => _wrap(_ptr.extractContents());

  ClientRect getBoundingClientRect() => _wrap(_ptr.getBoundingClientRect());

  ClientRectList getClientRects() => _wrap(_ptr.getClientRects());

  void insertNode(Node newNode) => _ptr.insertNode(_unwrap(newNode));

  bool intersectsNode(Node refNode) => _wrap(_ptr.intersectsNode(_unwrap(refNode)));

  bool isPointInRange(Node refNode, int offset) => _wrap(_ptr.isPointInRange(_unwrap(refNode), _unwrap(offset)));

  void selectNode(Node refNode) => _ptr.selectNode(_unwrap(refNode));

  void selectNodeContents(Node refNode) => _ptr.selectNodeContents(_unwrap(refNode));

  void setEnd(Node refNode, int offset) => _ptr.setEnd(_unwrap(refNode), _unwrap(offset));

  void setEndAfter(Node refNode) => _ptr.setEndAfter(_unwrap(refNode));

  void setEndBefore(Node refNode) => _ptr.setEndBefore(_unwrap(refNode));

  void setStart(Node refNode, int offset) => _ptr.setStart(_unwrap(refNode), _unwrap(offset));

  void setStartAfter(Node refNode) => _ptr.setStartAfter(_unwrap(refNode));

  void setStartBefore(Node refNode) => _ptr.setStartBefore(_unwrap(refNode));

  void surroundContents(Node newParent) => _ptr.surroundContents(_unwrap(newParent));

  String toString() => _wrap(_ptr.toString());
}

class _RangeExceptionImpl extends _DOMTypeBase implements RangeException {
  _RangeExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _RealtimeAnalyserNodeImpl extends _AudioNodeImpl implements RealtimeAnalyserNode {
  _RealtimeAnalyserNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get fftSize() => _wrap(_ptr.fftSize);

  void set fftSize(int value) { _ptr.fftSize = _unwrap(value); }

  int get frequencyBinCount() => _wrap(_ptr.frequencyBinCount);

  num get maxDecibels() => _wrap(_ptr.maxDecibels);

  void set maxDecibels(num value) { _ptr.maxDecibels = _unwrap(value); }

  num get minDecibels() => _wrap(_ptr.minDecibels);

  void set minDecibels(num value) { _ptr.minDecibels = _unwrap(value); }

  num get smoothingTimeConstant() => _wrap(_ptr.smoothingTimeConstant);

  void set smoothingTimeConstant(num value) { _ptr.smoothingTimeConstant = _unwrap(value); }

  void getByteFrequencyData(Uint8Array array) => _ptr.getByteFrequencyData(_unwrap(array));

  void getByteTimeDomainData(Uint8Array array) => _ptr.getByteTimeDomainData(_unwrap(array));

  void getFloatFrequencyData(Float32Array array) => _ptr.getFloatFrequencyData(_unwrap(array));
}

class _RectImpl extends _DOMTypeBase implements Rect {
  _RectImpl._wrap(ptr) : super._wrap(ptr);

  CSSPrimitiveValue get bottom() => _wrap(_ptr.bottom);

  CSSPrimitiveValue get left() => _wrap(_ptr.left);

  CSSPrimitiveValue get right() => _wrap(_ptr.right);

  CSSPrimitiveValue get top() => _wrap(_ptr.top);
}

class _SQLErrorImpl extends _DOMTypeBase implements SQLError {
  _SQLErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SQLExceptionImpl extends _DOMTypeBase implements SQLException {
  _SQLExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SQLResultSetImpl extends _DOMTypeBase implements SQLResultSet {
  _SQLResultSetImpl._wrap(ptr) : super._wrap(ptr);

  int get insertId() => _wrap(_ptr.insertId);

  SQLResultSetRowList get rows() => _wrap(_ptr.rows);

  int get rowsAffected() => _wrap(_ptr.rowsAffected);
}

class _SQLResultSetRowListImpl extends _DOMTypeBase implements SQLResultSetRowList {
  _SQLResultSetRowListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Object item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _SQLTransactionImpl extends _DOMTypeBase implements SQLTransaction {
  _SQLTransactionImpl._wrap(ptr) : super._wrap(ptr);
}

class _SQLTransactionSyncImpl extends _DOMTypeBase implements SQLTransactionSync {
  _SQLTransactionSyncImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAElementImpl extends _SVGElementImpl implements SVGAElement {
  _SVGAElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get target() => _wrap(_ptr.target);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGAltGlyphDefElementImpl extends _SVGElementImpl implements SVGAltGlyphDefElement {
  _SVGAltGlyphDefElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAltGlyphElementImpl extends _SVGTextPositioningElementImpl implements SVGAltGlyphElement {
  _SVGAltGlyphElementImpl._wrap(ptr) : super._wrap(ptr);

  String get format() => _wrap(_ptr.format);

  void set format(String value) { _ptr.format = _unwrap(value); }

  String get glyphRef() => _wrap(_ptr.glyphRef);

  void set glyphRef(String value) { _ptr.glyphRef = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGAltGlyphItemElementImpl extends _SVGElementImpl implements SVGAltGlyphItemElement {
  _SVGAltGlyphItemElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAngleImpl extends _DOMTypeBase implements SVGAngle {
  _SVGAngleImpl._wrap(ptr) : super._wrap(ptr);

  int get unitType() => _wrap(_ptr.unitType);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  String get valueAsString() => _wrap(_ptr.valueAsString);

  void set valueAsString(String value) { _ptr.valueAsString = _unwrap(value); }

  num get valueInSpecifiedUnits() => _wrap(_ptr.valueInSpecifiedUnits);

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = _unwrap(value); }

  void convertToSpecifiedUnits(int unitType) => _ptr.convertToSpecifiedUnits(_unwrap(unitType));

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) => _ptr.newValueSpecifiedUnits(_unwrap(unitType), _unwrap(valueInSpecifiedUnits));
}

class _SVGAnimateColorElementImpl extends _SVGAnimationElementImpl implements SVGAnimateColorElement {
  _SVGAnimateColorElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateElementImpl extends _SVGAnimationElementImpl implements SVGAnimateElement {
  _SVGAnimateElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateMotionElementImpl extends _SVGAnimationElementImpl implements SVGAnimateMotionElement {
  _SVGAnimateMotionElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateTransformElementImpl extends _SVGAnimationElementImpl implements SVGAnimateTransformElement {
  _SVGAnimateTransformElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimatedAngleImpl extends _DOMTypeBase implements SVGAnimatedAngle {
  _SVGAnimatedAngleImpl._wrap(ptr) : super._wrap(ptr);

  SVGAngle get animVal() => _wrap(_ptr.animVal);

  SVGAngle get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedBooleanImpl extends _DOMTypeBase implements SVGAnimatedBoolean {
  _SVGAnimatedBooleanImpl._wrap(ptr) : super._wrap(ptr);

  bool get animVal() => _wrap(_ptr.animVal);

  bool get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(bool value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedEnumerationImpl extends _DOMTypeBase implements SVGAnimatedEnumeration {
  _SVGAnimatedEnumerationImpl._wrap(ptr) : super._wrap(ptr);

  int get animVal() => _wrap(_ptr.animVal);

  int get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(int value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedIntegerImpl extends _DOMTypeBase implements SVGAnimatedInteger {
  _SVGAnimatedIntegerImpl._wrap(ptr) : super._wrap(ptr);

  int get animVal() => _wrap(_ptr.animVal);

  int get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(int value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedLengthImpl extends _DOMTypeBase implements SVGAnimatedLength {
  _SVGAnimatedLengthImpl._wrap(ptr) : super._wrap(ptr);

  SVGLength get animVal() => _wrap(_ptr.animVal);

  SVGLength get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedLengthListImpl extends _DOMTypeBase implements SVGAnimatedLengthList {
  _SVGAnimatedLengthListImpl._wrap(ptr) : super._wrap(ptr);

  SVGLengthList get animVal() => _wrap(_ptr.animVal);

  SVGLengthList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedNumberImpl extends _DOMTypeBase implements SVGAnimatedNumber {
  _SVGAnimatedNumberImpl._wrap(ptr) : super._wrap(ptr);

  num get animVal() => _wrap(_ptr.animVal);

  num get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(num value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedNumberListImpl extends _DOMTypeBase implements SVGAnimatedNumberList {
  _SVGAnimatedNumberListImpl._wrap(ptr) : super._wrap(ptr);

  SVGNumberList get animVal() => _wrap(_ptr.animVal);

  SVGNumberList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedPreserveAspectRatioImpl extends _DOMTypeBase implements SVGAnimatedPreserveAspectRatio {
  _SVGAnimatedPreserveAspectRatioImpl._wrap(ptr) : super._wrap(ptr);

  SVGPreserveAspectRatio get animVal() => _wrap(_ptr.animVal);

  SVGPreserveAspectRatio get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedRectImpl extends _DOMTypeBase implements SVGAnimatedRect {
  _SVGAnimatedRectImpl._wrap(ptr) : super._wrap(ptr);

  SVGRect get animVal() => _wrap(_ptr.animVal);

  SVGRect get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedStringImpl extends _DOMTypeBase implements SVGAnimatedString {
  _SVGAnimatedStringImpl._wrap(ptr) : super._wrap(ptr);

  String get animVal() => _wrap(_ptr.animVal);

  String get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(String value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedTransformListImpl extends _DOMTypeBase implements SVGAnimatedTransformList {
  _SVGAnimatedTransformListImpl._wrap(ptr) : super._wrap(ptr);

  SVGTransformList get animVal() => _wrap(_ptr.animVal);

  SVGTransformList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimationElementImpl extends _SVGElementImpl implements SVGAnimationElement {
  _SVGAnimationElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGElement get targetElement() => _wrap(_ptr.targetElement);

  num getCurrentTime() => _wrap(_ptr.getCurrentTime());

  num getSimpleDuration() => _wrap(_ptr.getSimpleDuration());

  num getStartTime() => _wrap(_ptr.getStartTime());

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From ElementTimeControl

  void beginElement() => _ptr.beginElement();

  void beginElementAt(num offset) => _ptr.beginElementAt(_unwrap(offset));

  void endElement() => _ptr.endElement();

  void endElementAt(num offset) => _ptr.endElementAt(_unwrap(offset));
}

class _SVGCircleElementImpl extends _SVGElementImpl implements SVGCircleElement {
  _SVGCircleElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get r() => _wrap(_ptr.r);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGClipPathElementImpl extends _SVGElementImpl implements SVGClipPathElement {
  _SVGClipPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get clipPathUnits() => _wrap(_ptr.clipPathUnits);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGColorImpl extends _CSSValueImpl implements SVGColor {
  _SVGColorImpl._wrap(ptr) : super._wrap(ptr);

  int get colorType() => _wrap(_ptr.colorType);

  RGBColor get rgbColor() => _wrap(_ptr.rgbColor);

  void setColor(int colorType, String rgbColor, String iccColor) => _ptr.setColor(_unwrap(colorType), _unwrap(rgbColor), _unwrap(iccColor));

  void setRGBColor(String rgbColor) => _ptr.setRGBColor(_unwrap(rgbColor));

  void setRGBColorICCColor(String rgbColor, String iccColor) => _ptr.setRGBColorICCColor(_unwrap(rgbColor), _unwrap(iccColor));
}

class _SVGComponentTransferFunctionElementImpl extends _SVGElementImpl implements SVGComponentTransferFunctionElement {
  _SVGComponentTransferFunctionElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get amplitude() => _wrap(_ptr.amplitude);

  SVGAnimatedNumber get exponent() => _wrap(_ptr.exponent);

  SVGAnimatedNumber get intercept() => _wrap(_ptr.intercept);

  SVGAnimatedNumber get offset() => _wrap(_ptr.offset);

  SVGAnimatedNumber get slope() => _wrap(_ptr.slope);

  SVGAnimatedNumberList get tableValues() => _wrap(_ptr.tableValues);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);
}

class _SVGCursorElementImpl extends _SVGElementImpl implements SVGCursorElement {
  _SVGCursorElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGDefsElementImpl extends _SVGElementImpl implements SVGDefsElement {
  _SVGDefsElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGDescElementImpl extends _SVGElementImpl implements SVGDescElement {
  _SVGDescElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGDocumentImpl extends _DocumentImpl implements SVGDocument {
  _SVGDocumentImpl._wrap(ptr) : super._wrap(ptr);

  SVGSVGElement get rootElement() => _wrap(_ptr.rootElement);

  Event $dom_createEvent(String eventType) => _wrap(_ptr.$dom_createEvent(_unwrap(eventType)));
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AttributeClassSet extends _CssClassSet {
  _AttributeClassSet(element) : super(element);

  String $dom_className() => _element.attributes['class'];

  void _write(Set s) {
    _element.attributes['class'] = _formatSet(s);
  }
}

class _SVGElementImpl extends _ElementImpl implements SVGElement {
  Set<String> get classes() {
    if (_cssClassSet === null) {
      _cssClassSet = new _AttributeClassSet(_ptr);
    }
    return _cssClassSet;
  }

  ElementList get elements() => new FilteredElementList(this);

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  String get outerHTML() {
    final container = new Element.tag("div");
    final SVGElement cloned = this.clone(true);
    container.elements.add(cloned);
    return container.innerHTML;
  }

  String get innerHTML() {
    final container = new Element.tag("div");
    final SVGElement cloned = this.clone(true);
    container.elements.addAll(cloned.elements);
    return container.innerHTML;
  }

  void set innerHTML(String svg) {
    final container = new Element.tag("div");
    // Wrap the SVG string in <svg> so that SVGElements are created, rather than
    // HTMLElements.
    container.innerHTML = '<svg version="1.1">$svg</svg>';
    this.elements = container.elements.first.elements;
  }

  _SVGElementImpl._wrap(ptr) : super._wrap(ptr);

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  SVGSVGElement get ownerSVGElement() => _wrap(_ptr.ownerSVGElement);

  SVGElement get viewportElement() => _wrap(_ptr.viewportElement);

  String get xmlbase() => _wrap(_ptr.xmlbase);

  void set xmlbase(String value) { _ptr.xmlbase = _unwrap(value); }

}

class _SVGElementInstanceImpl extends _DOMTypeBase implements SVGElementInstance {
  _SVGElementInstanceImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  SVGElementInstanceList get childNodes() => _wrap(_ptr.childNodes);

  SVGElement get correspondingElement() => _wrap(_ptr.correspondingElement);

  SVGUseElement get correspondingUseElement() => _wrap(_ptr.correspondingUseElement);

  SVGElementInstance get firstChild() => _wrap(_ptr.firstChild);

  SVGElementInstance get lastChild() => _wrap(_ptr.lastChild);

  SVGElementInstance get nextSibling() => _wrap(_ptr.nextSibling);

  SVGElementInstance get parentNode() => _wrap(_ptr.parentNode);

  SVGElementInstance get previousSibling() => _wrap(_ptr.previousSibling);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool dispatchEvent(Event event) => _wrap(_ptr.dispatchEvent(_unwrap(event)));

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _SVGElementInstanceListImpl extends _DOMTypeBase implements SVGElementInstanceList {
  _SVGElementInstanceListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SVGElementInstance item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _SVGEllipseElementImpl extends _SVGElementImpl implements SVGEllipseElement {
  _SVGEllipseElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get rx() => _wrap(_ptr.rx);

  SVGAnimatedLength get ry() => _wrap(_ptr.ry);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGExceptionImpl extends _DOMTypeBase implements SVGException {
  _SVGExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _SVGExternalResourcesRequiredImpl extends _DOMTypeBase implements SVGExternalResourcesRequired {
  _SVGExternalResourcesRequiredImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGFEBlendElementImpl extends _SVGElementImpl implements SVGFEBlendElement {
  _SVGFEBlendElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedEnumeration get mode() => _wrap(_ptr.mode);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEColorMatrixElementImpl extends _SVGElementImpl implements SVGFEColorMatrixElement {
  _SVGFEColorMatrixElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);

  SVGAnimatedNumberList get values() => _wrap(_ptr.values);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEComponentTransferElementImpl extends _SVGElementImpl implements SVGFEComponentTransferElement {
  _SVGFEComponentTransferElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFECompositeElementImpl extends _SVGElementImpl implements SVGFECompositeElement {
  _SVGFECompositeElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedNumber get k1() => _wrap(_ptr.k1);

  SVGAnimatedNumber get k2() => _wrap(_ptr.k2);

  SVGAnimatedNumber get k3() => _wrap(_ptr.k3);

  SVGAnimatedNumber get k4() => _wrap(_ptr.k4);

  SVGAnimatedEnumeration get operator() => _wrap(_ptr.operator);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEConvolveMatrixElementImpl extends _SVGElementImpl implements SVGFEConvolveMatrixElement {
  _SVGFEConvolveMatrixElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get bias() => _wrap(_ptr.bias);

  SVGAnimatedNumber get divisor() => _wrap(_ptr.divisor);

  SVGAnimatedEnumeration get edgeMode() => _wrap(_ptr.edgeMode);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumberList get kernelMatrix() => _wrap(_ptr.kernelMatrix);

  SVGAnimatedNumber get kernelUnitLengthX() => _wrap(_ptr.kernelUnitLengthX);

  SVGAnimatedNumber get kernelUnitLengthY() => _wrap(_ptr.kernelUnitLengthY);

  SVGAnimatedInteger get orderX() => _wrap(_ptr.orderX);

  SVGAnimatedInteger get orderY() => _wrap(_ptr.orderY);

  SVGAnimatedBoolean get preserveAlpha() => _wrap(_ptr.preserveAlpha);

  SVGAnimatedInteger get targetX() => _wrap(_ptr.targetX);

  SVGAnimatedInteger get targetY() => _wrap(_ptr.targetY);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEDiffuseLightingElementImpl extends _SVGElementImpl implements SVGFEDiffuseLightingElement {
  _SVGFEDiffuseLightingElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get diffuseConstant() => _wrap(_ptr.diffuseConstant);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get kernelUnitLengthX() => _wrap(_ptr.kernelUnitLengthX);

  SVGAnimatedNumber get kernelUnitLengthY() => _wrap(_ptr.kernelUnitLengthY);

  SVGAnimatedNumber get surfaceScale() => _wrap(_ptr.surfaceScale);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEDisplacementMapElementImpl extends _SVGElementImpl implements SVGFEDisplacementMapElement {
  _SVGFEDisplacementMapElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedNumber get scale() => _wrap(_ptr.scale);

  SVGAnimatedEnumeration get xChannelSelector() => _wrap(_ptr.xChannelSelector);

  SVGAnimatedEnumeration get yChannelSelector() => _wrap(_ptr.yChannelSelector);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEDistantLightElementImpl extends _SVGElementImpl implements SVGFEDistantLightElement {
  _SVGFEDistantLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get azimuth() => _wrap(_ptr.azimuth);

  SVGAnimatedNumber get elevation() => _wrap(_ptr.elevation);
}

class _SVGFEDropShadowElementImpl extends _SVGElementImpl implements SVGFEDropShadowElement {
  _SVGFEDropShadowElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get dx() => _wrap(_ptr.dx);

  SVGAnimatedNumber get dy() => _wrap(_ptr.dy);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get stdDeviationX() => _wrap(_ptr.stdDeviationX);

  SVGAnimatedNumber get stdDeviationY() => _wrap(_ptr.stdDeviationY);

  void setStdDeviation(num stdDeviationX, num stdDeviationY) => _ptr.setStdDeviation(_unwrap(stdDeviationX), _unwrap(stdDeviationY));

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEFloodElementImpl extends _SVGElementImpl implements SVGFEFloodElement {
  _SVGFEFloodElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEFuncAElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncAElement {
  _SVGFEFuncAElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncBElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncBElement {
  _SVGFEFuncBElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncGElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncGElement {
  _SVGFEFuncGElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncRElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncRElement {
  _SVGFEFuncRElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEGaussianBlurElementImpl extends _SVGElementImpl implements SVGFEGaussianBlurElement {
  _SVGFEGaussianBlurElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get stdDeviationX() => _wrap(_ptr.stdDeviationX);

  SVGAnimatedNumber get stdDeviationY() => _wrap(_ptr.stdDeviationY);

  void setStdDeviation(num stdDeviationX, num stdDeviationY) => _ptr.setStdDeviation(_unwrap(stdDeviationX), _unwrap(stdDeviationY));

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEImageElementImpl extends _SVGElementImpl implements SVGFEImageElement {
  _SVGFEImageElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEMergeElementImpl extends _SVGElementImpl implements SVGFEMergeElement {
  _SVGFEMergeElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEMergeNodeElementImpl extends _SVGElementImpl implements SVGFEMergeNodeElement {
  _SVGFEMergeNodeElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);
}

class _SVGFEMorphologyElementImpl extends _SVGElementImpl implements SVGFEMorphologyElement {
  _SVGFEMorphologyElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedEnumeration get operator() => _wrap(_ptr.operator);

  SVGAnimatedNumber get radiusX() => _wrap(_ptr.radiusX);

  SVGAnimatedNumber get radiusY() => _wrap(_ptr.radiusY);

  void setRadius(num radiusX, num radiusY) => _ptr.setRadius(_unwrap(radiusX), _unwrap(radiusY));

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEOffsetElementImpl extends _SVGElementImpl implements SVGFEOffsetElement {
  _SVGFEOffsetElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get dx() => _wrap(_ptr.dx);

  SVGAnimatedNumber get dy() => _wrap(_ptr.dy);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFEPointLightElementImpl extends _SVGElementImpl implements SVGFEPointLightElement {
  _SVGFEPointLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get x() => _wrap(_ptr.x);

  SVGAnimatedNumber get y() => _wrap(_ptr.y);

  SVGAnimatedNumber get z() => _wrap(_ptr.z);
}

class _SVGFESpecularLightingElementImpl extends _SVGElementImpl implements SVGFESpecularLightingElement {
  _SVGFESpecularLightingElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get specularConstant() => _wrap(_ptr.specularConstant);

  SVGAnimatedNumber get specularExponent() => _wrap(_ptr.specularExponent);

  SVGAnimatedNumber get surfaceScale() => _wrap(_ptr.surfaceScale);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFESpotLightElementImpl extends _SVGElementImpl implements SVGFESpotLightElement {
  _SVGFESpotLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get limitingConeAngle() => _wrap(_ptr.limitingConeAngle);

  SVGAnimatedNumber get pointsAtX() => _wrap(_ptr.pointsAtX);

  SVGAnimatedNumber get pointsAtY() => _wrap(_ptr.pointsAtY);

  SVGAnimatedNumber get pointsAtZ() => _wrap(_ptr.pointsAtZ);

  SVGAnimatedNumber get specularExponent() => _wrap(_ptr.specularExponent);

  SVGAnimatedNumber get x() => _wrap(_ptr.x);

  SVGAnimatedNumber get y() => _wrap(_ptr.y);

  SVGAnimatedNumber get z() => _wrap(_ptr.z);
}

class _SVGFETileElementImpl extends _SVGElementImpl implements SVGFETileElement {
  _SVGFETileElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFETurbulenceElementImpl extends _SVGElementImpl implements SVGFETurbulenceElement {
  _SVGFETurbulenceElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get baseFrequencyX() => _wrap(_ptr.baseFrequencyX);

  SVGAnimatedNumber get baseFrequencyY() => _wrap(_ptr.baseFrequencyY);

  SVGAnimatedInteger get numOctaves() => _wrap(_ptr.numOctaves);

  SVGAnimatedNumber get seed() => _wrap(_ptr.seed);

  SVGAnimatedEnumeration get stitchTiles() => _wrap(_ptr.stitchTiles);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFilterElementImpl extends _SVGElementImpl implements SVGFilterElement {
  _SVGFilterElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedInteger get filterResX() => _wrap(_ptr.filterResX);

  SVGAnimatedInteger get filterResY() => _wrap(_ptr.filterResY);

  SVGAnimatedEnumeration get filterUnits() => _wrap(_ptr.filterUnits);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get primitiveUnits() => _wrap(_ptr.primitiveUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  void setFilterRes(int filterResX, int filterResY) => _ptr.setFilterRes(_unwrap(filterResX), _unwrap(filterResY));

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGFilterPrimitiveStandardAttributesImpl extends _SVGStylableImpl implements SVGFilterPrimitiveStandardAttributes {
  _SVGFilterPrimitiveStandardAttributesImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);
}

class _SVGFitToViewBoxImpl extends _DOMTypeBase implements SVGFitToViewBox {
  _SVGFitToViewBoxImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGFontElementImpl extends _SVGElementImpl implements SVGFontElement {
  _SVGFontElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceElementImpl extends _SVGElementImpl implements SVGFontFaceElement {
  _SVGFontFaceElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceFormatElementImpl extends _SVGElementImpl implements SVGFontFaceFormatElement {
  _SVGFontFaceFormatElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceNameElementImpl extends _SVGElementImpl implements SVGFontFaceNameElement {
  _SVGFontFaceNameElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceSrcElementImpl extends _SVGElementImpl implements SVGFontFaceSrcElement {
  _SVGFontFaceSrcElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceUriElementImpl extends _SVGElementImpl implements SVGFontFaceUriElement {
  _SVGFontFaceUriElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGForeignObjectElementImpl extends _SVGElementImpl implements SVGForeignObjectElement {
  _SVGForeignObjectElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGGElementImpl extends _SVGElementImpl implements SVGGElement {
  _SVGGElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGGlyphElementImpl extends _SVGElementImpl implements SVGGlyphElement {
  _SVGGlyphElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGGlyphRefElementImpl extends _SVGElementImpl implements SVGGlyphRefElement {
  _SVGGlyphRefElementImpl._wrap(ptr) : super._wrap(ptr);

  num get dx() => _wrap(_ptr.dx);

  void set dx(num value) { _ptr.dx = _unwrap(value); }

  num get dy() => _wrap(_ptr.dy);

  void set dy(num value) { _ptr.dy = _unwrap(value); }

  String get format() => _wrap(_ptr.format);

  void set format(String value) { _ptr.format = _unwrap(value); }

  String get glyphRef() => _wrap(_ptr.glyphRef);

  void set glyphRef(String value) { _ptr.glyphRef = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGGradientElementImpl extends _SVGElementImpl implements SVGGradientElement {
  _SVGGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedTransformList get gradientTransform() => _wrap(_ptr.gradientTransform);

  SVGAnimatedEnumeration get gradientUnits() => _wrap(_ptr.gradientUnits);

  SVGAnimatedEnumeration get spreadMethod() => _wrap(_ptr.spreadMethod);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGHKernElementImpl extends _SVGElementImpl implements SVGHKernElement {
  _SVGHKernElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGImageElementImpl extends _SVGElementImpl implements SVGImageElement {
  _SVGImageElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGLangSpaceImpl extends _DOMTypeBase implements SVGLangSpace {
  _SVGLangSpaceImpl._wrap(ptr) : super._wrap(ptr);

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }
}

class _SVGLengthImpl extends _DOMTypeBase implements SVGLength {
  _SVGLengthImpl._wrap(ptr) : super._wrap(ptr);

  int get unitType() => _wrap(_ptr.unitType);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  String get valueAsString() => _wrap(_ptr.valueAsString);

  void set valueAsString(String value) { _ptr.valueAsString = _unwrap(value); }

  num get valueInSpecifiedUnits() => _wrap(_ptr.valueInSpecifiedUnits);

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = _unwrap(value); }

  void convertToSpecifiedUnits(int unitType) => _ptr.convertToSpecifiedUnits(_unwrap(unitType));

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) => _ptr.newValueSpecifiedUnits(_unwrap(unitType), _unwrap(valueInSpecifiedUnits));
}

class _SVGLengthListImpl extends _DOMTypeBase implements SVGLengthList {
  _SVGLengthListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGLength appendItem(SVGLength item) => _wrap(_ptr.appendItem(_unwrap(item)));

  void clear() => _ptr.clear();

  SVGLength getItem(int index) => _wrap(_ptr.getItem(_unwrap(index)));

  SVGLength initialize(SVGLength item) => _wrap(_ptr.initialize(_unwrap(item)));

  SVGLength insertItemBefore(SVGLength item, int index) => _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));

  SVGLength removeItem(int index) => _wrap(_ptr.removeItem(_unwrap(index)));

  SVGLength replaceItem(SVGLength item, int index) => _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
}

class _SVGLineElementImpl extends _SVGElementImpl implements SVGLineElement {
  _SVGLineElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x1() => _wrap(_ptr.x1);

  SVGAnimatedLength get x2() => _wrap(_ptr.x2);

  SVGAnimatedLength get y1() => _wrap(_ptr.y1);

  SVGAnimatedLength get y2() => _wrap(_ptr.y2);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGLinearGradientElementImpl extends _SVGGradientElementImpl implements SVGLinearGradientElement {
  _SVGLinearGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x1() => _wrap(_ptr.x1);

  SVGAnimatedLength get x2() => _wrap(_ptr.x2);

  SVGAnimatedLength get y1() => _wrap(_ptr.y1);

  SVGAnimatedLength get y2() => _wrap(_ptr.y2);
}

class _SVGLocatableImpl extends _DOMTypeBase implements SVGLocatable {
  _SVGLocatableImpl._wrap(ptr) : super._wrap(ptr);

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGMPathElementImpl extends _SVGElementImpl implements SVGMPathElement {
  _SVGMPathElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGMarkerElementImpl extends _SVGElementImpl implements SVGMarkerElement {
  _SVGMarkerElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get markerHeight() => _wrap(_ptr.markerHeight);

  SVGAnimatedEnumeration get markerUnits() => _wrap(_ptr.markerUnits);

  SVGAnimatedLength get markerWidth() => _wrap(_ptr.markerWidth);

  SVGAnimatedAngle get orientAngle() => _wrap(_ptr.orientAngle);

  SVGAnimatedEnumeration get orientType() => _wrap(_ptr.orientType);

  SVGAnimatedLength get refX() => _wrap(_ptr.refX);

  SVGAnimatedLength get refY() => _wrap(_ptr.refY);

  void setOrientToAngle(SVGAngle angle) => _ptr.setOrientToAngle(_unwrap(angle));

  void setOrientToAuto() => _ptr.setOrientToAuto();

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGMaskElementImpl extends _SVGElementImpl implements SVGMaskElement {
  _SVGMaskElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get maskContentUnits() => _wrap(_ptr.maskContentUnits);

  SVGAnimatedEnumeration get maskUnits() => _wrap(_ptr.maskUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGMatrixImpl extends _DOMTypeBase implements SVGMatrix {
  _SVGMatrixImpl._wrap(ptr) : super._wrap(ptr);

  num get a() => _wrap(_ptr.a);

  void set a(num value) { _ptr.a = _unwrap(value); }

  num get b() => _wrap(_ptr.b);

  void set b(num value) { _ptr.b = _unwrap(value); }

  num get c() => _wrap(_ptr.c);

  void set c(num value) { _ptr.c = _unwrap(value); }

  num get d() => _wrap(_ptr.d);

  void set d(num value) { _ptr.d = _unwrap(value); }

  num get e() => _wrap(_ptr.e);

  void set e(num value) { _ptr.e = _unwrap(value); }

  num get f() => _wrap(_ptr.f);

  void set f(num value) { _ptr.f = _unwrap(value); }

  SVGMatrix flipX() => _wrap(_ptr.flipX());

  SVGMatrix flipY() => _wrap(_ptr.flipY());

  SVGMatrix inverse() => _wrap(_ptr.inverse());

  SVGMatrix multiply(SVGMatrix secondMatrix) => _wrap(_ptr.multiply(_unwrap(secondMatrix)));

  SVGMatrix rotate(num angle) => _wrap(_ptr.rotate(_unwrap(angle)));

  SVGMatrix rotateFromVector(num x, num y) => _wrap(_ptr.rotateFromVector(_unwrap(x), _unwrap(y)));

  SVGMatrix scale(num scaleFactor) => _wrap(_ptr.scale(_unwrap(scaleFactor)));

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY) => _wrap(_ptr.scaleNonUniform(_unwrap(scaleFactorX), _unwrap(scaleFactorY)));

  SVGMatrix skewX(num angle) => _wrap(_ptr.skewX(_unwrap(angle)));

  SVGMatrix skewY(num angle) => _wrap(_ptr.skewY(_unwrap(angle)));

  SVGMatrix translate(num x, num y) => _wrap(_ptr.translate(_unwrap(x), _unwrap(y)));
}

class _SVGMetadataElementImpl extends _SVGElementImpl implements SVGMetadataElement {
  _SVGMetadataElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGMissingGlyphElementImpl extends _SVGElementImpl implements SVGMissingGlyphElement {
  _SVGMissingGlyphElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGNumberImpl extends _DOMTypeBase implements SVGNumber {
  _SVGNumberImpl._wrap(ptr) : super._wrap(ptr);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _SVGNumberListImpl extends _DOMTypeBase implements SVGNumberList {
  _SVGNumberListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGNumber appendItem(SVGNumber item) => _wrap(_ptr.appendItem(_unwrap(item)));

  void clear() => _ptr.clear();

  SVGNumber getItem(int index) => _wrap(_ptr.getItem(_unwrap(index)));

  SVGNumber initialize(SVGNumber item) => _wrap(_ptr.initialize(_unwrap(item)));

  SVGNumber insertItemBefore(SVGNumber item, int index) => _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));

  SVGNumber removeItem(int index) => _wrap(_ptr.removeItem(_unwrap(index)));

  SVGNumber replaceItem(SVGNumber item, int index) => _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
}

class _SVGPaintImpl extends _SVGColorImpl implements SVGPaint {
  _SVGPaintImpl._wrap(ptr) : super._wrap(ptr);

  int get paintType() => _wrap(_ptr.paintType);

  String get uri() => _wrap(_ptr.uri);

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) => _ptr.setPaint(_unwrap(paintType), _unwrap(uri), _unwrap(rgbColor), _unwrap(iccColor));

  void setUri(String uri) => _ptr.setUri(_unwrap(uri));
}

class _SVGPathElementImpl extends _SVGElementImpl implements SVGPathElement {
  _SVGPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPathSegList get animatedNormalizedPathSegList() => _wrap(_ptr.animatedNormalizedPathSegList);

  SVGPathSegList get animatedPathSegList() => _wrap(_ptr.animatedPathSegList);

  SVGPathSegList get normalizedPathSegList() => _wrap(_ptr.normalizedPathSegList);

  SVGAnimatedNumber get pathLength() => _wrap(_ptr.pathLength);

  SVGPathSegList get pathSegList() => _wrap(_ptr.pathSegList);

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) => _wrap(_ptr.createSVGPathSegArcAbs(_unwrap(x), _unwrap(y), _unwrap(r1), _unwrap(r2), _unwrap(angle), _unwrap(largeArcFlag), _unwrap(sweepFlag)));

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) => _wrap(_ptr.createSVGPathSegArcRel(_unwrap(x), _unwrap(y), _unwrap(r1), _unwrap(r2), _unwrap(angle), _unwrap(largeArcFlag), _unwrap(sweepFlag)));

  SVGPathSegClosePath createSVGPathSegClosePath() => _wrap(_ptr.createSVGPathSegClosePath());

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) => _wrap(_ptr.createSVGPathSegCurvetoCubicAbs(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2)));

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) => _wrap(_ptr.createSVGPathSegCurvetoCubicRel(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2)));

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) => _wrap(_ptr.createSVGPathSegCurvetoCubicSmoothAbs(_unwrap(x), _unwrap(y), _unwrap(x2), _unwrap(y2)));

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) => _wrap(_ptr.createSVGPathSegCurvetoCubicSmoothRel(_unwrap(x), _unwrap(y), _unwrap(x2), _unwrap(y2)));

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) => _wrap(_ptr.createSVGPathSegCurvetoQuadraticAbs(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1)));

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) => _wrap(_ptr.createSVGPathSegCurvetoQuadraticRel(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1)));

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) => _wrap(_ptr.createSVGPathSegCurvetoQuadraticSmoothAbs(_unwrap(x), _unwrap(y)));

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) => _wrap(_ptr.createSVGPathSegCurvetoQuadraticSmoothRel(_unwrap(x), _unwrap(y)));

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y) => _wrap(_ptr.createSVGPathSegLinetoAbs(_unwrap(x), _unwrap(y)));

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x) => _wrap(_ptr.createSVGPathSegLinetoHorizontalAbs(_unwrap(x)));

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x) => _wrap(_ptr.createSVGPathSegLinetoHorizontalRel(_unwrap(x)));

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y) => _wrap(_ptr.createSVGPathSegLinetoRel(_unwrap(x), _unwrap(y)));

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y) => _wrap(_ptr.createSVGPathSegLinetoVerticalAbs(_unwrap(y)));

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y) => _wrap(_ptr.createSVGPathSegLinetoVerticalRel(_unwrap(y)));

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y) => _wrap(_ptr.createSVGPathSegMovetoAbs(_unwrap(x), _unwrap(y)));

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y) => _wrap(_ptr.createSVGPathSegMovetoRel(_unwrap(x), _unwrap(y)));

  int getPathSegAtLength(num distance) => _wrap(_ptr.getPathSegAtLength(_unwrap(distance)));

  SVGPoint getPointAtLength(num distance) => _wrap(_ptr.getPointAtLength(_unwrap(distance)));

  num getTotalLength() => _wrap(_ptr.getTotalLength());

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGPathSegImpl extends _DOMTypeBase implements SVGPathSeg {
  _SVGPathSegImpl._wrap(ptr) : super._wrap(ptr);

  int get pathSegType() => _wrap(_ptr.pathSegType);

  String get pathSegTypeAsLetter() => _wrap(_ptr.pathSegTypeAsLetter);
}

class _SVGPathSegArcAbsImpl extends _SVGPathSegImpl implements SVGPathSegArcAbs {
  _SVGPathSegArcAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  void set angle(num value) { _ptr.angle = _unwrap(value); }

  bool get largeArcFlag() => _wrap(_ptr.largeArcFlag);

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = _unwrap(value); }

  num get r1() => _wrap(_ptr.r1);

  void set r1(num value) { _ptr.r1 = _unwrap(value); }

  num get r2() => _wrap(_ptr.r2);

  void set r2(num value) { _ptr.r2 = _unwrap(value); }

  bool get sweepFlag() => _wrap(_ptr.sweepFlag);

  void set sweepFlag(bool value) { _ptr.sweepFlag = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegArcRelImpl extends _SVGPathSegImpl implements SVGPathSegArcRel {
  _SVGPathSegArcRelImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  void set angle(num value) { _ptr.angle = _unwrap(value); }

  bool get largeArcFlag() => _wrap(_ptr.largeArcFlag);

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = _unwrap(value); }

  num get r1() => _wrap(_ptr.r1);

  void set r1(num value) { _ptr.r1 = _unwrap(value); }

  num get r2() => _wrap(_ptr.r2);

  void set r2(num value) { _ptr.r2 = _unwrap(value); }

  bool get sweepFlag() => _wrap(_ptr.sweepFlag);

  void set sweepFlag(bool value) { _ptr.sweepFlag = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegClosePathImpl extends _SVGPathSegImpl implements SVGPathSegClosePath {
  _SVGPathSegClosePathImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGPathSegCurvetoCubicAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicAbs {
  _SVGPathSegCurvetoCubicAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicRel {
  _SVGPathSegCurvetoCubicRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothAbs {
  _SVGPathSegCurvetoCubicSmoothAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothRel {
  _SVGPathSegCurvetoCubicSmoothRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticAbs {
  _SVGPathSegCurvetoQuadraticAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticRel {
  _SVGPathSegCurvetoQuadraticRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothAbs {
  _SVGPathSegCurvetoQuadraticSmoothAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothRel {
  _SVGPathSegCurvetoQuadraticSmoothRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoAbs {
  _SVGPathSegLinetoAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoHorizontalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalAbs {
  _SVGPathSegLinetoHorizontalAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }
}

class _SVGPathSegLinetoHorizontalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalRel {
  _SVGPathSegLinetoHorizontalRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }
}

class _SVGPathSegLinetoRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoRel {
  _SVGPathSegLinetoRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoVerticalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalAbs {
  _SVGPathSegLinetoVerticalAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoVerticalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalRel {
  _SVGPathSegLinetoVerticalRelImpl._wrap(ptr) : super._wrap(ptr);

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegListImpl extends _DOMTypeBase implements SVGPathSegList {
  _SVGPathSegListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGPathSeg appendItem(SVGPathSeg newItem) => _wrap(_ptr.appendItem(_unwrap(newItem)));

  void clear() => _ptr.clear();

  SVGPathSeg getItem(int index) => _wrap(_ptr.getItem(_unwrap(index)));

  SVGPathSeg initialize(SVGPathSeg newItem) => _wrap(_ptr.initialize(_unwrap(newItem)));

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index) => _wrap(_ptr.insertItemBefore(_unwrap(newItem), _unwrap(index)));

  SVGPathSeg removeItem(int index) => _wrap(_ptr.removeItem(_unwrap(index)));

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index) => _wrap(_ptr.replaceItem(_unwrap(newItem), _unwrap(index)));
}

class _SVGPathSegMovetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegMovetoAbs {
  _SVGPathSegMovetoAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegMovetoRelImpl extends _SVGPathSegImpl implements SVGPathSegMovetoRel {
  _SVGPathSegMovetoRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPatternElementImpl extends _SVGElementImpl implements SVGPatternElement {
  _SVGPatternElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get patternContentUnits() => _wrap(_ptr.patternContentUnits);

  SVGAnimatedTransformList get patternTransform() => _wrap(_ptr.patternTransform);

  SVGAnimatedEnumeration get patternUnits() => _wrap(_ptr.patternUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGPointImpl extends _DOMTypeBase implements SVGPoint {
  _SVGPointImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  SVGPoint matrixTransform(SVGMatrix matrix) => _wrap(_ptr.matrixTransform(_unwrap(matrix)));
}

class _SVGPointListImpl extends _DOMTypeBase implements SVGPointList {
  _SVGPointListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGPoint appendItem(SVGPoint item) => _wrap(_ptr.appendItem(_unwrap(item)));

  void clear() => _ptr.clear();

  SVGPoint getItem(int index) => _wrap(_ptr.getItem(_unwrap(index)));

  SVGPoint initialize(SVGPoint item) => _wrap(_ptr.initialize(_unwrap(item)));

  SVGPoint insertItemBefore(SVGPoint item, int index) => _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));

  SVGPoint removeItem(int index) => _wrap(_ptr.removeItem(_unwrap(index)));

  SVGPoint replaceItem(SVGPoint item, int index) => _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
}

class _SVGPolygonElementImpl extends _SVGElementImpl implements SVGPolygonElement {
  _SVGPolygonElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPointList get animatedPoints() => _wrap(_ptr.animatedPoints);

  SVGPointList get points() => _wrap(_ptr.points);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGPolylineElementImpl extends _SVGElementImpl implements SVGPolylineElement {
  _SVGPolylineElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPointList get animatedPoints() => _wrap(_ptr.animatedPoints);

  SVGPointList get points() => _wrap(_ptr.points);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGPreserveAspectRatioImpl extends _DOMTypeBase implements SVGPreserveAspectRatio {
  _SVGPreserveAspectRatioImpl._wrap(ptr) : super._wrap(ptr);

  int get align() => _wrap(_ptr.align);

  void set align(int value) { _ptr.align = _unwrap(value); }

  int get meetOrSlice() => _wrap(_ptr.meetOrSlice);

  void set meetOrSlice(int value) { _ptr.meetOrSlice = _unwrap(value); }
}

class _SVGRadialGradientElementImpl extends _SVGGradientElementImpl implements SVGRadialGradientElement {
  _SVGRadialGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get fx() => _wrap(_ptr.fx);

  SVGAnimatedLength get fy() => _wrap(_ptr.fy);

  SVGAnimatedLength get r() => _wrap(_ptr.r);
}

class _SVGRectImpl extends _DOMTypeBase implements SVGRect {
  _SVGRectImpl._wrap(ptr) : super._wrap(ptr);

  num get height() => _wrap(_ptr.height);

  void set height(num value) { _ptr.height = _unwrap(value); }

  num get width() => _wrap(_ptr.width);

  void set width(num value) { _ptr.width = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGRectElementImpl extends _SVGElementImpl implements SVGRectElement {
  _SVGRectElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedLength get rx() => _wrap(_ptr.rx);

  SVGAnimatedLength get ry() => _wrap(_ptr.ry);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGRenderingIntentImpl extends _DOMTypeBase implements SVGRenderingIntent {
  _SVGRenderingIntentImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGSVGElementImpl extends _SVGElementImpl implements SVGSVGElement {
  _SVGSVGElementImpl._wrap(ptr) : super._wrap(ptr);

  String get contentScriptType() => _wrap(_ptr.contentScriptType);

  void set contentScriptType(String value) { _ptr.contentScriptType = _unwrap(value); }

  String get contentStyleType() => _wrap(_ptr.contentStyleType);

  void set contentStyleType(String value) { _ptr.contentStyleType = _unwrap(value); }

  num get currentScale() => _wrap(_ptr.currentScale);

  void set currentScale(num value) { _ptr.currentScale = _unwrap(value); }

  SVGPoint get currentTranslate() => _wrap(_ptr.currentTranslate);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  num get pixelUnitToMillimeterX() => _wrap(_ptr.pixelUnitToMillimeterX);

  num get pixelUnitToMillimeterY() => _wrap(_ptr.pixelUnitToMillimeterY);

  num get screenPixelToMillimeterX() => _wrap(_ptr.screenPixelToMillimeterX);

  num get screenPixelToMillimeterY() => _wrap(_ptr.screenPixelToMillimeterY);

  bool get useCurrentView() => _wrap(_ptr.useCurrentView);

  void set useCurrentView(bool value) { _ptr.useCurrentView = _unwrap(value); }

  SVGRect get viewport() => _wrap(_ptr.viewport);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  bool animationsPaused() => _wrap(_ptr.animationsPaused());

  bool checkEnclosure(SVGElement element, SVGRect rect) => _wrap(_ptr.checkEnclosure(_unwrap(element), _unwrap(rect)));

  bool checkIntersection(SVGElement element, SVGRect rect) => _wrap(_ptr.checkIntersection(_unwrap(element), _unwrap(rect)));

  SVGAngle createSVGAngle() => _wrap(_ptr.createSVGAngle());

  SVGLength createSVGLength() => _wrap(_ptr.createSVGLength());

  SVGMatrix createSVGMatrix() => _wrap(_ptr.createSVGMatrix());

  SVGNumber createSVGNumber() => _wrap(_ptr.createSVGNumber());

  SVGPoint createSVGPoint() => _wrap(_ptr.createSVGPoint());

  SVGRect createSVGRect() => _wrap(_ptr.createSVGRect());

  SVGTransform createSVGTransform() => _wrap(_ptr.createSVGTransform());

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) => _wrap(_ptr.createSVGTransformFromMatrix(_unwrap(matrix)));

  void deselectAll() => _ptr.deselectAll();

  void forceRedraw() => _ptr.forceRedraw();

  num getCurrentTime() => _wrap(_ptr.getCurrentTime());

  Element getElementById(String elementId) => _wrap(_ptr.getElementById(_unwrap(elementId)));

  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement) => _wrap(_ptr.getEnclosureList(_unwrap(rect), _unwrap(referenceElement)));

  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement) => _wrap(_ptr.getIntersectionList(_unwrap(rect), _unwrap(referenceElement)));

  void pauseAnimations() => _ptr.pauseAnimations();

  void setCurrentTime(num seconds) => _ptr.setCurrentTime(_unwrap(seconds));

  int suspendRedraw(int maxWaitMilliseconds) => _wrap(_ptr.suspendRedraw(_unwrap(maxWaitMilliseconds)));

  void unpauseAnimations() => _ptr.unpauseAnimations();

  void unsuspendRedraw(int suspendHandleId) => _ptr.unsuspendRedraw(_unwrap(suspendHandleId));

  void unsuspendRedrawAll() => _ptr.unsuspendRedrawAll();

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);

  // From SVGZoomAndPan

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGScriptElementImpl extends _SVGElementImpl implements SVGScriptElement {
  _SVGScriptElementImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGSetElementImpl extends _SVGAnimationElementImpl implements SVGSetElement {
  _SVGSetElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGStopElementImpl extends _SVGElementImpl implements SVGStopElement {
  _SVGStopElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get offset() => _wrap(_ptr.offset);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGStringListImpl extends _DOMTypeBase implements SVGStringList {
  _SVGStringListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  String appendItem(String item) => _wrap(_ptr.appendItem(_unwrap(item)));

  void clear() => _ptr.clear();

  String getItem(int index) => _wrap(_ptr.getItem(_unwrap(index)));

  String initialize(String item) => _wrap(_ptr.initialize(_unwrap(item)));

  String insertItemBefore(String item, int index) => _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));

  String removeItem(int index) => _wrap(_ptr.removeItem(_unwrap(index)));

  String replaceItem(String item, int index) => _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
}

class _SVGStylableImpl extends _DOMTypeBase implements SVGStylable {
  _SVGStylableImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGStyleElementImpl extends _SVGElementImpl implements SVGStyleElement {
  _SVGStyleElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }
}

class _SVGSwitchElementImpl extends _SVGElementImpl implements SVGSwitchElement {
  _SVGSwitchElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGSymbolElementImpl extends _SVGElementImpl implements SVGSymbolElement {
  _SVGSymbolElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGTRefElementImpl extends _SVGTextPositioningElementImpl implements SVGTRefElement {
  _SVGTRefElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGTSpanElementImpl extends _SVGTextPositioningElementImpl implements SVGTSpanElement {
  _SVGTSpanElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGTestsImpl extends _DOMTypeBase implements SVGTests {
  _SVGTestsImpl._wrap(ptr) : super._wrap(ptr);

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));
}

class _SVGTextContentElementImpl extends _SVGElementImpl implements SVGTextContentElement {
  _SVGTextContentElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get lengthAdjust() => _wrap(_ptr.lengthAdjust);

  SVGAnimatedLength get textLength() => _wrap(_ptr.textLength);

  int getCharNumAtPosition(SVGPoint point) => _wrap(_ptr.getCharNumAtPosition(_unwrap(point)));

  num getComputedTextLength() => _wrap(_ptr.getComputedTextLength());

  SVGPoint getEndPositionOfChar(int offset) => _wrap(_ptr.getEndPositionOfChar(_unwrap(offset)));

  SVGRect getExtentOfChar(int offset) => _wrap(_ptr.getExtentOfChar(_unwrap(offset)));

  int getNumberOfChars() => _wrap(_ptr.getNumberOfChars());

  num getRotationOfChar(int offset) => _wrap(_ptr.getRotationOfChar(_unwrap(offset)));

  SVGPoint getStartPositionOfChar(int offset) => _wrap(_ptr.getStartPositionOfChar(_unwrap(offset)));

  num getSubStringLength(int offset, int length) => _wrap(_ptr.getSubStringLength(_unwrap(offset), _unwrap(length)));

  void selectSubString(int offset, int length) => _ptr.selectSubString(_unwrap(offset), _unwrap(length));

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGTextElementImpl extends _SVGTextPositioningElementImpl implements SVGTextElement {
  _SVGTextElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGTextPathElementImpl extends _SVGTextContentElementImpl implements SVGTextPathElement {
  _SVGTextPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get method() => _wrap(_ptr.method);

  SVGAnimatedEnumeration get spacing() => _wrap(_ptr.spacing);

  SVGAnimatedLength get startOffset() => _wrap(_ptr.startOffset);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGTextPositioningElementImpl extends _SVGTextContentElementImpl implements SVGTextPositioningElement {
  _SVGTextPositioningElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLengthList get dx() => _wrap(_ptr.dx);

  SVGAnimatedLengthList get dy() => _wrap(_ptr.dy);

  SVGAnimatedNumberList get rotate() => _wrap(_ptr.rotate);

  SVGAnimatedLengthList get x() => _wrap(_ptr.x);

  SVGAnimatedLengthList get y() => _wrap(_ptr.y);
}

class _SVGTitleElementImpl extends _SVGElementImpl implements SVGTitleElement {
  _SVGTitleElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
}

class _SVGTransformImpl extends _DOMTypeBase implements SVGTransform {
  _SVGTransformImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  SVGMatrix get matrix() => _wrap(_ptr.matrix);

  int get type() => _wrap(_ptr.type);

  void setMatrix(SVGMatrix matrix) => _ptr.setMatrix(_unwrap(matrix));

  void setRotate(num angle, num cx, num cy) => _ptr.setRotate(_unwrap(angle), _unwrap(cx), _unwrap(cy));

  void setScale(num sx, num sy) => _ptr.setScale(_unwrap(sx), _unwrap(sy));

  void setSkewX(num angle) => _ptr.setSkewX(_unwrap(angle));

  void setSkewY(num angle) => _ptr.setSkewY(_unwrap(angle));

  void setTranslate(num tx, num ty) => _ptr.setTranslate(_unwrap(tx), _unwrap(ty));
}

class _SVGTransformListImpl extends _DOMTypeBase implements SVGTransformList {
  _SVGTransformListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGTransform appendItem(SVGTransform item) => _wrap(_ptr.appendItem(_unwrap(item)));

  void clear() => _ptr.clear();

  SVGTransform consolidate() => _wrap(_ptr.consolidate());

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) => _wrap(_ptr.createSVGTransformFromMatrix(_unwrap(matrix)));

  SVGTransform getItem(int index) => _wrap(_ptr.getItem(_unwrap(index)));

  SVGTransform initialize(SVGTransform item) => _wrap(_ptr.initialize(_unwrap(item)));

  SVGTransform insertItemBefore(SVGTransform item, int index) => _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));

  SVGTransform removeItem(int index) => _wrap(_ptr.removeItem(_unwrap(index)));

  SVGTransform replaceItem(SVGTransform item, int index) => _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
}

class _SVGTransformableImpl extends _SVGLocatableImpl implements SVGTransformable {
  _SVGTransformableImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);
}

class _SVGURIReferenceImpl extends _DOMTypeBase implements SVGURIReference {
  _SVGURIReferenceImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGUnitTypesImpl extends _DOMTypeBase implements SVGUnitTypes {
  _SVGUnitTypesImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGUseElementImpl extends _SVGElementImpl implements SVGUseElement {
  _SVGUseElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGElementInstance get animatedInstanceRoot() => _wrap(_ptr.animatedInstanceRoot);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGElementInstance get instanceRoot() => _wrap(_ptr.instanceRoot);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) => _wrap(_ptr.hasExtension(_unwrap(extension)));

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.$dom_svgClassName);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) => _wrap(_ptr.getPresentationAttribute(_unwrap(name)));

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() => _wrap(_ptr.getBBox());

  SVGMatrix getCTM() => _wrap(_ptr.getCTM());

  SVGMatrix getScreenCTM() => _wrap(_ptr.getScreenCTM());

  SVGMatrix getTransformToElement(SVGElement element) => _wrap(_ptr.getTransformToElement(_unwrap(element)));
}

class _SVGVKernElementImpl extends _SVGElementImpl implements SVGVKernElement {
  _SVGVKernElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGViewElementImpl extends _SVGElementImpl implements SVGViewElement {
  _SVGViewElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGStringList get viewTarget() => _wrap(_ptr.viewTarget);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);

  // From SVGZoomAndPan

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGViewSpecImpl extends _SVGZoomAndPanImpl implements SVGViewSpec {
  _SVGViewSpecImpl._wrap(ptr) : super._wrap(ptr);

  String get preserveAspectRatioString() => _wrap(_ptr.preserveAspectRatioString);

  SVGTransformList get transform() => _wrap(_ptr.transform);

  String get transformString() => _wrap(_ptr.transformString);

  String get viewBoxString() => _wrap(_ptr.viewBoxString);

  SVGElement get viewTarget() => _wrap(_ptr.viewTarget);

  String get viewTargetString() => _wrap(_ptr.viewTargetString);

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGZoomAndPanImpl extends _DOMTypeBase implements SVGZoomAndPan {
  _SVGZoomAndPanImpl._wrap(ptr) : super._wrap(ptr);

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGZoomEventImpl extends _UIEventImpl implements SVGZoomEvent {
  _SVGZoomEventImpl._wrap(ptr) : super._wrap(ptr);

  num get newScale() => _wrap(_ptr.newScale);

  SVGPoint get newTranslate() => _wrap(_ptr.newTranslate);

  num get previousScale() => _wrap(_ptr.previousScale);

  SVGPoint get previousTranslate() => _wrap(_ptr.previousTranslate);

  SVGRect get zoomRectScreen() => _wrap(_ptr.zoomRectScreen);
}

class _ScreenImpl extends _DOMTypeBase implements Screen {
  _ScreenImpl._wrap(ptr) : super._wrap(ptr);

  int get availHeight() => _wrap(_ptr.availHeight);

  int get availLeft() => _wrap(_ptr.availLeft);

  int get availTop() => _wrap(_ptr.availTop);

  int get availWidth() => _wrap(_ptr.availWidth);

  int get colorDepth() => _wrap(_ptr.colorDepth);

  int get height() => _wrap(_ptr.height);

  int get pixelDepth() => _wrap(_ptr.pixelDepth);

  int get width() => _wrap(_ptr.width);
}

class _ScriptElementImpl extends _ElementImpl implements ScriptElement {
  _ScriptElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get async() => _wrap(_ptr.async);

  void set async(bool value) { _ptr.async = _unwrap(value); }

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get crossOrigin() => _wrap(_ptr.crossOrigin);

  void set crossOrigin(String value) { _ptr.crossOrigin = _unwrap(value); }

  bool get defer() => _wrap(_ptr.defer);

  void set defer(bool value) { _ptr.defer = _unwrap(value); }

  String get event() => _wrap(_ptr.event);

  void set event(String value) { _ptr.event = _unwrap(value); }

  String get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(String value) { _ptr.htmlFor = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _ScriptProfileImpl extends _DOMTypeBase implements ScriptProfile {
  _ScriptProfileImpl._wrap(ptr) : super._wrap(ptr);

  ScriptProfileNode get head() => _wrap(_ptr.head);

  String get title() => _wrap(_ptr.title);

  int get uid() => _wrap(_ptr.uid);
}

class _ScriptProfileNodeImpl extends _DOMTypeBase implements ScriptProfileNode {
  _ScriptProfileNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get callUID() => _wrap(_ptr.callUID);

  List<ScriptProfileNode> get children() => _wrap(_ptr.children);

  String get functionName() => _wrap(_ptr.functionName);

  int get lineNumber() => _wrap(_ptr.lineNumber);

  int get numberOfCalls() => _wrap(_ptr.numberOfCalls);

  num get selfTime() => _wrap(_ptr.selfTime);

  num get totalTime() => _wrap(_ptr.totalTime);

  String get url() => _wrap(_ptr.url);

  bool get visible() => _wrap(_ptr.visible);
}

class _SelectElementImpl extends _ElementImpl implements SelectElement {
  _SelectElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  NodeList get labels() => _wrap(_ptr.labels);

  int get length() => _wrap(_ptr.length);

  void set length(int value) { _ptr.length = _unwrap(value); }

  bool get multiple() => _wrap(_ptr.multiple);

  void set multiple(bool value) { _ptr.multiple = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  HTMLOptionsCollection get options() => _wrap(_ptr.options);

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  int get selectedIndex() => _wrap(_ptr.selectedIndex);

  void set selectedIndex(int value) { _ptr.selectedIndex = _unwrap(value); }

  HTMLCollection get selectedOptions() => _wrap(_ptr.selectedOptions);

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  void add(Element element, Element before) => _ptr.add(_unwrap(element), _unwrap(before));

  bool checkValidity() => _wrap(_ptr.checkValidity());

  Node item(int index) => _wrap(_ptr.item(_unwrap(index)));

  Node namedItem(String name) => _wrap(_ptr.namedItem(_unwrap(name)));

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));
}

class _SessionDescriptionImpl extends _DOMTypeBase implements SessionDescription {
  _SessionDescriptionImpl._wrap(ptr) : super._wrap(ptr);

  void addCandidate(IceCandidate candidate) => _ptr.addCandidate(_unwrap(candidate));

  String toSdp() => _wrap(_ptr.toSdp());
}

class _ShadowElementImpl extends _ElementImpl implements ShadowElement {
  _ShadowElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _ShadowRootImpl extends _DocumentFragmentImpl implements ShadowRoot {
  _ShadowRootImpl._wrap(ptr) : super._wrap(ptr);

  Element get activeElement() => _wrap(_ptr.activeElement);

  bool get applyAuthorStyles() => _wrap(_ptr.applyAuthorStyles);

  void set applyAuthorStyles(bool value) { _ptr.applyAuthorStyles = _unwrap(value); }

  Element get host() => _wrap(_ptr.host);

  String get innerHTML() => _wrap(_ptr.innerHTML);

  void set innerHTML(String value) { _ptr.innerHTML = _unwrap(value); }

  DOMSelection get selection() => _wrap(_ptr.selection);

  Element getElementById(String elementId) => _wrap(_ptr.getElementById(_unwrap(elementId)));

  NodeList getElementsByClassName(String className) => _wrap(_ptr.getElementsByClassName(_unwrap(className)));

  NodeList getElementsByTagName(String tagName) => _wrap(_ptr.getElementsByTagName(_unwrap(tagName)));

  NodeList getElementsByTagNameNS(String namespaceURI, String localName) => _wrap(_ptr.getElementsByTagNameNS(_unwrap(namespaceURI), _unwrap(localName)));
}

class _SharedWorkerImpl extends _AbstractWorkerImpl implements SharedWorker {
  _SharedWorkerImpl._wrap(ptr) : super._wrap(ptr);

  MessagePort get port() => _wrap(_ptr.port);
}

class _SharedWorkerContextImpl extends _WorkerContextImpl implements SharedWorkerContext {
  _SharedWorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get name() => _wrap(_ptr.name);
}

class _SourceElementImpl extends _ElementImpl implements SourceElement {
  _SourceElementImpl._wrap(ptr) : super._wrap(ptr);

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _SpanElementImpl extends _ElementImpl implements SpanElement {
  _SpanElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SpeechGrammarImpl extends _DOMTypeBase implements SpeechGrammar {
  _SpeechGrammarImpl._wrap(ptr) : super._wrap(ptr);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  num get weight() => _wrap(_ptr.weight);

  void set weight(num value) { _ptr.weight = _unwrap(value); }
}

class _SpeechGrammarListImpl extends _DOMTypeBase implements SpeechGrammarList {
  _SpeechGrammarListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void addFromString(String string, [num weight = null]) => _ptr.addFromString(_unwrap(string), _unwrap(weight));

  void addFromUri(String src, [num weight = null]) => _ptr.addFromUri(_unwrap(src), _unwrap(weight));

  SpeechGrammar item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _SpeechInputEventImpl extends _EventImpl implements SpeechInputEvent {
  _SpeechInputEventImpl._wrap(ptr) : super._wrap(ptr);

  SpeechInputResultList get results() => _wrap(_ptr.results);
}

class _SpeechInputResultImpl extends _DOMTypeBase implements SpeechInputResult {
  _SpeechInputResultImpl._wrap(ptr) : super._wrap(ptr);

  num get confidence() => _wrap(_ptr.confidence);

  String get utterance() => _wrap(_ptr.utterance);
}

class _SpeechInputResultListImpl extends _DOMTypeBase implements SpeechInputResultList {
  _SpeechInputResultListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SpeechInputResult item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _SpeechRecognitionImpl extends _EventTargetImpl implements SpeechRecognition {
  _SpeechRecognitionImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  bool get continuous() => _wrap(_ptr.continuous);

  void set continuous(bool value) { _ptr.continuous = _unwrap(value); }

  SpeechGrammarList get grammars() => _wrap(_ptr.grammars);

  void set grammars(SpeechGrammarList value) { _ptr.grammars = _unwrap(value); }

  String get lang() => _wrap(_ptr.lang);

  void set lang(String value) { _ptr.lang = _unwrap(value); }

  void abort() => _ptr.abort();

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void start() => _ptr.start();

  void stop() => _ptr.stop();
}

class _SpeechRecognitionAlternativeImpl extends _DOMTypeBase implements SpeechRecognitionAlternative {
  _SpeechRecognitionAlternativeImpl._wrap(ptr) : super._wrap(ptr);

  num get confidence() => _wrap(_ptr.confidence);

  String get transcript() => _wrap(_ptr.transcript);
}

class _SpeechRecognitionErrorImpl extends _DOMTypeBase implements SpeechRecognitionError {
  _SpeechRecognitionErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SpeechRecognitionEventImpl extends _EventImpl implements SpeechRecognitionEvent {
  _SpeechRecognitionEventImpl._wrap(ptr) : super._wrap(ptr);

  SpeechRecognitionError get error() => _wrap(_ptr.error);

  SpeechRecognitionResult get result() => _wrap(_ptr.result);

  SpeechRecognitionResultList get resultHistory() => _wrap(_ptr.resultHistory);

  int get resultIndex() => _wrap(_ptr.resultIndex);
}

class _SpeechRecognitionResultImpl extends _DOMTypeBase implements SpeechRecognitionResult {
  _SpeechRecognitionResultImpl._wrap(ptr) : super._wrap(ptr);

  bool get finalValue() => _wrap(_ptr.finalValue);

  int get length() => _wrap(_ptr.length);

  SpeechRecognitionAlternative item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _SpeechRecognitionResultListImpl extends _DOMTypeBase implements SpeechRecognitionResultList {
  _SpeechRecognitionResultListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SpeechRecognitionResult item(int index) => _wrap(_ptr.item(_unwrap(index)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _StorageImpl extends _DOMTypeBase implements Storage {

  // TODO(nweiz): update this when maps support lazy iteration
  bool containsValue(String value) => getValues().some((e) => e == value);

  bool containsKey(String key) => $dom_getItem(key) != null;

  String operator [](String key) => $dom_getItem(key);

  void operator []=(String key, String value) => $dom_setItem(key, value);

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) this[key] = ifAbsent();
    return this[key];
  }

  String remove(String key) {
    final value = this[key];
    $dom_removeItem(key);
    return value;
  }

  void clear() => $dom_clear();

  void forEach(void f(String key, String value)) {
    for (var i = 0; true; i++) {
      final key = $dom_key(i);
      if (key == null) return;

      f(key, this[key]);
    }
  }

  Collection<String> getKeys() {
    final keys = [];
    forEach((k, v) => keys.add(k));
    return keys;
  }

  Collection<String> getValues() {
    final values = [];
    forEach((k, v) => values.add(v));
    return values;
  }

  int get length() => $dom_length;

  bool isEmpty() => $dom_key(0) == null;
  _StorageImpl._wrap(ptr) : super._wrap(ptr);

  int get $dom_length() => _wrap(_ptr.$dom_length);

  void $dom_clear() => _ptr.$dom_clear();

  String $dom_getItem(String key) => _wrap(_ptr.$dom_getItem(_unwrap(key)));

  String $dom_key(int index) => _wrap(_ptr.$dom_key(_unwrap(index)));

  void $dom_removeItem(String key) => _ptr.$dom_removeItem(_unwrap(key));

  void $dom_setItem(String key, String data) => _ptr.$dom_setItem(_unwrap(key), _unwrap(data));

}

class _StorageEventImpl extends _EventImpl implements StorageEvent {
  _StorageEventImpl._wrap(ptr) : super._wrap(ptr);

  String get key() => _wrap(_ptr.key);

  String get newValue() => _wrap(_ptr.newValue);

  String get oldValue() => _wrap(_ptr.oldValue);

  Storage get storageArea() => _wrap(_ptr.storageArea);

  String get url() => _wrap(_ptr.url);

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) => _ptr.initStorageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(keyArg), _unwrap(oldValueArg), _unwrap(newValueArg), _unwrap(urlArg), _unwrap(storageAreaArg));
}

class _StorageInfoImpl extends _DOMTypeBase implements StorageInfo {
  _StorageInfoImpl._wrap(ptr) : super._wrap(ptr);

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback = null, StorageInfoErrorCallback errorCallback = null]) => _ptr.queryUsageAndQuota(_unwrap(storageType), _unwrap(usageCallback), _unwrap(errorCallback));

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback = null, StorageInfoErrorCallback errorCallback = null]) => _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes), _unwrap(quotaCallback), _unwrap(errorCallback));
}

class _StyleElementImpl extends _ElementImpl implements StyleElement {
  _StyleElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  bool get scoped() => _wrap(_ptr.scoped);

  void set scoped(bool value) { _ptr.scoped = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _StyleMediaImpl extends _DOMTypeBase implements StyleMedia {
  _StyleMediaImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  bool matchMedium(String mediaquery) => _wrap(_ptr.matchMedium(_unwrap(mediaquery)));
}

class _StyleSheetImpl extends _DOMTypeBase implements StyleSheet {
  _StyleSheetImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  MediaList get media() => _wrap(_ptr.media);

  Node get ownerNode() => _wrap(_ptr.ownerNode);

  StyleSheet get parentStyleSheet() => _wrap(_ptr.parentStyleSheet);

  String get title() => _wrap(_ptr.title);

  String get type() => _wrap(_ptr.type);
}

class _StyleSheetListImpl extends _DOMTypeBase implements StyleSheetList {
  _StyleSheetListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  StyleSheet operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, StyleSheet value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<StyleSheet> mixins.
  // StyleSheet is the element type.

  // From Iterable<StyleSheet>:

  Iterator<StyleSheet> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<StyleSheet>(this);
  }

  // From Collection<StyleSheet>:

  void add(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<StyleSheet> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(StyleSheet element)) => _Collections.forEach(this, f);

  Collection map(f(StyleSheet element)) => _Collections.map(this, [], f);

  Collection<StyleSheet> filter(bool f(StyleSheet element)) =>
     _Collections.filter(this, <StyleSheet>[], f);

  bool every(bool f(StyleSheet element)) => _Collections.every(this, f);

  bool some(bool f(StyleSheet element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<StyleSheet>:

  void sort(int compare(StyleSheet a, StyleSheet b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(StyleSheet element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(StyleSheet element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  StyleSheet last() => this[length - 1];

  StyleSheet removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [StyleSheet initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <StyleSheet>[]);

  // -- end List<StyleSheet> mixins.

  StyleSheet item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _TableCaptionElementImpl extends _ElementImpl implements TableCaptionElement {
  _TableCaptionElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _TableCellElementImpl extends _ElementImpl implements TableCellElement {
  _TableCellElementImpl._wrap(ptr) : super._wrap(ptr);

  String get abbr() => _wrap(_ptr.abbr);

  void set abbr(String value) { _ptr.abbr = _unwrap(value); }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get axis() => _wrap(_ptr.axis);

  void set axis(String value) { _ptr.axis = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  int get cellIndex() => _wrap(_ptr.cellIndex);

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get colSpan() => _wrap(_ptr.colSpan);

  void set colSpan(int value) { _ptr.colSpan = _unwrap(value); }

  String get headers() => _wrap(_ptr.headers);

  void set headers(String value) { _ptr.headers = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  bool get noWrap() => _wrap(_ptr.noWrap);

  void set noWrap(bool value) { _ptr.noWrap = _unwrap(value); }

  int get rowSpan() => _wrap(_ptr.rowSpan);

  void set rowSpan(int value) { _ptr.rowSpan = _unwrap(value); }

  String get scope() => _wrap(_ptr.scope);

  void set scope(String value) { _ptr.scope = _unwrap(value); }

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _TableColElementImpl extends _ElementImpl implements TableColElement {
  _TableColElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get span() => _wrap(_ptr.span);

  void set span(int value) { _ptr.span = _unwrap(value); }

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _TableElementImpl extends _ElementImpl implements TableElement {
  _TableElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  TableCaptionElement get caption() => _wrap(_ptr.caption);

  void set caption(TableCaptionElement value) { _ptr.caption = _unwrap(value); }

  String get cellPadding() => _wrap(_ptr.cellPadding);

  void set cellPadding(String value) { _ptr.cellPadding = _unwrap(value); }

  String get cellSpacing() => _wrap(_ptr.cellSpacing);

  void set cellSpacing(String value) { _ptr.cellSpacing = _unwrap(value); }

  String get frame() => _wrap(_ptr.frame);

  void set frame(String value) { _ptr.frame = _unwrap(value); }

  HTMLCollection get rows() => _wrap(_ptr.rows);

  String get rules() => _wrap(_ptr.rules);

  void set rules(String value) { _ptr.rules = _unwrap(value); }

  String get summary() => _wrap(_ptr.summary);

  void set summary(String value) { _ptr.summary = _unwrap(value); }

  HTMLCollection get tBodies() => _wrap(_ptr.tBodies);

  TableSectionElement get tFoot() => _wrap(_ptr.tFoot);

  void set tFoot(TableSectionElement value) { _ptr.tFoot = _unwrap(value); }

  TableSectionElement get tHead() => _wrap(_ptr.tHead);

  void set tHead(TableSectionElement value) { _ptr.tHead = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  Element createCaption() => _wrap(_ptr.createCaption());

  Element createTBody() => _wrap(_ptr.createTBody());

  Element createTFoot() => _wrap(_ptr.createTFoot());

  Element createTHead() => _wrap(_ptr.createTHead());

  void deleteCaption() => _ptr.deleteCaption();

  void deleteRow(int index) => _ptr.deleteRow(_unwrap(index));

  void deleteTFoot() => _ptr.deleteTFoot();

  void deleteTHead() => _ptr.deleteTHead();

  Element insertRow(int index) => _wrap(_ptr.insertRow(_unwrap(index)));
}

class _TableRowElementImpl extends _ElementImpl implements TableRowElement {
  _TableRowElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  HTMLCollection get cells() => _wrap(_ptr.cells);

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get rowIndex() => _wrap(_ptr.rowIndex);

  int get sectionRowIndex() => _wrap(_ptr.sectionRowIndex);

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  void deleteCell(int index) => _ptr.deleteCell(_unwrap(index));

  Element insertCell(int index) => _wrap(_ptr.insertCell(_unwrap(index)));
}

class _TableSectionElementImpl extends _ElementImpl implements TableSectionElement {
  _TableSectionElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  HTMLCollection get rows() => _wrap(_ptr.rows);

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  void deleteRow(int index) => _ptr.deleteRow(_unwrap(index));

  Element insertRow(int index) => _wrap(_ptr.insertRow(_unwrap(index)));
}

class _TextImpl extends _CharacterDataImpl implements Text {
  _TextImpl._wrap(ptr) : super._wrap(ptr);

  String get wholeText() => _wrap(_ptr.wholeText);

  Text replaceWholeText(String content) => _wrap(_ptr.replaceWholeText(_unwrap(content)));

  Text splitText(int offset) => _wrap(_ptr.splitText(_unwrap(offset)));
}

class _TextAreaElementImpl extends _ElementImpl implements TextAreaElement {
  _TextAreaElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  int get cols() => _wrap(_ptr.cols);

  void set cols(int value) { _ptr.cols = _unwrap(value); }

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  NodeList get labels() => _wrap(_ptr.labels);

  int get maxLength() => _wrap(_ptr.maxLength);

  void set maxLength(int value) { _ptr.maxLength = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get placeholder() => _wrap(_ptr.placeholder);

  void set placeholder(String value) { _ptr.placeholder = _unwrap(value); }

  bool get readOnly() => _wrap(_ptr.readOnly);

  void set readOnly(bool value) { _ptr.readOnly = _unwrap(value); }

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  int get rows() => _wrap(_ptr.rows);

  void set rows(int value) { _ptr.rows = _unwrap(value); }

  String get selectionDirection() => _wrap(_ptr.selectionDirection);

  void set selectionDirection(String value) { _ptr.selectionDirection = _unwrap(value); }

  int get selectionEnd() => _wrap(_ptr.selectionEnd);

  void set selectionEnd(int value) { _ptr.selectionEnd = _unwrap(value); }

  int get selectionStart() => _wrap(_ptr.selectionStart);

  void set selectionStart(int value) { _ptr.selectionStart = _unwrap(value); }

  int get textLength() => _wrap(_ptr.textLength);

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  String get wrap() => _wrap(_ptr.wrap);

  void set wrap(String value) { _ptr.wrap = _unwrap(value); }

  bool checkValidity() => _wrap(_ptr.checkValidity());

  void select() => _ptr.select();

  void setCustomValidity(String error) => _ptr.setCustomValidity(_unwrap(error));

  void setSelectionRange(int start, int end, [String direction = null]) => _ptr.setSelectionRange(_unwrap(start), _unwrap(end), _unwrap(direction));
}

class _TextEventImpl extends _UIEventImpl implements TextEvent {
  _TextEventImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) => _ptr.initTextEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(viewArg), _unwrap(dataArg));
}

class _TextMetricsImpl extends _DOMTypeBase implements TextMetrics {
  _TextMetricsImpl._wrap(ptr) : super._wrap(ptr);

  num get width() => _wrap(_ptr.width);
}

class _TextTrackImpl extends _EventTargetImpl implements TextTrack {
  _TextTrackImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  TextTrackCueList get activeCues() => _wrap(_ptr.activeCues);

  TextTrackCueList get cues() => _wrap(_ptr.cues);

  String get kind() => _wrap(_ptr.kind);

  String get label() => _wrap(_ptr.label);

  String get language() => _wrap(_ptr.language);

  int get mode() => _wrap(_ptr.mode);

  void set mode(int value) { _ptr.mode = _unwrap(value); }

  void addCue(TextTrackCue cue) => _ptr.addCue(_unwrap(cue));

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void removeCue(TextTrackCue cue) => _ptr.removeCue(_unwrap(cue));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _TextTrackCueImpl extends _EventTargetImpl implements TextTrackCue {
  _TextTrackCueImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  num get endTime() => _wrap(_ptr.endTime);

  void set endTime(num value) { _ptr.endTime = _unwrap(value); }

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  int get line() => _wrap(_ptr.line);

  void set line(int value) { _ptr.line = _unwrap(value); }

  bool get pauseOnExit() => _wrap(_ptr.pauseOnExit);

  void set pauseOnExit(bool value) { _ptr.pauseOnExit = _unwrap(value); }

  int get position() => _wrap(_ptr.position);

  void set position(int value) { _ptr.position = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  bool get snapToLines() => _wrap(_ptr.snapToLines);

  void set snapToLines(bool value) { _ptr.snapToLines = _unwrap(value); }

  num get startTime() => _wrap(_ptr.startTime);

  void set startTime(num value) { _ptr.startTime = _unwrap(value); }

  String get text() => _wrap(_ptr.text);

  void set text(String value) { _ptr.text = _unwrap(value); }

  TextTrack get track() => _wrap(_ptr.track);

  String get vertical() => _wrap(_ptr.vertical);

  void set vertical(String value) { _ptr.vertical = _unwrap(value); }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  DocumentFragment getCueAsHTML() => _wrap(_ptr.getCueAsHTML());

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _TextTrackCueListImpl extends _DOMTypeBase implements TextTrackCueList {
  _TextTrackCueListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  TextTrackCue getCueById(String id) => _wrap(_ptr.getCueById(_unwrap(id)));

  TextTrackCue item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _TextTrackListImpl extends _EventTargetImpl implements TextTrackList {
  _TextTrackListImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  int get length() => _wrap(_ptr.length);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  TextTrack item(int index) => _wrap(_ptr.item(_unwrap(index)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _TimeRangesImpl extends _DOMTypeBase implements TimeRanges {
  _TimeRangesImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num end(int index) => _wrap(_ptr.end(_unwrap(index)));

  num start(int index) => _wrap(_ptr.start(_unwrap(index)));
}

class _TitleElementImpl extends _ElementImpl implements TitleElement {
  _TitleElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _TouchImpl extends _DOMTypeBase implements Touch {
  _TouchImpl._wrap(ptr) : super._wrap(ptr);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  int get identifier() => _wrap(_ptr.identifier);

  int get pageX() => _wrap(_ptr.pageX);

  int get pageY() => _wrap(_ptr.pageY);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  EventTarget get target() => _wrap(_ptr.target);

  num get webkitForce() => _wrap(_ptr.webkitForce);

  int get webkitRadiusX() => _wrap(_ptr.webkitRadiusX);

  int get webkitRadiusY() => _wrap(_ptr.webkitRadiusY);

  num get webkitRotationAngle() => _wrap(_ptr.webkitRotationAngle);
}

class _TouchEventImpl extends _UIEventImpl implements TouchEvent {
  _TouchEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  TouchList get changedTouches() => _wrap(_ptr.changedTouches);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  bool get metaKey() => _wrap(_ptr.metaKey);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  TouchList get targetTouches() => _wrap(_ptr.targetTouches);

  TouchList get touches() => _wrap(_ptr.touches);

  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) => _ptr.initTouchEvent(_unwrap(touches), _unwrap(targetTouches), _unwrap(changedTouches), _unwrap(type), _unwrap(view), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey));
}

class _TouchListImpl extends _DOMTypeBase implements TouchList {
  _TouchListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Touch operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, Touch value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<Touch> mixins.
  // Touch is the element type.

  // From Iterable<Touch>:

  Iterator<Touch> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Touch>(this);
  }

  // From Collection<Touch>:

  void add(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Touch> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(Touch element)) => _Collections.forEach(this, f);

  Collection map(f(Touch element)) => _Collections.map(this, [], f);

  Collection<Touch> filter(bool f(Touch element)) =>
     _Collections.filter(this, <Touch>[], f);

  bool every(bool f(Touch element)) => _Collections.every(this, f);

  bool some(bool f(Touch element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Touch>:

  void sort(int compare(Touch a, Touch b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Touch element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Touch element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Touch last() => this[length - 1];

  Touch removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Touch> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Touch initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Touch>[]);

  // -- end List<Touch> mixins.

  Touch item(int index) => _wrap(_ptr.item(_unwrap(index)));
}

class _TrackElementImpl extends _ElementImpl implements TrackElement {
  _TrackElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(bool value) { _ptr.defaultValue = _unwrap(value); }

  String get kind() => _wrap(_ptr.kind);

  void set kind(String value) { _ptr.kind = _unwrap(value); }

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get srclang() => _wrap(_ptr.srclang);

  void set srclang(String value) { _ptr.srclang = _unwrap(value); }

  TextTrack get track() => _wrap(_ptr.track);
}

class _TrackEventImpl extends _EventImpl implements TrackEvent {
  _TrackEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get track() => _wrap(_ptr.track);
}

class _TransitionEventImpl extends _EventImpl implements TransitionEvent {
  _TransitionEventImpl._wrap(ptr) : super._wrap(ptr);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);

  String get propertyName() => _wrap(_ptr.propertyName);
}

class _TreeWalkerImpl extends _DOMTypeBase implements TreeWalker {
  _TreeWalkerImpl._wrap(ptr) : super._wrap(ptr);

  Node get currentNode() => _wrap(_ptr.currentNode);

  void set currentNode(Node value) { _ptr.currentNode = _unwrap(value); }

  bool get expandEntityReferences() => _wrap(_ptr.expandEntityReferences);

  NodeFilter get filter() => _wrap(_ptr.filter);

  Node get root() => _wrap(_ptr.root);

  int get whatToShow() => _wrap(_ptr.whatToShow);

  Node firstChild() => _wrap(_ptr.firstChild());

  Node lastChild() => _wrap(_ptr.lastChild());

  Node nextNode() => _wrap(_ptr.nextNode());

  Node nextSibling() => _wrap(_ptr.nextSibling());

  Node parentNode() => _wrap(_ptr.parentNode());

  Node previousNode() => _wrap(_ptr.previousNode());

  Node previousSibling() => _wrap(_ptr.previousSibling());
}

class _UIEventImpl extends _EventImpl implements UIEvent {
  _UIEventImpl._wrap(ptr) : super._wrap(ptr);

  int get charCode() => _wrap(_ptr.charCode);

  int get detail() => _wrap(_ptr.detail);

  int get keyCode() => _wrap(_ptr.keyCode);

  int get layerX() => _wrap(_ptr.layerX);

  int get layerY() => _wrap(_ptr.layerY);

  int get pageX() => _wrap(_ptr.pageX);

  int get pageY() => _wrap(_ptr.pageY);

  Window get view() => _wrap(_ptr.view);

  int get which() => _wrap(_ptr.which);

  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) => _ptr.initUIEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(detail));
}

class _UListElementImpl extends _ElementImpl implements UListElement {
  _UListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _Uint16ArrayImpl extends _ArrayBufferViewImpl implements Uint16Array, List<int> {
  _Uint16ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Uint16Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _Uint32ArrayImpl extends _ArrayBufferViewImpl implements Uint32Array, List<int> {
  _Uint32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Uint32Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _Uint8ArrayImpl extends _ArrayBufferViewImpl implements Uint8Array, List<int> {
  _Uint8ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Uint8Array subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _Uint8ClampedArrayImpl extends _Uint8ArrayImpl implements Uint8ClampedArray {
  _Uint8ClampedArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void setElements(Object array, [int offset = null]) => _ptr.setElements(_unwrap(array), _unwrap(offset));

  Uint8ClampedArray subarray(int start, [int end = null]) => _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
}

class _UnknownElementImpl extends _ElementImpl implements UnknownElement {
  _UnknownElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _ValidityStateImpl extends _DOMTypeBase implements ValidityState {
  _ValidityStateImpl._wrap(ptr) : super._wrap(ptr);

  bool get customError() => _wrap(_ptr.customError);

  bool get patternMismatch() => _wrap(_ptr.patternMismatch);

  bool get rangeOverflow() => _wrap(_ptr.rangeOverflow);

  bool get rangeUnderflow() => _wrap(_ptr.rangeUnderflow);

  bool get stepMismatch() => _wrap(_ptr.stepMismatch);

  bool get tooLong() => _wrap(_ptr.tooLong);

  bool get typeMismatch() => _wrap(_ptr.typeMismatch);

  bool get valid() => _wrap(_ptr.valid);

  bool get valueMissing() => _wrap(_ptr.valueMissing);
}

class _VideoElementImpl extends _MediaElementImpl implements VideoElement {
  _VideoElementImpl._wrap(ptr) : super._wrap(ptr);

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  String get poster() => _wrap(_ptr.poster);

  void set poster(String value) { _ptr.poster = _unwrap(value); }

  int get videoHeight() => _wrap(_ptr.videoHeight);

  int get videoWidth() => _wrap(_ptr.videoWidth);

  int get webkitDecodedFrameCount() => _wrap(_ptr.webkitDecodedFrameCount);

  bool get webkitDisplayingFullscreen() => _wrap(_ptr.webkitDisplayingFullscreen);

  int get webkitDroppedFrameCount() => _wrap(_ptr.webkitDroppedFrameCount);

  bool get webkitSupportsFullscreen() => _wrap(_ptr.webkitSupportsFullscreen);

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  void webkitEnterFullScreen() => _ptr.webkitEnterFullScreen();

  void webkitEnterFullscreen() => _ptr.webkitEnterFullscreen();

  void webkitExitFullScreen() => _ptr.webkitExitFullScreen();

  void webkitExitFullscreen() => _ptr.webkitExitFullscreen();
}

class _WaveShaperNodeImpl extends _AudioNodeImpl implements WaveShaperNode {
  _WaveShaperNodeImpl._wrap(ptr) : super._wrap(ptr);

  Float32Array get curve() => _wrap(_ptr.curve);

  void set curve(Float32Array value) { _ptr.curve = _unwrap(value); }
}

class _WaveTableImpl extends _DOMTypeBase implements WaveTable {
  _WaveTableImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLActiveInfoImpl extends _DOMTypeBase implements WebGLActiveInfo {
  _WebGLActiveInfoImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  int get size() => _wrap(_ptr.size);

  int get type() => _wrap(_ptr.type);
}

class _WebGLBufferImpl extends _DOMTypeBase implements WebGLBuffer {
  _WebGLBufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLCompressedTextureS3TCImpl extends _DOMTypeBase implements WebGLCompressedTextureS3TC {
  _WebGLCompressedTextureS3TCImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLContextAttributesImpl extends _DOMTypeBase implements WebGLContextAttributes {
  _WebGLContextAttributesImpl._wrap(ptr) : super._wrap(ptr);

  bool get alpha() => _wrap(_ptr.alpha);

  void set alpha(bool value) { _ptr.alpha = _unwrap(value); }

  bool get antialias() => _wrap(_ptr.antialias);

  void set antialias(bool value) { _ptr.antialias = _unwrap(value); }

  bool get depth() => _wrap(_ptr.depth);

  void set depth(bool value) { _ptr.depth = _unwrap(value); }

  bool get premultipliedAlpha() => _wrap(_ptr.premultipliedAlpha);

  void set premultipliedAlpha(bool value) { _ptr.premultipliedAlpha = _unwrap(value); }

  bool get preserveDrawingBuffer() => _wrap(_ptr.preserveDrawingBuffer);

  void set preserveDrawingBuffer(bool value) { _ptr.preserveDrawingBuffer = _unwrap(value); }

  bool get stencil() => _wrap(_ptr.stencil);

  void set stencil(bool value) { _ptr.stencil = _unwrap(value); }
}

class _WebGLContextEventImpl extends _EventImpl implements WebGLContextEvent {
  _WebGLContextEventImpl._wrap(ptr) : super._wrap(ptr);

  String get statusMessage() => _wrap(_ptr.statusMessage);
}

class _WebGLDebugRendererInfoImpl extends _DOMTypeBase implements WebGLDebugRendererInfo {
  _WebGLDebugRendererInfoImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLDebugShadersImpl extends _DOMTypeBase implements WebGLDebugShaders {
  _WebGLDebugShadersImpl._wrap(ptr) : super._wrap(ptr);

  String getTranslatedShaderSource(WebGLShader shader) => _wrap(_ptr.getTranslatedShaderSource(_unwrap(shader)));
}

class _WebGLFramebufferImpl extends _DOMTypeBase implements WebGLFramebuffer {
  _WebGLFramebufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLLoseContextImpl extends _DOMTypeBase implements WebGLLoseContext {
  _WebGLLoseContextImpl._wrap(ptr) : super._wrap(ptr);

  void loseContext() => _ptr.loseContext();

  void restoreContext() => _ptr.restoreContext();
}

class _WebGLProgramImpl extends _DOMTypeBase implements WebGLProgram {
  _WebGLProgramImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLRenderbufferImpl extends _DOMTypeBase implements WebGLRenderbuffer {
  _WebGLRenderbufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLRenderingContextImpl extends _CanvasRenderingContextImpl implements WebGLRenderingContext {
  _WebGLRenderingContextImpl._wrap(ptr) : super._wrap(ptr);

  int get drawingBufferHeight() => _wrap(_ptr.drawingBufferHeight);

  int get drawingBufferWidth() => _wrap(_ptr.drawingBufferWidth);

  void activeTexture(int texture) => _ptr.activeTexture(_unwrap(texture));

  void attachShader(WebGLProgram program, WebGLShader shader) => _ptr.attachShader(_unwrap(program), _unwrap(shader));

  void bindAttribLocation(WebGLProgram program, int index, String name) => _ptr.bindAttribLocation(_unwrap(program), _unwrap(index), _unwrap(name));

  void bindBuffer(int target, WebGLBuffer buffer) => _ptr.bindBuffer(_unwrap(target), _unwrap(buffer));

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) => _ptr.bindFramebuffer(_unwrap(target), _unwrap(framebuffer));

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) => _ptr.bindRenderbuffer(_unwrap(target), _unwrap(renderbuffer));

  void bindTexture(int target, WebGLTexture texture) => _ptr.bindTexture(_unwrap(target), _unwrap(texture));

  void blendColor(num red, num green, num blue, num alpha) => _ptr.blendColor(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));

  void blendEquation(int mode) => _ptr.blendEquation(_unwrap(mode));

  void blendEquationSeparate(int modeRGB, int modeAlpha) => _ptr.blendEquationSeparate(_unwrap(modeRGB), _unwrap(modeAlpha));

  void blendFunc(int sfactor, int dfactor) => _ptr.blendFunc(_unwrap(sfactor), _unwrap(dfactor));

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) => _ptr.blendFuncSeparate(_unwrap(srcRGB), _unwrap(dstRGB), _unwrap(srcAlpha), _unwrap(dstAlpha));

  void bufferData(int target, data_OR_size, int usage) => _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));

  void bufferSubData(int target, int offset, data) => _ptr.bufferSubData(_unwrap(target), _unwrap(offset), _unwrap(data));

  int checkFramebufferStatus(int target) => _wrap(_ptr.checkFramebufferStatus(_unwrap(target)));

  void clear(int mask) => _ptr.clear(_unwrap(mask));

  void clearColor(num red, num green, num blue, num alpha) => _ptr.clearColor(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));

  void clearDepth(num depth) => _ptr.clearDepth(_unwrap(depth));

  void clearStencil(int s) => _ptr.clearStencil(_unwrap(s));

  void colorMask(bool red, bool green, bool blue, bool alpha) => _ptr.colorMask(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));

  void compileShader(WebGLShader shader) => _ptr.compileShader(_unwrap(shader));

  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data) => _ptr.compressedTexImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(width), _unwrap(height), _unwrap(border), _unwrap(data));

  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data) => _ptr.compressedTexSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(width), _unwrap(height), _unwrap(format), _unwrap(data));

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) => _ptr.copyTexImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(border));

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) => _ptr.copyTexSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));

  WebGLBuffer createBuffer() => _wrap(_ptr.createBuffer());

  WebGLFramebuffer createFramebuffer() => _wrap(_ptr.createFramebuffer());

  WebGLProgram createProgram() => _wrap(_ptr.createProgram());

  WebGLRenderbuffer createRenderbuffer() => _wrap(_ptr.createRenderbuffer());

  WebGLShader createShader(int type) => _wrap(_ptr.createShader(_unwrap(type)));

  WebGLTexture createTexture() => _wrap(_ptr.createTexture());

  void cullFace(int mode) => _ptr.cullFace(_unwrap(mode));

  void deleteBuffer(WebGLBuffer buffer) => _ptr.deleteBuffer(_unwrap(buffer));

  void deleteFramebuffer(WebGLFramebuffer framebuffer) => _ptr.deleteFramebuffer(_unwrap(framebuffer));

  void deleteProgram(WebGLProgram program) => _ptr.deleteProgram(_unwrap(program));

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) => _ptr.deleteRenderbuffer(_unwrap(renderbuffer));

  void deleteShader(WebGLShader shader) => _ptr.deleteShader(_unwrap(shader));

  void deleteTexture(WebGLTexture texture) => _ptr.deleteTexture(_unwrap(texture));

  void depthFunc(int func) => _ptr.depthFunc(_unwrap(func));

  void depthMask(bool flag) => _ptr.depthMask(_unwrap(flag));

  void depthRange(num zNear, num zFar) => _ptr.depthRange(_unwrap(zNear), _unwrap(zFar));

  void detachShader(WebGLProgram program, WebGLShader shader) => _ptr.detachShader(_unwrap(program), _unwrap(shader));

  void disable(int cap) => _ptr.disable(_unwrap(cap));

  void disableVertexAttribArray(int index) => _ptr.disableVertexAttribArray(_unwrap(index));

  void drawArrays(int mode, int first, int count) => _ptr.drawArrays(_unwrap(mode), _unwrap(first), _unwrap(count));

  void drawElements(int mode, int count, int type, int offset) => _ptr.drawElements(_unwrap(mode), _unwrap(count), _unwrap(type), _unwrap(offset));

  void enable(int cap) => _ptr.enable(_unwrap(cap));

  void enableVertexAttribArray(int index) => _ptr.enableVertexAttribArray(_unwrap(index));

  void finish() => _ptr.finish();

  void flush() => _ptr.flush();

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) => _ptr.framebufferRenderbuffer(_unwrap(target), _unwrap(attachment), _unwrap(renderbuffertarget), _unwrap(renderbuffer));

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) => _ptr.framebufferTexture2D(_unwrap(target), _unwrap(attachment), _unwrap(textarget), _unwrap(texture), _unwrap(level));

  void frontFace(int mode) => _ptr.frontFace(_unwrap(mode));

  void generateMipmap(int target) => _ptr.generateMipmap(_unwrap(target));

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) => _wrap(_ptr.getActiveAttrib(_unwrap(program), _unwrap(index)));

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) => _wrap(_ptr.getActiveUniform(_unwrap(program), _unwrap(index)));

  List getAttachedShaders(WebGLProgram program) => _wrap(_ptr.getAttachedShaders(_unwrap(program)));

  int getAttribLocation(WebGLProgram program, String name) => _wrap(_ptr.getAttribLocation(_unwrap(program), _unwrap(name)));

  Object getBufferParameter(int target, int pname) => _wrap(_ptr.getBufferParameter(_unwrap(target), _unwrap(pname)));

  WebGLContextAttributes getContextAttributes() => _wrap(_ptr.getContextAttributes());

  int getError() => _wrap(_ptr.getError());

  Object getExtension(String name) => _wrap(_ptr.getExtension(_unwrap(name)));

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) => _wrap(_ptr.getFramebufferAttachmentParameter(_unwrap(target), _unwrap(attachment), _unwrap(pname)));

  Object getParameter(int pname) => _wrap(_ptr.getParameter(_unwrap(pname)));

  String getProgramInfoLog(WebGLProgram program) => _wrap(_ptr.getProgramInfoLog(_unwrap(program)));

  Object getProgramParameter(WebGLProgram program, int pname) => _wrap(_ptr.getProgramParameter(_unwrap(program), _unwrap(pname)));

  Object getRenderbufferParameter(int target, int pname) => _wrap(_ptr.getRenderbufferParameter(_unwrap(target), _unwrap(pname)));

  String getShaderInfoLog(WebGLShader shader) => _wrap(_ptr.getShaderInfoLog(_unwrap(shader)));

  Object getShaderParameter(WebGLShader shader, int pname) => _wrap(_ptr.getShaderParameter(_unwrap(shader), _unwrap(pname)));

  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype) => _wrap(_ptr.getShaderPrecisionFormat(_unwrap(shadertype), _unwrap(precisiontype)));

  String getShaderSource(WebGLShader shader) => _wrap(_ptr.getShaderSource(_unwrap(shader)));

  Object getTexParameter(int target, int pname) => _wrap(_ptr.getTexParameter(_unwrap(target), _unwrap(pname)));

  Object getUniform(WebGLProgram program, WebGLUniformLocation location) => _wrap(_ptr.getUniform(_unwrap(program), _unwrap(location)));

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) => _wrap(_ptr.getUniformLocation(_unwrap(program), _unwrap(name)));

  Object getVertexAttrib(int index, int pname) => _wrap(_ptr.getVertexAttrib(_unwrap(index), _unwrap(pname)));

  int getVertexAttribOffset(int index, int pname) => _wrap(_ptr.getVertexAttribOffset(_unwrap(index), _unwrap(pname)));

  void hint(int target, int mode) => _ptr.hint(_unwrap(target), _unwrap(mode));

  bool isBuffer(WebGLBuffer buffer) => _wrap(_ptr.isBuffer(_unwrap(buffer)));

  bool isContextLost() => _wrap(_ptr.isContextLost());

  bool isEnabled(int cap) => _wrap(_ptr.isEnabled(_unwrap(cap)));

  bool isFramebuffer(WebGLFramebuffer framebuffer) => _wrap(_ptr.isFramebuffer(_unwrap(framebuffer)));

  bool isProgram(WebGLProgram program) => _wrap(_ptr.isProgram(_unwrap(program)));

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) => _wrap(_ptr.isRenderbuffer(_unwrap(renderbuffer)));

  bool isShader(WebGLShader shader) => _wrap(_ptr.isShader(_unwrap(shader)));

  bool isTexture(WebGLTexture texture) => _wrap(_ptr.isTexture(_unwrap(texture)));

  void lineWidth(num width) => _ptr.lineWidth(_unwrap(width));

  void linkProgram(WebGLProgram program) => _ptr.linkProgram(_unwrap(program));

  void pixelStorei(int pname, int param) => _ptr.pixelStorei(_unwrap(pname), _unwrap(param));

  void polygonOffset(num factor, num units) => _ptr.polygonOffset(_unwrap(factor), _unwrap(units));

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) => _ptr.readPixels(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(format), _unwrap(type), _unwrap(pixels));

  void releaseShaderCompiler() => _ptr.releaseShaderCompiler();

  void renderbufferStorage(int target, int internalformat, int width, int height) => _ptr.renderbufferStorage(_unwrap(target), _unwrap(internalformat), _unwrap(width), _unwrap(height));

  void sampleCoverage(num value, bool invert) => _ptr.sampleCoverage(_unwrap(value), _unwrap(invert));

  void scissor(int x, int y, int width, int height) => _ptr.scissor(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));

  void shaderSource(WebGLShader shader, String string) => _ptr.shaderSource(_unwrap(shader), _unwrap(string));

  void stencilFunc(int func, int ref, int mask) => _ptr.stencilFunc(_unwrap(func), _unwrap(ref), _unwrap(mask));

  void stencilFuncSeparate(int face, int func, int ref, int mask) => _ptr.stencilFuncSeparate(_unwrap(face), _unwrap(func), _unwrap(ref), _unwrap(mask));

  void stencilMask(int mask) => _ptr.stencilMask(_unwrap(mask));

  void stencilMaskSeparate(int face, int mask) => _ptr.stencilMaskSeparate(_unwrap(face), _unwrap(mask));

  void stencilOp(int fail, int zfail, int zpass) => _ptr.stencilOp(_unwrap(fail), _unwrap(zfail), _unwrap(zpass));

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) => _ptr.stencilOpSeparate(_unwrap(face), _unwrap(fail), _unwrap(zfail), _unwrap(zpass));

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format = null, int type = null, ArrayBufferView pixels = null]) => _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video), _unwrap(format), _unwrap(type), _unwrap(pixels));

  void texParameterf(int target, int pname, num param) => _ptr.texParameterf(_unwrap(target), _unwrap(pname), _unwrap(param));

  void texParameteri(int target, int pname, int param) => _ptr.texParameteri(_unwrap(target), _unwrap(pname), _unwrap(param));

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type = null, ArrayBufferView pixels = null]) => _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video), _unwrap(type), _unwrap(pixels));

  void uniform1f(WebGLUniformLocation location, num x) => _ptr.uniform1f(_unwrap(location), _unwrap(x));

  void uniform1fv(WebGLUniformLocation location, Float32Array v) => _ptr.uniform1fv(_unwrap(location), _unwrap(v));

  void uniform1i(WebGLUniformLocation location, int x) => _ptr.uniform1i(_unwrap(location), _unwrap(x));

  void uniform1iv(WebGLUniformLocation location, Int32Array v) => _ptr.uniform1iv(_unwrap(location), _unwrap(v));

  void uniform2f(WebGLUniformLocation location, num x, num y) => _ptr.uniform2f(_unwrap(location), _unwrap(x), _unwrap(y));

  void uniform2fv(WebGLUniformLocation location, Float32Array v) => _ptr.uniform2fv(_unwrap(location), _unwrap(v));

  void uniform2i(WebGLUniformLocation location, int x, int y) => _ptr.uniform2i(_unwrap(location), _unwrap(x), _unwrap(y));

  void uniform2iv(WebGLUniformLocation location, Int32Array v) => _ptr.uniform2iv(_unwrap(location), _unwrap(v));

  void uniform3f(WebGLUniformLocation location, num x, num y, num z) => _ptr.uniform3f(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z));

  void uniform3fv(WebGLUniformLocation location, Float32Array v) => _ptr.uniform3fv(_unwrap(location), _unwrap(v));

  void uniform3i(WebGLUniformLocation location, int x, int y, int z) => _ptr.uniform3i(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z));

  void uniform3iv(WebGLUniformLocation location, Int32Array v) => _ptr.uniform3iv(_unwrap(location), _unwrap(v));

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) => _ptr.uniform4f(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));

  void uniform4fv(WebGLUniformLocation location, Float32Array v) => _ptr.uniform4fv(_unwrap(location), _unwrap(v));

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) => _ptr.uniform4i(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));

  void uniform4iv(WebGLUniformLocation location, Int32Array v) => _ptr.uniform4iv(_unwrap(location), _unwrap(v));

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) => _ptr.uniformMatrix2fv(_unwrap(location), _unwrap(transpose), _unwrap(array));

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) => _ptr.uniformMatrix3fv(_unwrap(location), _unwrap(transpose), _unwrap(array));

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) => _ptr.uniformMatrix4fv(_unwrap(location), _unwrap(transpose), _unwrap(array));

  void useProgram(WebGLProgram program) => _ptr.useProgram(_unwrap(program));

  void validateProgram(WebGLProgram program) => _ptr.validateProgram(_unwrap(program));

  void vertexAttrib1f(int indx, num x) => _ptr.vertexAttrib1f(_unwrap(indx), _unwrap(x));

  void vertexAttrib1fv(int indx, Float32Array values) => _ptr.vertexAttrib1fv(_unwrap(indx), _unwrap(values));

  void vertexAttrib2f(int indx, num x, num y) => _ptr.vertexAttrib2f(_unwrap(indx), _unwrap(x), _unwrap(y));

  void vertexAttrib2fv(int indx, Float32Array values) => _ptr.vertexAttrib2fv(_unwrap(indx), _unwrap(values));

  void vertexAttrib3f(int indx, num x, num y, num z) => _ptr.vertexAttrib3f(_unwrap(indx), _unwrap(x), _unwrap(y), _unwrap(z));

  void vertexAttrib3fv(int indx, Float32Array values) => _ptr.vertexAttrib3fv(_unwrap(indx), _unwrap(values));

  void vertexAttrib4f(int indx, num x, num y, num z, num w) => _ptr.vertexAttrib4f(_unwrap(indx), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));

  void vertexAttrib4fv(int indx, Float32Array values) => _ptr.vertexAttrib4fv(_unwrap(indx), _unwrap(values));

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) => _ptr.vertexAttribPointer(_unwrap(indx), _unwrap(size), _unwrap(type), _unwrap(normalized), _unwrap(stride), _unwrap(offset));

  void viewport(int x, int y, int width, int height) => _ptr.viewport(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
}

class _WebGLShaderImpl extends _DOMTypeBase implements WebGLShader {
  _WebGLShaderImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLShaderPrecisionFormatImpl extends _DOMTypeBase implements WebGLShaderPrecisionFormat {
  _WebGLShaderPrecisionFormatImpl._wrap(ptr) : super._wrap(ptr);

  int get precision() => _wrap(_ptr.precision);

  int get rangeMax() => _wrap(_ptr.rangeMax);

  int get rangeMin() => _wrap(_ptr.rangeMin);
}

class _WebGLTextureImpl extends _DOMTypeBase implements WebGLTexture {
  _WebGLTextureImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLUniformLocationImpl extends _DOMTypeBase implements WebGLUniformLocation {
  _WebGLUniformLocationImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLVertexArrayObjectOESImpl extends _DOMTypeBase implements WebGLVertexArrayObjectOES {
  _WebGLVertexArrayObjectOESImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebKitCSSFilterValueImpl extends _CSSValueListImpl implements WebKitCSSFilterValue {
  _WebKitCSSFilterValueImpl._wrap(ptr) : super._wrap(ptr);

  int get operationType() => _wrap(_ptr.operationType);
}

class _WebKitCSSRegionRuleImpl extends _CSSRuleImpl implements WebKitCSSRegionRule {
  _WebKitCSSRegionRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);
}

class _WebKitMutationObserverImpl extends _DOMTypeBase implements WebKitMutationObserver {
  _WebKitMutationObserverImpl._wrap(ptr) : super._wrap(ptr);

  void disconnect() => _ptr.disconnect();

  List<MutationRecord> takeRecords() => _wrap(_ptr.takeRecords());
}

class _WebKitNamedFlowImpl extends _DOMTypeBase implements WebKitNamedFlow {
  _WebKitNamedFlowImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get contentNodes() => _wrap(_ptr.contentNodes);

  bool get overflow() => _wrap(_ptr.overflow);

  NodeList getRegionsByContentNode(Node contentNode) => _wrap(_ptr.getRegionsByContentNode(_unwrap(contentNode)));
}

class _WebSocketImpl extends _EventTargetImpl implements WebSocket {
  _WebSocketImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  String get URL() => _wrap(_ptr.URL);

  String get binaryType() => _wrap(_ptr.binaryType);

  void set binaryType(String value) { _ptr.binaryType = _unwrap(value); }

  int get bufferedAmount() => _wrap(_ptr.bufferedAmount);

  String get extensions() => _wrap(_ptr.extensions);

  String get protocol() => _wrap(_ptr.protocol);

  int get readyState() => _wrap(_ptr.readyState);

  String get url() => _wrap(_ptr.url);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void close([int code = null, String reason = null]) => _ptr.close(_unwrap(code), _unwrap(reason));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool send(String data) => _wrap(_ptr.send(_unwrap(data)));
}

class _WheelEventImpl extends _UIEventImpl implements WheelEvent {
  _WheelEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  bool get metaKey() => _wrap(_ptr.metaKey);

  int get offsetX() => _wrap(_ptr.offsetX);

  int get offsetY() => _wrap(_ptr.offsetY);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  bool get webkitDirectionInvertedFromDevice() => _wrap(_ptr.webkitDirectionInvertedFromDevice);

  int get wheelDelta() => _wrap(_ptr.wheelDelta);

  int get wheelDeltaX() => _wrap(_ptr.wheelDeltaX);

  int get wheelDeltaY() => _wrap(_ptr.wheelDeltaY);

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) => _ptr.initWebKitWheelEvent(_unwrap(wheelDeltaX), _unwrap(wheelDeltaY), _unwrap(view), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WindowImpl extends _EventTargetImpl implements Window {

  _DocumentImpl get document() => _wrap(_ptr.document);

  void requestLayoutFrame(TimeoutHandler callback) {
    _addMeasurementFrameCallback(callback);
  }

  int requestAnimationFrame(RequestAnimationFrameCallback callback) =>
      webkitRequestAnimationFrame(callback);

  void cancelAnimationFrame(int id) => webkitCancelAnimationFrame(id);

  Window get top() => _wrap(_ptr.top);

  _WindowImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  DOMApplicationCache get applicationCache() => _wrap(_ptr.applicationCache);

  Navigator get clientInformation() => _wrap(_ptr.clientInformation);

  bool get closed() => _wrap(_ptr.closed);

  Console get console() => _wrap(_ptr.console);

  Crypto get crypto() => _wrap(_ptr.crypto);

  String get defaultStatus() => _wrap(_ptr.defaultStatus);

  void set defaultStatus(String value) { _ptr.defaultStatus = _unwrap(value); }

  String get defaultstatus() => _wrap(_ptr.defaultstatus);

  void set defaultstatus(String value) { _ptr.defaultstatus = _unwrap(value); }

  num get devicePixelRatio() => _wrap(_ptr.devicePixelRatio);

  Event get event() => _wrap(_ptr.event);

  Window get frames() => _wrap(_ptr.frames);

  History get history() => _wrap(_ptr.history);

  int get innerHeight() => _wrap(_ptr.innerHeight);

  int get innerWidth() => _wrap(_ptr.innerWidth);

  int get length() => _wrap(_ptr.length);

  Storage get localStorage() => _wrap(_ptr.localStorage);

  Location get location() => _wrap(_ptr.location);

  void set location(Location value) { _ptr.location = _unwrap(value); }

  BarInfo get locationbar() => _wrap(_ptr.locationbar);

  BarInfo get menubar() => _wrap(_ptr.menubar);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  Navigator get navigator() => _wrap(_ptr.navigator);

  bool get offscreenBuffering() => _wrap(_ptr.offscreenBuffering);

  Window get opener() => _wrap(_ptr.opener);

  int get outerHeight() => _wrap(_ptr.outerHeight);

  int get outerWidth() => _wrap(_ptr.outerWidth);

  int get pageXOffset() => _wrap(_ptr.pageXOffset);

  int get pageYOffset() => _wrap(_ptr.pageYOffset);

  Window get parent() => _wrap(_ptr.parent);

  Performance get performance() => _wrap(_ptr.performance);

  BarInfo get personalbar() => _wrap(_ptr.personalbar);

  Screen get screen() => _wrap(_ptr.screen);

  int get screenLeft() => _wrap(_ptr.screenLeft);

  int get screenTop() => _wrap(_ptr.screenTop);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  int get scrollX() => _wrap(_ptr.scrollX);

  int get scrollY() => _wrap(_ptr.scrollY);

  BarInfo get scrollbars() => _wrap(_ptr.scrollbars);

  Window get self() => _wrap(_ptr.self);

  Storage get sessionStorage() => _wrap(_ptr.sessionStorage);

  String get status() => _wrap(_ptr.status);

  void set status(String value) { _ptr.status = _unwrap(value); }

  BarInfo get statusbar() => _wrap(_ptr.statusbar);

  StyleMedia get styleMedia() => _wrap(_ptr.styleMedia);

  BarInfo get toolbar() => _wrap(_ptr.toolbar);

  IDBFactory get webkitIndexedDB() => _wrap(_ptr.webkitIndexedDB);

  NotificationCenter get webkitNotifications() => _wrap(_ptr.webkitNotifications);

  StorageInfo get webkitStorageInfo() => _wrap(_ptr.webkitStorageInfo);

  Window get window() => _wrap(_ptr.window);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void alert(String message) => _ptr.alert(_unwrap(message));

  String atob(String string) => _wrap(_ptr.atob(_unwrap(string)));

  void blur() => _ptr.blur();

  String btoa(String string) => _wrap(_ptr.btoa(_unwrap(string)));

  void captureEvents() => _ptr.captureEvents();

  void clearInterval(int handle) => _ptr.clearInterval(_unwrap(handle));

  void clearTimeout(int handle) => _ptr.clearTimeout(_unwrap(handle));

  void close() => _ptr.close();

  bool confirm(String message) => _wrap(_ptr.confirm(_unwrap(message)));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) => _wrap(_ptr.find(_unwrap(string), _unwrap(caseSensitive), _unwrap(backwards), _unwrap(wrap), _unwrap(wholeWord), _unwrap(searchInFrames), _unwrap(showDialog)));

  void focus() => _ptr.focus();

  CSSStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement) => _wrap(_ptr.$dom_getComputedStyle(_unwrap(element), _unwrap(pseudoElement)));

  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement) => _wrap(_ptr.getMatchedCSSRules(_unwrap(element), _unwrap(pseudoElement)));

  DOMSelection getSelection() => _wrap(_ptr.getSelection());

  MediaQueryList matchMedia(String query) => _wrap(_ptr.matchMedia(_unwrap(query)));

  void moveBy(num x, num y) => _ptr.moveBy(_unwrap(x), _unwrap(y));

  void moveTo(num x, num y) => _ptr.moveTo(_unwrap(x), _unwrap(y));

  Window open(String url, String name, [String options = null]) => _wrap(_ptr.open(_unwrap(url), _unwrap(name), _unwrap(options)));

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) => _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));

  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts = null]) => _ptr.postMessage(_unwrap(message), _unwrap(targetOrigin), _unwrap(messagePorts));

  void print() => _ptr.print();

  String prompt(String message, String defaultValue) => _wrap(_ptr.prompt(_unwrap(message), _unwrap(defaultValue)));

  void releaseEvents() => _ptr.releaseEvents();

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void resizeBy(num x, num y) => _ptr.resizeBy(_unwrap(x), _unwrap(y));

  void resizeTo(num width, num height) => _ptr.resizeTo(_unwrap(width), _unwrap(height));

  void scroll(int x, int y) => _ptr.scroll(_unwrap(x), _unwrap(y));

  void scrollBy(int x, int y) => _ptr.scrollBy(_unwrap(x), _unwrap(y));

  void scrollTo(int x, int y) => _ptr.scrollTo(_unwrap(x), _unwrap(y));

  int setInterval(TimeoutHandler handler, int timeout) => _wrap(_ptr.setInterval(_unwrap(handler), _unwrap(timeout)));

  int setTimeout(TimeoutHandler handler, int timeout) => _wrap(_ptr.setTimeout(_unwrap(handler), _unwrap(timeout)));

  Object showModalDialog(String url, [Object dialogArgs = null, String featureArgs = null]) => _wrap(_ptr.showModalDialog(_unwrap(url), _unwrap(dialogArgs), _unwrap(featureArgs)));

  void stop() => _ptr.stop();

  void webkitCancelAnimationFrame(int id) => _ptr.webkitCancelAnimationFrame(_unwrap(id));

  void webkitCancelRequestAnimationFrame(int id) => _ptr.webkitCancelRequestAnimationFrame(_unwrap(id));

  Point webkitConvertPointFromNodeToPage(Node node, Point p) => _wrap(_ptr.webkitConvertPointFromNodeToPage(_unwrap(node), _unwrap(p)));

  Point webkitConvertPointFromPageToNode(Node node, Point p) => _wrap(_ptr.webkitConvertPointFromPageToNode(_unwrap(node), _unwrap(p)));

  void webkitPostMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List transferList = null]) => _ptr.webkitPostMessage(_unwrap(message), _unwrap(targetOrigin), _unwrap(transferList));

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback) => _wrap(_ptr.webkitRequestAnimationFrame(_unwrap(callback)));

  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback = null]) => _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback), _unwrap(errorCallback));

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback), _unwrap(errorCallback));

}

class _WorkerImpl extends _AbstractWorkerImpl implements Worker {
  _WorkerImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts = null]) => _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));

  void terminate() => _ptr.terminate();

  void webkitPostMessage(/*SerializedScriptValue*/ message, [List messagePorts = null]) => _ptr.webkitPostMessage(_unwrap(message), _unwrap(messagePorts));
}

class _WorkerContextImpl extends _EventTargetImpl implements WorkerContext {
  _WorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  WorkerLocation get location() => _wrap(_ptr.location);

  WorkerNavigator get navigator() => _wrap(_ptr.navigator);

  WorkerContext get self() => _wrap(_ptr.self);

  IDBFactory get webkitIndexedDB() => _wrap(_ptr.webkitIndexedDB);

  NotificationCenter get webkitNotifications() => _wrap(_ptr.webkitNotifications);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void clearInterval(int handle) => _ptr.clearInterval(_unwrap(handle));

  void clearTimeout(int handle) => _ptr.clearTimeout(_unwrap(handle));

  void close() => _ptr.close();

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void importScripts() => _ptr.importScripts();

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) => _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));

  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) => _wrap(_ptr.openDatabaseSync(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  int setInterval(TimeoutHandler handler, int timeout) => _wrap(_ptr.setInterval(_unwrap(handler), _unwrap(timeout)));

  int setTimeout(TimeoutHandler handler, int timeout) => _wrap(_ptr.setTimeout(_unwrap(handler), _unwrap(timeout)));

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback), _unwrap(errorCallback));

  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size) => _wrap(_ptr.webkitRequestFileSystemSync(_unwrap(type), _unwrap(size)));

  EntrySync webkitResolveLocalFileSystemSyncURL(String url) => _wrap(_ptr.webkitResolveLocalFileSystemSyncURL(_unwrap(url)));

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) => _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback), _unwrap(errorCallback));
}

class _WorkerLocationImpl extends _DOMTypeBase implements WorkerLocation {
  _WorkerLocationImpl._wrap(ptr) : super._wrap(ptr);

  String get hash() => _wrap(_ptr.hash);

  String get host() => _wrap(_ptr.host);

  String get hostname() => _wrap(_ptr.hostname);

  String get href() => _wrap(_ptr.href);

  String get pathname() => _wrap(_ptr.pathname);

  String get port() => _wrap(_ptr.port);

  String get protocol() => _wrap(_ptr.protocol);

  String get search() => _wrap(_ptr.search);

  String toString() => _wrap(_ptr.toString());
}

class _WorkerNavigatorImpl extends _DOMTypeBase implements WorkerNavigator {
  _WorkerNavigatorImpl._wrap(ptr) : super._wrap(ptr);

  String get appName() => _wrap(_ptr.appName);

  String get appVersion() => _wrap(_ptr.appVersion);

  bool get onLine() => _wrap(_ptr.onLine);

  String get platform() => _wrap(_ptr.platform);

  String get userAgent() => _wrap(_ptr.userAgent);
}

class _XMLHttpRequestImpl extends _EventTargetImpl implements XMLHttpRequest {
  _XMLHttpRequestImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  bool get asBlob() => _wrap(_ptr.asBlob);

  void set asBlob(bool value) { _ptr.asBlob = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  Object get response() => _wrap(_ptr.response);

  Blob get responseBlob() => _wrap(_ptr.responseBlob);

  String get responseText() => _wrap(_ptr.responseText);

  String get responseType() => _wrap(_ptr.responseType);

  void set responseType(String value) { _ptr.responseType = _unwrap(value); }

  Document get responseXML() => _wrap(_ptr.responseXML);

  int get status() => _wrap(_ptr.status);

  String get statusText() => _wrap(_ptr.statusText);

  XMLHttpRequestUpload get upload() => _wrap(_ptr.upload);

  bool get withCredentials() => _wrap(_ptr.withCredentials);

  void set withCredentials(bool value) { _ptr.withCredentials = _unwrap(value); }

  void abort() => _ptr.abort();

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  String getAllResponseHeaders() => _wrap(_ptr.getAllResponseHeaders());

  String getResponseHeader(String header) => _wrap(_ptr.getResponseHeader(_unwrap(header)));

  void open(String method, String url, [bool async = null, String user = null, String password = null]) => _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async), _unwrap(user), _unwrap(password));

  void overrideMimeType(String override) => _ptr.overrideMimeType(_unwrap(override));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  void send([data = null]) => _ptr.send(_unwrap(data));

  void setRequestHeader(String header, String value) => _ptr.setRequestHeader(_unwrap(header), _unwrap(value));
}

class _XMLHttpRequestExceptionImpl extends _DOMTypeBase implements XMLHttpRequestException {
  _XMLHttpRequestExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _XMLHttpRequestProgressEventImpl extends _ProgressEventImpl implements XMLHttpRequestProgressEvent {
  _XMLHttpRequestProgressEventImpl._wrap(ptr) : super._wrap(ptr);

  int get position() => _wrap(_ptr.position);

  int get totalSize() => _wrap(_ptr.totalSize);
}

class _XMLHttpRequestUploadImpl extends _EventTargetImpl implements XMLHttpRequestUpload {
  _XMLHttpRequestUploadImpl._wrap(ptr) : super._wrap(ptr);

  Events get on() => _ptr.on;

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));

  bool $dom_dispatchEvent(Event evt) => _wrap(_ptr.$dom_dispatchEvent(_unwrap(evt)));

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) => _ptr.$dom_removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
}

class _XMLSerializerImpl extends _DOMTypeBase implements XMLSerializer {
  _XMLSerializerImpl._wrap(ptr) : super._wrap(ptr);

  String serializeToString(Node node) => _wrap(_ptr.serializeToString(_unwrap(node)));
}

class _XPathEvaluatorImpl extends _DOMTypeBase implements XPathEvaluator {
  _XPathEvaluatorImpl._wrap(ptr) : super._wrap(ptr);

  XPathExpression createExpression(String expression, XPathNSResolver resolver) => _wrap(_ptr.createExpression(_unwrap(expression), _unwrap(resolver)));

  XPathNSResolver createNSResolver(Node nodeResolver) => _wrap(_ptr.createNSResolver(_unwrap(nodeResolver)));

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) => _wrap(_ptr.evaluate(_unwrap(expression), _unwrap(contextNode), _unwrap(resolver), _unwrap(type), _unwrap(inResult)));
}

class _XPathExceptionImpl extends _DOMTypeBase implements XPathException {
  _XPathExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() => _wrap(_ptr.toString());
}

class _XPathExpressionImpl extends _DOMTypeBase implements XPathExpression {
  _XPathExpressionImpl._wrap(ptr) : super._wrap(ptr);

  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) => _wrap(_ptr.evaluate(_unwrap(contextNode), _unwrap(type), _unwrap(inResult)));
}

class _XPathNSResolverImpl extends _DOMTypeBase implements XPathNSResolver {
  _XPathNSResolverImpl._wrap(ptr) : super._wrap(ptr);

  String lookupNamespaceURI(String prefix) => _wrap(_ptr.lookupNamespaceURI(_unwrap(prefix)));
}

class _XPathResultImpl extends _DOMTypeBase implements XPathResult {
  _XPathResultImpl._wrap(ptr) : super._wrap(ptr);

  bool get booleanValue() => _wrap(_ptr.booleanValue);

  bool get invalidIteratorState() => _wrap(_ptr.invalidIteratorState);

  num get numberValue() => _wrap(_ptr.numberValue);

  int get resultType() => _wrap(_ptr.resultType);

  Node get singleNodeValue() => _wrap(_ptr.singleNodeValue);

  int get snapshotLength() => _wrap(_ptr.snapshotLength);

  String get stringValue() => _wrap(_ptr.stringValue);

  Node iterateNext() => _wrap(_ptr.iterateNext());

  Node snapshotItem(int index) => _wrap(_ptr.snapshotItem(_unwrap(index)));
}

class _XSLTProcessorImpl extends _DOMTypeBase implements XSLTProcessor {
  _XSLTProcessorImpl._wrap(ptr) : super._wrap(ptr);

  void clearParameters() => _ptr.clearParameters();

  String getParameter(String namespaceURI, String localName) => _wrap(_ptr.getParameter(_unwrap(namespaceURI), _unwrap(localName)));

  void importStylesheet(Node stylesheet) => _ptr.importStylesheet(_unwrap(stylesheet));

  void removeParameter(String namespaceURI, String localName) => _ptr.removeParameter(_unwrap(namespaceURI), _unwrap(localName));

  void reset() => _ptr.reset();

  void setParameter(String namespaceURI, String localName, String value) => _ptr.setParameter(_unwrap(namespaceURI), _unwrap(localName), _unwrap(value));

  Document transformToDocument(Node source) => _wrap(_ptr.transformToDocument(_unwrap(source)));

  DocumentFragment transformToFragment(Node source, Document docVal) => _wrap(_ptr.transformToFragment(_unwrap(source), _unwrap(docVal)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioElementFactoryProvider {
  factory AudioElement([String src = null]) =>
      _wrap(_HTMLAudioElementFactoryProviderImpl.createHTMLAudioElement(_unwrap(src)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CSSMatrixFactoryProvider {
  factory CSSMatrix([String cssValue = null]) =>
      _wrap(_WebKitCSSMatrixFactoryProviderImpl.createWebKitCSSMatrix(_unwrap(cssValue)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMParserFactoryProvider {
  factory DOMParser() =>
      _wrap(_DOMParserFactoryProviderImpl.createDOMParser());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMURLFactoryProvider {
  factory DOMURL() =>
      _wrap(_DOMURLFactoryProviderImpl.createDOMURL());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DeprecatedPeerConnectionFactoryProvider {
  factory DeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback) =>
      _wrap(_DeprecatedPeerConnectionFactoryProviderImpl.createDeprecatedPeerConnection(_unwrap(serverConfiguration), _unwrap(signalingCallback)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventSourceFactoryProvider {
  factory EventSource(String scriptUrl) =>
      _wrap(_EventSourceFactoryProviderImpl.createEventSource(_unwrap(scriptUrl)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderFactoryProvider {
  factory FileReader() =>
      _wrap(_FileReaderFactoryProviderImpl.createFileReader());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderSyncFactoryProvider {
  factory FileReaderSync() =>
      _wrap(_FileReaderSyncFactoryProviderImpl.createFileReaderSync());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IceCandidateFactoryProvider {
  factory IceCandidate(String label, String candidateLine) =>
      _wrap(_IceCandidateFactoryProviderImpl.createIceCandidate(_unwrap(label), _unwrap(candidateLine)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaControllerFactoryProvider {
  factory MediaController() =>
      _wrap(_MediaControllerFactoryProviderImpl.createMediaController());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaStreamFactoryProvider {
  factory MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks) =>
      _wrap(_MediaStreamFactoryProviderImpl.createMediaStream(_unwrap(audioTracks), _unwrap(videoTracks)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MessageChannelFactoryProvider {
  factory MessageChannel() =>
      _wrap(_MessageChannelFactoryProviderImpl.createMessageChannel());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _NotificationFactoryProvider {
  factory Notification(String title, [Map options = null]) =>
      _wrap(_NotificationFactoryProviderImpl.createNotification(_unwrap(title), _unwrap(options)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _OptionElementFactoryProvider {
  factory OptionElement([String data = null, String value = null, bool defaultSelected = null, bool selected = null]) =>
      _wrap(_HTMLOptionElementFactoryProviderImpl.createHTMLOptionElement(_unwrap(data), _unwrap(value), _unwrap(defaultSelected), _unwrap(selected)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _PeerConnection00FactoryProvider {
  factory PeerConnection00(String serverConfiguration, IceCallback iceCallback) =>
      _wrap(_PeerConnection00FactoryProviderImpl.createPeerConnection00(_unwrap(serverConfiguration), _unwrap(iceCallback)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SessionDescriptionFactoryProvider {
  factory SessionDescription(String sdp) =>
      _wrap(_SessionDescriptionFactoryProviderImpl.createSessionDescription(_unwrap(sdp)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ShadowRootFactoryProvider {
  factory ShadowRoot(Element host) =>
      _wrap(_ShadowRootFactoryProviderImpl.createShadowRoot(_unwrap(host)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SharedWorkerFactoryProvider {
  factory SharedWorker(String scriptURL, [String name = null]) =>
      _wrap(_SharedWorkerFactoryProviderImpl.createSharedWorker(_unwrap(scriptURL), _unwrap(name)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarFactoryProvider {
  factory SpeechGrammar() =>
      _wrap(_SpeechGrammarFactoryProviderImpl.createSpeechGrammar());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarListFactoryProvider {
  factory SpeechGrammarList() =>
      _wrap(_SpeechGrammarListFactoryProviderImpl.createSpeechGrammarList());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechRecognitionFactoryProvider {
  factory SpeechRecognition() =>
      _wrap(_SpeechRecognitionFactoryProviderImpl.createSpeechRecognition());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TextTrackCueFactoryProvider {
  factory TextTrackCue(String id, num startTime, num endTime, String text, [String settings = null, bool pauseOnExit = null]) =>
      _wrap(_TextTrackCueFactoryProviderImpl.createTextTrackCue(_unwrap(id), _unwrap(startTime), _unwrap(endTime), _unwrap(text), _unwrap(settings), _unwrap(pauseOnExit)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WorkerFactoryProvider {
  factory Worker(String scriptUrl) =>
      _wrap(_WorkerFactoryProviderImpl.createWorker(_unwrap(scriptUrl)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLHttpRequestFactoryProvider {
  factory XMLHttpRequest() => _wrap(_XMLHttpRequestFactoryProviderImpl.createXMLHttpRequest());

  factory XMLHttpRequest.get(String url,
                                     onSuccess(XMLHttpRequest request)) =>
      _XMLHttpRequestUtils.get(url, onSuccess);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLSerializerFactoryProvider {
  factory XMLSerializer() =>
      _wrap(_XMLSerializerFactoryProviderImpl.createXMLSerializer());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XPathEvaluatorFactoryProvider {
  factory XPathEvaluator() =>
      _wrap(_XPathEvaluatorFactoryProviderImpl.createXPathEvaluator());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XSLTProcessorFactoryProvider {
  factory XSLTProcessor() =>
      _wrap(_XSLTProcessorFactoryProviderImpl.createXSLTProcessor());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AbstractWorker
interface AbstractWorker extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  AbstractWorkerEvents get on();

  /** @domName AbstractWorker.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName AbstractWorker.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName AbstractWorker.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface AbstractWorkerEvents extends Events {

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAnchorElement
interface AnchorElement extends Element default _Elements {

  AnchorElement([String href]);

  /** @domName HTMLAnchorElement.charset */
  String charset;

  /** @domName HTMLAnchorElement.coords */
  String coords;

  /** @domName HTMLAnchorElement.download */
  String download;

  /** @domName HTMLAnchorElement.hash */
  String hash;

  /** @domName HTMLAnchorElement.host */
  String host;

  /** @domName HTMLAnchorElement.hostname */
  String hostname;

  /** @domName HTMLAnchorElement.href */
  String href;

  /** @domName HTMLAnchorElement.hreflang */
  String hreflang;

  /** @domName HTMLAnchorElement.name */
  String name;

  /** @domName HTMLAnchorElement.origin */
  final String origin;

  /** @domName HTMLAnchorElement.pathname */
  String pathname;

  /** @domName HTMLAnchorElement.ping */
  String ping;

  /** @domName HTMLAnchorElement.port */
  String port;

  /** @domName HTMLAnchorElement.protocol */
  String protocol;

  /** @domName HTMLAnchorElement.rel */
  String rel;

  /** @domName HTMLAnchorElement.rev */
  String rev;

  /** @domName HTMLAnchorElement.search */
  String search;

  /** @domName HTMLAnchorElement.shape */
  String shape;

  /** @domName HTMLAnchorElement.target */
  String target;

  /** @domName HTMLAnchorElement.type */
  String type;

  /** @domName HTMLAnchorElement.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimation
interface Animation {

  static final int DIRECTION_ALTERNATE = 1;

  static final int DIRECTION_NORMAL = 0;

  static final int FILL_BACKWARDS = 1;

  static final int FILL_BOTH = 3;

  static final int FILL_FORWARDS = 2;

  static final int FILL_NONE = 0;

  /** @domName WebKitAnimation.delay */
  final num delay;

  /** @domName WebKitAnimation.direction */
  final int direction;

  /** @domName WebKitAnimation.duration */
  final num duration;

  /** @domName WebKitAnimation.elapsedTime */
  num elapsedTime;

  /** @domName WebKitAnimation.ended */
  final bool ended;

  /** @domName WebKitAnimation.fillMode */
  final int fillMode;

  /** @domName WebKitAnimation.iterationCount */
  final int iterationCount;

  /** @domName WebKitAnimation.name */
  final String name;

  /** @domName WebKitAnimation.paused */
  final bool paused;

  /** @domName WebKitAnimation.pause */
  void pause();

  /** @domName WebKitAnimation.play */
  void play();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimationEvent
interface AnimationEvent extends Event {

  /** @domName WebKitAnimationEvent.animationName */
  final String animationName;

  /** @domName WebKitAnimationEvent.elapsedTime */
  final num elapsedTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimationList
interface AnimationList {

  /** @domName WebKitAnimationList.length */
  final int length;

  /** @domName WebKitAnimationList.item */
  Animation item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAppletElement
interface AppletElement extends Element {

  /** @domName HTMLAppletElement.align */
  String align;

  /** @domName HTMLAppletElement.alt */
  String alt;

  /** @domName HTMLAppletElement.archive */
  String archive;

  /** @domName HTMLAppletElement.code */
  String code;

  /** @domName HTMLAppletElement.codeBase */
  String codeBase;

  /** @domName HTMLAppletElement.height */
  String height;

  /** @domName HTMLAppletElement.hspace */
  String hspace;

  /** @domName HTMLAppletElement.name */
  String name;

  /** @domName HTMLAppletElement.object */
  String object;

  /** @domName HTMLAppletElement.vspace */
  String vspace;

  /** @domName HTMLAppletElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAreaElement
interface AreaElement extends Element default _Elements {

  AreaElement();

  /** @domName HTMLAreaElement.alt */
  String alt;

  /** @domName HTMLAreaElement.coords */
  String coords;

  /** @domName HTMLAreaElement.hash */
  final String hash;

  /** @domName HTMLAreaElement.host */
  final String host;

  /** @domName HTMLAreaElement.hostname */
  final String hostname;

  /** @domName HTMLAreaElement.href */
  String href;

  /** @domName HTMLAreaElement.noHref */
  bool noHref;

  /** @domName HTMLAreaElement.pathname */
  final String pathname;

  /** @domName HTMLAreaElement.ping */
  String ping;

  /** @domName HTMLAreaElement.port */
  final String port;

  /** @domName HTMLAreaElement.protocol */
  final String protocol;

  /** @domName HTMLAreaElement.search */
  final String search;

  /** @domName HTMLAreaElement.shape */
  String shape;

  /** @domName HTMLAreaElement.target */
  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ArrayBuffer
interface ArrayBuffer {

  /** @domName ArrayBuffer.byteLength */
  final int byteLength;

  /** @domName ArrayBuffer.slice */
  ArrayBuffer slice(int begin, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ArrayBufferView
interface ArrayBufferView {

  /** @domName ArrayBufferView.buffer */
  final ArrayBuffer buffer;

  /** @domName ArrayBufferView.byteLength */
  final int byteLength;

  /** @domName ArrayBufferView.byteOffset */
  final int byteOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Attr
interface Attr extends Node {

  /** @domName Attr.isId */
  final bool isId;

  /** @domName Attr.name */
  final String name;

  /** @domName Attr.ownerElement */
  final Element ownerElement;

  /** @domName Attr.specified */
  final bool specified;

  /** @domName Attr.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioBuffer
interface AudioBuffer {

  /** @domName AudioBuffer.duration */
  final num duration;

  /** @domName AudioBuffer.gain */
  num gain;

  /** @domName AudioBuffer.length */
  final int length;

  /** @domName AudioBuffer.numberOfChannels */
  final int numberOfChannels;

  /** @domName AudioBuffer.sampleRate */
  final num sampleRate;

  /** @domName AudioBuffer.getChannelData */
  Float32Array getChannelData(int channelIndex);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool AudioBufferCallback(AudioBuffer audioBuffer);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioBufferSourceNode
interface AudioBufferSourceNode extends AudioSourceNode {

  static final int FINISHED_STATE = 3;

  static final int PLAYING_STATE = 2;

  static final int SCHEDULED_STATE = 1;

  static final int UNSCHEDULED_STATE = 0;

  /** @domName AudioBufferSourceNode.buffer */
  AudioBuffer buffer;

  /** @domName AudioBufferSourceNode.gain */
  final AudioGain gain;

  /** @domName AudioBufferSourceNode.loop */
  bool loop;

  /** @domName AudioBufferSourceNode.looping */
  bool looping;

  /** @domName AudioBufferSourceNode.playbackRate */
  final AudioParam playbackRate;

  /** @domName AudioBufferSourceNode.playbackState */
  final int playbackState;

  /** @domName AudioBufferSourceNode.noteGrainOn */
  void noteGrainOn(num when, num grainOffset, num grainDuration);

  /** @domName AudioBufferSourceNode.noteOff */
  void noteOff(num when);

  /** @domName AudioBufferSourceNode.noteOn */
  void noteOn(num when);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioChannelMerger
interface AudioChannelMerger extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioChannelSplitter
interface AudioChannelSplitter extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioContext
interface AudioContext extends EventTarget default _AudioContextFactoryProvider {
  AudioContext();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  AudioContextEvents get on();

  /** @domName AudioContext.activeSourceCount */
  final int activeSourceCount;

  /** @domName AudioContext.currentTime */
  final num currentTime;

  /** @domName AudioContext.destination */
  final AudioDestinationNode destination;

  /** @domName AudioContext.listener */
  final AudioListener listener;

  /** @domName AudioContext.sampleRate */
  final num sampleRate;

  /** @domName AudioContext.createAnalyser */
  RealtimeAnalyserNode createAnalyser();

  /** @domName AudioContext.createBiquadFilter */
  BiquadFilterNode createBiquadFilter();

  /** @domName AudioContext.createBuffer */
  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate]);

  /** @domName AudioContext.createBufferSource */
  AudioBufferSourceNode createBufferSource();

  /** @domName AudioContext.createChannelMerger */
  AudioChannelMerger createChannelMerger([int numberOfInputs]);

  /** @domName AudioContext.createChannelSplitter */
  AudioChannelSplitter createChannelSplitter([int numberOfOutputs]);

  /** @domName AudioContext.createConvolver */
  ConvolverNode createConvolver();

  /** @domName AudioContext.createDelayNode */
  DelayNode createDelayNode([num maxDelayTime]);

  /** @domName AudioContext.createDynamicsCompressor */
  DynamicsCompressorNode createDynamicsCompressor();

  /** @domName AudioContext.createGainNode */
  AudioGainNode createGainNode();

  /** @domName AudioContext.createJavaScriptNode */
  JavaScriptAudioNode createJavaScriptNode(int bufferSize, [int numberOfInputChannels, int numberOfOutputChannels]);

  /** @domName AudioContext.createMediaElementSource */
  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement);

  /** @domName AudioContext.createOscillator */
  Oscillator createOscillator();

  /** @domName AudioContext.createPanner */
  AudioPannerNode createPanner();

  /** @domName AudioContext.createWaveShaper */
  WaveShaperNode createWaveShaper();

  /** @domName AudioContext.createWaveTable */
  WaveTable createWaveTable(Float32Array real, Float32Array imag);

  /** @domName AudioContext.decodeAudioData */
  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]);

  /** @domName AudioContext.startRendering */
  void startRendering();
}

interface AudioContextEvents extends Events {

  EventListenerList get complete();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioDestinationNode
interface AudioDestinationNode extends AudioNode {

  /** @domName AudioDestinationNode.numberOfChannels */
  final int numberOfChannels;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAudioElement
interface AudioElement extends MediaElement default _AudioElementFactoryProvider {

  AudioElement([String src]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioGain
interface AudioGain extends AudioParam {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioGainNode
interface AudioGainNode extends AudioNode {

  /** @domName AudioGainNode.gain */
  final AudioGain gain;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioListener
interface AudioListener {

  /** @domName AudioListener.dopplerFactor */
  num dopplerFactor;

  /** @domName AudioListener.speedOfSound */
  num speedOfSound;

  /** @domName AudioListener.setOrientation */
  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp);

  /** @domName AudioListener.setPosition */
  void setPosition(num x, num y, num z);

  /** @domName AudioListener.setVelocity */
  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioNode
interface AudioNode {

  /** @domName AudioNode.context */
  final AudioContext context;

  /** @domName AudioNode.numberOfInputs */
  final int numberOfInputs;

  /** @domName AudioNode.numberOfOutputs */
  final int numberOfOutputs;

  /** @domName AudioNode.connect */
  void connect(destination, int output, [int input]);

  /** @domName AudioNode.disconnect */
  void disconnect(int output);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioPannerNode
interface AudioPannerNode extends AudioNode {

  static final int EQUALPOWER = 0;

  static final int EXPONENTIAL_DISTANCE = 2;

  static final int HRTF = 1;

  static final int INVERSE_DISTANCE = 1;

  static final int LINEAR_DISTANCE = 0;

  static final int SOUNDFIELD = 2;

  /** @domName AudioPannerNode.coneGain */
  final AudioGain coneGain;

  /** @domName AudioPannerNode.coneInnerAngle */
  num coneInnerAngle;

  /** @domName AudioPannerNode.coneOuterAngle */
  num coneOuterAngle;

  /** @domName AudioPannerNode.coneOuterGain */
  num coneOuterGain;

  /** @domName AudioPannerNode.distanceGain */
  final AudioGain distanceGain;

  /** @domName AudioPannerNode.distanceModel */
  int distanceModel;

  /** @domName AudioPannerNode.maxDistance */
  num maxDistance;

  /** @domName AudioPannerNode.panningModel */
  int panningModel;

  /** @domName AudioPannerNode.refDistance */
  num refDistance;

  /** @domName AudioPannerNode.rolloffFactor */
  num rolloffFactor;

  /** @domName AudioPannerNode.setOrientation */
  void setOrientation(num x, num y, num z);

  /** @domName AudioPannerNode.setPosition */
  void setPosition(num x, num y, num z);

  /** @domName AudioPannerNode.setVelocity */
  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioParam
interface AudioParam {

  /** @domName AudioParam.defaultValue */
  final num defaultValue;

  /** @domName AudioParam.maxValue */
  final num maxValue;

  /** @domName AudioParam.minValue */
  final num minValue;

  /** @domName AudioParam.name */
  final String name;

  /** @domName AudioParam.units */
  final int units;

  /** @domName AudioParam.value */
  num value;

  /** @domName AudioParam.cancelScheduledValues */
  void cancelScheduledValues(num startTime);

  /** @domName AudioParam.exponentialRampToValueAtTime */
  void exponentialRampToValueAtTime(num value, num time);

  /** @domName AudioParam.linearRampToValueAtTime */
  void linearRampToValueAtTime(num value, num time);

  /** @domName AudioParam.setTargetValueAtTime */
  void setTargetValueAtTime(num targetValue, num time, num timeConstant);

  /** @domName AudioParam.setValueAtTime */
  void setValueAtTime(num value, num time);

  /** @domName AudioParam.setValueCurveAtTime */
  void setValueCurveAtTime(Float32Array values, num time, num duration);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioProcessingEvent
interface AudioProcessingEvent extends Event {

  /** @domName AudioProcessingEvent.inputBuffer */
  final AudioBuffer inputBuffer;

  /** @domName AudioProcessingEvent.outputBuffer */
  final AudioBuffer outputBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioSourceNode
interface AudioSourceNode extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBRElement
interface BRElement extends Element default _Elements {

  BRElement();

  /** @domName HTMLBRElement.clear */
  String clear;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BarInfo
interface BarInfo {

  /** @domName BarInfo.visible */
  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBaseElement
interface BaseElement extends Element default _Elements {

  BaseElement();

  /** @domName HTMLBaseElement.href */
  String href;

  /** @domName HTMLBaseElement.target */
  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBaseFontElement
interface BaseFontElement extends Element {

  /** @domName HTMLBaseFontElement.color */
  String color;

  /** @domName HTMLBaseFontElement.face */
  String face;

  /** @domName HTMLBaseFontElement.size */
  int size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BatteryManager
interface BatteryManager extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  BatteryManagerEvents get on();

  /** @domName BatteryManager.charging */
  final bool charging;

  /** @domName BatteryManager.chargingTime */
  final num chargingTime;

  /** @domName BatteryManager.dischargingTime */
  final num dischargingTime;

  /** @domName BatteryManager.level */
  final num level;

  /** @domName BatteryManager.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName BatteryManager.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName BatteryManager.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface BatteryManagerEvents extends Events {

  EventListenerList get chargingChange();

  EventListenerList get chargingTimeChange();

  EventListenerList get dischargingTimeChange();

  EventListenerList get levelChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BeforeLoadEvent
interface BeforeLoadEvent extends Event {

  /** @domName BeforeLoadEvent.url */
  final String url;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BiquadFilterNode
interface BiquadFilterNode extends AudioNode {

  static final int ALLPASS = 7;

  static final int BANDPASS = 2;

  static final int HIGHPASS = 1;

  static final int HIGHSHELF = 4;

  static final int LOWPASS = 0;

  static final int LOWSHELF = 3;

  static final int NOTCH = 6;

  static final int PEAKING = 5;

  /** @domName BiquadFilterNode.Q */
  final AudioParam Q;

  /** @domName BiquadFilterNode.frequency */
  final AudioParam frequency;

  /** @domName BiquadFilterNode.gain */
  final AudioParam gain;

  /** @domName BiquadFilterNode.type */
  int type;

  /** @domName BiquadFilterNode.getFrequencyResponse */
  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Blob
interface Blob {

  /** @domName Blob.size */
  final int size;

  /** @domName Blob.type */
  final String type;

  /** @domName Blob.webkitSlice */
  Blob webkitSlice([int start, int end, String contentType]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBodyElement
interface BodyElement extends Element default _Elements {

  BodyElement();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  BodyElementEvents get on();

  /** @domName HTMLBodyElement.aLink */
  String aLink;

  /** @domName HTMLBodyElement.background */
  String background;

  /** @domName HTMLBodyElement.bgColor */
  String bgColor;

  /** @domName HTMLBodyElement.link */
  String link;

  /** @domName HTMLBodyElement.vLink */
  String vLink;
}

interface BodyElementEvents extends ElementEvents {

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get load();

  EventListenerList get message();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get popState();

  EventListenerList get resize();

  EventListenerList get storage();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLButtonElement
interface ButtonElement extends Element default _Elements {

  ButtonElement();

  /** @domName HTMLButtonElement.autofocus */
  bool autofocus;

  /** @domName HTMLButtonElement.disabled */
  bool disabled;

  /** @domName HTMLButtonElement.form */
  final FormElement form;

  /** @domName HTMLButtonElement.formAction */
  String formAction;

  /** @domName HTMLButtonElement.formEnctype */
  String formEnctype;

  /** @domName HTMLButtonElement.formMethod */
  String formMethod;

  /** @domName HTMLButtonElement.formNoValidate */
  bool formNoValidate;

  /** @domName HTMLButtonElement.formTarget */
  String formTarget;

  /** @domName HTMLButtonElement.labels */
  final NodeList labels;

  /** @domName HTMLButtonElement.name */
  String name;

  /** @domName HTMLButtonElement.type */
  final String type;

  /** @domName HTMLButtonElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLButtonElement.validity */
  final ValidityState validity;

  /** @domName HTMLButtonElement.value */
  String value;

  /** @domName HTMLButtonElement.willValidate */
  final bool willValidate;

  /** @domName HTMLButtonElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLButtonElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CDATASection
interface CDATASection extends Text {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSCharsetRule
interface CSSCharsetRule extends CSSRule {

  /** @domName CSSCharsetRule.encoding */
  String encoding;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSFontFaceRule
interface CSSFontFaceRule extends CSSRule {

  /** @domName CSSFontFaceRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSImportRule
interface CSSImportRule extends CSSRule {

  /** @domName CSSImportRule.href */
  final String href;

  /** @domName CSSImportRule.media */
  final MediaList media;

  /** @domName CSSImportRule.styleSheet */
  final CSSStyleSheet styleSheet;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSKeyframeRule
interface CSSKeyframeRule extends CSSRule {

  /** @domName WebKitCSSKeyframeRule.keyText */
  String keyText;

  /** @domName WebKitCSSKeyframeRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSKeyframesRule
interface CSSKeyframesRule extends CSSRule {

  /** @domName WebKitCSSKeyframesRule.cssRules */
  final CSSRuleList cssRules;

  /** @domName WebKitCSSKeyframesRule.name */
  String name;

  /** @domName WebKitCSSKeyframesRule.deleteRule */
  void deleteRule(String key);

  /** @domName WebKitCSSKeyframesRule.findRule */
  CSSKeyframeRule findRule(String key);

  /** @domName WebKitCSSKeyframesRule.insertRule */
  void insertRule(String rule);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSMatrix
interface CSSMatrix default _CSSMatrixFactoryProvider {

  CSSMatrix([String cssValue]);

  /** @domName WebKitCSSMatrix.a */
  num a;

  /** @domName WebKitCSSMatrix.b */
  num b;

  /** @domName WebKitCSSMatrix.c */
  num c;

  /** @domName WebKitCSSMatrix.d */
  num d;

  /** @domName WebKitCSSMatrix.e */
  num e;

  /** @domName WebKitCSSMatrix.f */
  num f;

  /** @domName WebKitCSSMatrix.m11 */
  num m11;

  /** @domName WebKitCSSMatrix.m12 */
  num m12;

  /** @domName WebKitCSSMatrix.m13 */
  num m13;

  /** @domName WebKitCSSMatrix.m14 */
  num m14;

  /** @domName WebKitCSSMatrix.m21 */
  num m21;

  /** @domName WebKitCSSMatrix.m22 */
  num m22;

  /** @domName WebKitCSSMatrix.m23 */
  num m23;

  /** @domName WebKitCSSMatrix.m24 */
  num m24;

  /** @domName WebKitCSSMatrix.m31 */
  num m31;

  /** @domName WebKitCSSMatrix.m32 */
  num m32;

  /** @domName WebKitCSSMatrix.m33 */
  num m33;

  /** @domName WebKitCSSMatrix.m34 */
  num m34;

  /** @domName WebKitCSSMatrix.m41 */
  num m41;

  /** @domName WebKitCSSMatrix.m42 */
  num m42;

  /** @domName WebKitCSSMatrix.m43 */
  num m43;

  /** @domName WebKitCSSMatrix.m44 */
  num m44;

  /** @domName WebKitCSSMatrix.inverse */
  CSSMatrix inverse();

  /** @domName WebKitCSSMatrix.multiply */
  CSSMatrix multiply(CSSMatrix secondMatrix);

  /** @domName WebKitCSSMatrix.rotate */
  CSSMatrix rotate(num rotX, num rotY, num rotZ);

  /** @domName WebKitCSSMatrix.rotateAxisAngle */
  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle);

  /** @domName WebKitCSSMatrix.scale */
  CSSMatrix scale(num scaleX, num scaleY, num scaleZ);

  /** @domName WebKitCSSMatrix.setMatrixValue */
  void setMatrixValue(String string);

  /** @domName WebKitCSSMatrix.skewX */
  CSSMatrix skewX(num angle);

  /** @domName WebKitCSSMatrix.skewY */
  CSSMatrix skewY(num angle);

  /** @domName WebKitCSSMatrix.toString */
  String toString();

  /** @domName WebKitCSSMatrix.translate */
  CSSMatrix translate(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSMediaRule
interface CSSMediaRule extends CSSRule {

  /** @domName CSSMediaRule.cssRules */
  final CSSRuleList cssRules;

  /** @domName CSSMediaRule.media */
  final MediaList media;

  /** @domName CSSMediaRule.deleteRule */
  void deleteRule(int index);

  /** @domName CSSMediaRule.insertRule */
  int insertRule(String rule, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSPageRule
interface CSSPageRule extends CSSRule {

  /** @domName CSSPageRule.selectorText */
  String selectorText;

  /** @domName CSSPageRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSPrimitiveValue
interface CSSPrimitiveValue extends CSSValue {

  static final int CSS_ATTR = 22;

  static final int CSS_CM = 6;

  static final int CSS_COUNTER = 23;

  static final int CSS_DEG = 11;

  static final int CSS_DIMENSION = 18;

  static final int CSS_EMS = 3;

  static final int CSS_EXS = 4;

  static final int CSS_GRAD = 13;

  static final int CSS_HZ = 16;

  static final int CSS_IDENT = 21;

  static final int CSS_IN = 8;

  static final int CSS_KHZ = 17;

  static final int CSS_MM = 7;

  static final int CSS_MS = 14;

  static final int CSS_NUMBER = 1;

  static final int CSS_PC = 10;

  static final int CSS_PERCENTAGE = 2;

  static final int CSS_PT = 9;

  static final int CSS_PX = 5;

  static final int CSS_RAD = 12;

  static final int CSS_RECT = 24;

  static final int CSS_RGBCOLOR = 25;

  static final int CSS_S = 15;

  static final int CSS_STRING = 19;

  static final int CSS_UNKNOWN = 0;

  static final int CSS_URI = 20;

  static final int CSS_VH = 27;

  static final int CSS_VMIN = 28;

  static final int CSS_VW = 26;

  /** @domName CSSPrimitiveValue.primitiveType */
  final int primitiveType;

  /** @domName CSSPrimitiveValue.getCounterValue */
  Counter getCounterValue();

  /** @domName CSSPrimitiveValue.getFloatValue */
  num getFloatValue(int unitType);

  /** @domName CSSPrimitiveValue.getRGBColorValue */
  RGBColor getRGBColorValue();

  /** @domName CSSPrimitiveValue.getRectValue */
  Rect getRectValue();

  /** @domName CSSPrimitiveValue.getStringValue */
  String getStringValue();

  /** @domName CSSPrimitiveValue.setFloatValue */
  void setFloatValue(int unitType, num floatValue);

  /** @domName CSSPrimitiveValue.setStringValue */
  void setStringValue(int stringType, String stringValue);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSRule
interface CSSRule {

  static final int CHARSET_RULE = 2;

  static final int FONT_FACE_RULE = 5;

  static final int IMPORT_RULE = 3;

  static final int MEDIA_RULE = 4;

  static final int PAGE_RULE = 6;

  static final int STYLE_RULE = 1;

  static final int UNKNOWN_RULE = 0;

  static final int WEBKIT_KEYFRAMES_RULE = 7;

  static final int WEBKIT_KEYFRAME_RULE = 8;

  static final int WEBKIT_REGION_RULE = 10;

  /** @domName CSSRule.cssText */
  String cssText;

  /** @domName CSSRule.parentRule */
  final CSSRule parentRule;

  /** @domName CSSRule.parentStyleSheet */
  final CSSStyleSheet parentStyleSheet;

  /** @domName CSSRule.type */
  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSRuleList
interface CSSRuleList {

  /** @domName CSSRuleList.length */
  final int length;

  /** @domName CSSRuleList.item */
  CSSRule item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleDeclaration
interface CSSStyleDeclaration default _CSSStyleDeclarationFactoryProvider {
  CSSStyleDeclaration();
  CSSStyleDeclaration.css(String css);


  /** @domName CSSStyleDeclaration.cssText */
  String cssText;

  /** @domName CSSStyleDeclaration.length */
  final int length;

  /** @domName CSSStyleDeclaration.parentRule */
  final CSSRule parentRule;

  /** @domName CSSStyleDeclaration.getPropertyCSSValue */
  CSSValue getPropertyCSSValue(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyPriority */
  String getPropertyPriority(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyShorthand */
  String getPropertyShorthand(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyValue */
  String getPropertyValue(String propertyName);

  /** @domName CSSStyleDeclaration.isPropertyImplicit */
  bool isPropertyImplicit(String propertyName);

  /** @domName CSSStyleDeclaration.item */
  String item(int index);

  /** @domName CSSStyleDeclaration.removeProperty */
  String removeProperty(String propertyName);

  /** @domName CSSStyleDeclaration.setProperty */
  void setProperty(String propertyName, String value, [String priority]);


  /** Gets the value of "animation" */
  String get animation();

  /** Sets the value of "animation" */
  void set animation(var value);

  /** Gets the value of "animation-delay" */
  String get animationDelay();

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value);

  /** Gets the value of "animation-direction" */
  String get animationDirection();

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value);

  /** Gets the value of "animation-duration" */
  String get animationDuration();

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value);

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode();

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value);

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount();

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value);

  /** Gets the value of "animation-name" */
  String get animationName();

  /** Sets the value of "animation-name" */
  void set animationName(var value);

  /** Gets the value of "animation-play-state" */
  String get animationPlayState();

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value);

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction();

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value);

  /** Gets the value of "appearance" */
  String get appearance();

  /** Sets the value of "appearance" */
  void set appearance(var value);

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility();

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value);

  /** Gets the value of "background" */
  String get background();

  /** Sets the value of "background" */
  void set background(var value);

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment();

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value);

  /** Gets the value of "background-clip" */
  String get backgroundClip();

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value);

  /** Gets the value of "background-color" */
  String get backgroundColor();

  /** Sets the value of "background-color" */
  void set backgroundColor(var value);

  /** Gets the value of "background-composite" */
  String get backgroundComposite();

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value);

  /** Gets the value of "background-image" */
  String get backgroundImage();

  /** Sets the value of "background-image" */
  void set backgroundImage(var value);

  /** Gets the value of "background-origin" */
  String get backgroundOrigin();

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value);

  /** Gets the value of "background-position" */
  String get backgroundPosition();

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value);

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX();

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value);

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY();

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value);

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat();

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value);

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX();

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value);

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY();

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value);

  /** Gets the value of "background-size" */
  String get backgroundSize();

  /** Sets the value of "background-size" */
  void set backgroundSize(var value);

  /** Gets the value of "border" */
  String get border();

  /** Sets the value of "border" */
  void set border(var value);

  /** Gets the value of "border-after" */
  String get borderAfter();

  /** Sets the value of "border-after" */
  void set borderAfter(var value);

  /** Gets the value of "border-after-color" */
  String get borderAfterColor();

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value);

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle();

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value);

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth();

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value);

  /** Gets the value of "border-before" */
  String get borderBefore();

  /** Sets the value of "border-before" */
  void set borderBefore(var value);

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor();

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value);

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle();

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value);

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth();

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value);

  /** Gets the value of "border-bottom" */
  String get borderBottom();

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value);

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor();

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value);

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius();

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value);

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius();

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value);

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle();

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value);

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth();

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value);

  /** Gets the value of "border-collapse" */
  String get borderCollapse();

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value);

  /** Gets the value of "border-color" */
  String get borderColor();

  /** Sets the value of "border-color" */
  void set borderColor(var value);

  /** Gets the value of "border-end" */
  String get borderEnd();

  /** Sets the value of "border-end" */
  void set borderEnd(var value);

  /** Gets the value of "border-end-color" */
  String get borderEndColor();

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value);

  /** Gets the value of "border-end-style" */
  String get borderEndStyle();

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value);

  /** Gets the value of "border-end-width" */
  String get borderEndWidth();

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value);

  /** Gets the value of "border-fit" */
  String get borderFit();

  /** Sets the value of "border-fit" */
  void set borderFit(var value);

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing();

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value);

  /** Gets the value of "border-image" */
  String get borderImage();

  /** Sets the value of "border-image" */
  void set borderImage(var value);

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset();

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value);

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat();

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value);

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice();

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value);

  /** Gets the value of "border-image-source" */
  String get borderImageSource();

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value);

  /** Gets the value of "border-image-width" */
  String get borderImageWidth();

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value);

  /** Gets the value of "border-left" */
  String get borderLeft();

  /** Sets the value of "border-left" */
  void set borderLeft(var value);

  /** Gets the value of "border-left-color" */
  String get borderLeftColor();

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value);

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle();

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value);

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth();

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value);

  /** Gets the value of "border-radius" */
  String get borderRadius();

  /** Sets the value of "border-radius" */
  void set borderRadius(var value);

  /** Gets the value of "border-right" */
  String get borderRight();

  /** Sets the value of "border-right" */
  void set borderRight(var value);

  /** Gets the value of "border-right-color" */
  String get borderRightColor();

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value);

  /** Gets the value of "border-right-style" */
  String get borderRightStyle();

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value);

  /** Gets the value of "border-right-width" */
  String get borderRightWidth();

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value);

  /** Gets the value of "border-spacing" */
  String get borderSpacing();

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value);

  /** Gets the value of "border-start" */
  String get borderStart();

  /** Sets the value of "border-start" */
  void set borderStart(var value);

  /** Gets the value of "border-start-color" */
  String get borderStartColor();

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value);

  /** Gets the value of "border-start-style" */
  String get borderStartStyle();

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value);

  /** Gets the value of "border-start-width" */
  String get borderStartWidth();

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value);

  /** Gets the value of "border-style" */
  String get borderStyle();

  /** Sets the value of "border-style" */
  void set borderStyle(var value);

  /** Gets the value of "border-top" */
  String get borderTop();

  /** Sets the value of "border-top" */
  void set borderTop(var value);

  /** Gets the value of "border-top-color" */
  String get borderTopColor();

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value);

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius();

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value);

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius();

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value);

  /** Gets the value of "border-top-style" */
  String get borderTopStyle();

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value);

  /** Gets the value of "border-top-width" */
  String get borderTopWidth();

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value);

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing();

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value);

  /** Gets the value of "border-width" */
  String get borderWidth();

  /** Sets the value of "border-width" */
  void set borderWidth(var value);

  /** Gets the value of "bottom" */
  String get bottom();

  /** Sets the value of "bottom" */
  void set bottom(var value);

  /** Gets the value of "box-align" */
  String get boxAlign();

  /** Sets the value of "box-align" */
  void set boxAlign(var value);

  /** Gets the value of "box-direction" */
  String get boxDirection();

  /** Sets the value of "box-direction" */
  void set boxDirection(var value);

  /** Gets the value of "box-flex" */
  String get boxFlex();

  /** Sets the value of "box-flex" */
  void set boxFlex(var value);

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup();

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value);

  /** Gets the value of "box-lines" */
  String get boxLines();

  /** Sets the value of "box-lines" */
  void set boxLines(var value);

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup();

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value);

  /** Gets the value of "box-orient" */
  String get boxOrient();

  /** Sets the value of "box-orient" */
  void set boxOrient(var value);

  /** Gets the value of "box-pack" */
  String get boxPack();

  /** Sets the value of "box-pack" */
  void set boxPack(var value);

  /** Gets the value of "box-reflect" */
  String get boxReflect();

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value);

  /** Gets the value of "box-shadow" */
  String get boxShadow();

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value);

  /** Gets the value of "box-sizing" */
  String get boxSizing();

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value);

  /** Gets the value of "caption-side" */
  String get captionSide();

  /** Sets the value of "caption-side" */
  void set captionSide(var value);

  /** Gets the value of "clear" */
  String get clear();

  /** Sets the value of "clear" */
  void set clear(var value);

  /** Gets the value of "clip" */
  String get clip();

  /** Sets the value of "clip" */
  void set clip(var value);

  /** Gets the value of "color" */
  String get color();

  /** Sets the value of "color" */
  void set color(var value);

  /** Gets the value of "color-correction" */
  String get colorCorrection();

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value);

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter();

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value);

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore();

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value);

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside();

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value);

  /** Gets the value of "column-count" */
  String get columnCount();

  /** Sets the value of "column-count" */
  void set columnCount(var value);

  /** Gets the value of "column-gap" */
  String get columnGap();

  /** Sets the value of "column-gap" */
  void set columnGap(var value);

  /** Gets the value of "column-rule" */
  String get columnRule();

  /** Sets the value of "column-rule" */
  void set columnRule(var value);

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor();

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value);

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle();

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value);

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth();

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value);

  /** Gets the value of "column-span" */
  String get columnSpan();

  /** Sets the value of "column-span" */
  void set columnSpan(var value);

  /** Gets the value of "column-width" */
  String get columnWidth();

  /** Sets the value of "column-width" */
  void set columnWidth(var value);

  /** Gets the value of "columns" */
  String get columns();

  /** Sets the value of "columns" */
  void set columns(var value);

  /** Gets the value of "content" */
  String get content();

  /** Sets the value of "content" */
  void set content(var value);

  /** Gets the value of "counter-increment" */
  String get counterIncrement();

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value);

  /** Gets the value of "counter-reset" */
  String get counterReset();

  /** Sets the value of "counter-reset" */
  void set counterReset(var value);

  /** Gets the value of "cursor" */
  String get cursor();

  /** Sets the value of "cursor" */
  void set cursor(var value);

  /** Gets the value of "direction" */
  String get direction();

  /** Sets the value of "direction" */
  void set direction(var value);

  /** Gets the value of "display" */
  String get display();

  /** Sets the value of "display" */
  void set display(var value);

  /** Gets the value of "empty-cells" */
  String get emptyCells();

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value);

  /** Gets the value of "filter" */
  String get filter();

  /** Sets the value of "filter" */
  void set filter(var value);

  /** Gets the value of "flex-align" */
  String get flexAlign();

  /** Sets the value of "flex-align" */
  void set flexAlign(var value);

  /** Gets the value of "flex-flow" */
  String get flexFlow();

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value);

  /** Gets the value of "flex-order" */
  String get flexOrder();

  /** Sets the value of "flex-order" */
  void set flexOrder(var value);

  /** Gets the value of "flex-pack" */
  String get flexPack();

  /** Sets the value of "flex-pack" */
  void set flexPack(var value);

  /** Gets the value of "float" */
  String get float();

  /** Sets the value of "float" */
  void set float(var value);

  /** Gets the value of "flow-from" */
  String get flowFrom();

  /** Sets the value of "flow-from" */
  void set flowFrom(var value);

  /** Gets the value of "flow-into" */
  String get flowInto();

  /** Sets the value of "flow-into" */
  void set flowInto(var value);

  /** Gets the value of "font" */
  String get font();

  /** Sets the value of "font" */
  void set font(var value);

  /** Gets the value of "font-family" */
  String get fontFamily();

  /** Sets the value of "font-family" */
  void set fontFamily(var value);

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings();

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value);

  /** Gets the value of "font-size" */
  String get fontSize();

  /** Sets the value of "font-size" */
  void set fontSize(var value);

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta();

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value);

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing();

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value);

  /** Gets the value of "font-stretch" */
  String get fontStretch();

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value);

  /** Gets the value of "font-style" */
  String get fontStyle();

  /** Sets the value of "font-style" */
  void set fontStyle(var value);

  /** Gets the value of "font-variant" */
  String get fontVariant();

  /** Sets the value of "font-variant" */
  void set fontVariant(var value);

  /** Gets the value of "font-weight" */
  String get fontWeight();

  /** Sets the value of "font-weight" */
  void set fontWeight(var value);

  /** Gets the value of "height" */
  String get height();

  /** Sets the value of "height" */
  void set height(var value);

  /** Gets the value of "highlight" */
  String get highlight();

  /** Sets the value of "highlight" */
  void set highlight(var value);

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter();

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value);

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter();

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value);

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore();

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value);

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines();

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value);

  /** Gets the value of "hyphens" */
  String get hyphens();

  /** Sets the value of "hyphens" */
  void set hyphens(var value);

  /** Gets the value of "image-rendering" */
  String get imageRendering();

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value);

  /** Gets the value of "left" */
  String get left();

  /** Sets the value of "left" */
  void set left(var value);

  /** Gets the value of "letter-spacing" */
  String get letterSpacing();

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value);

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain();

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value);

  /** Gets the value of "line-break" */
  String get lineBreak();

  /** Sets the value of "line-break" */
  void set lineBreak(var value);

  /** Gets the value of "line-clamp" */
  String get lineClamp();

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value);

  /** Gets the value of "line-height" */
  String get lineHeight();

  /** Sets the value of "line-height" */
  void set lineHeight(var value);

  /** Gets the value of "list-style" */
  String get listStyle();

  /** Sets the value of "list-style" */
  void set listStyle(var value);

  /** Gets the value of "list-style-image" */
  String get listStyleImage();

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value);

  /** Gets the value of "list-style-position" */
  String get listStylePosition();

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value);

  /** Gets the value of "list-style-type" */
  String get listStyleType();

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value);

  /** Gets the value of "locale" */
  String get locale();

  /** Sets the value of "locale" */
  void set locale(var value);

  /** Gets the value of "logical-height" */
  String get logicalHeight();

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value);

  /** Gets the value of "logical-width" */
  String get logicalWidth();

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value);

  /** Gets the value of "margin" */
  String get margin();

  /** Sets the value of "margin" */
  void set margin(var value);

  /** Gets the value of "margin-after" */
  String get marginAfter();

  /** Sets the value of "margin-after" */
  void set marginAfter(var value);

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse();

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value);

  /** Gets the value of "margin-before" */
  String get marginBefore();

  /** Sets the value of "margin-before" */
  void set marginBefore(var value);

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse();

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value);

  /** Gets the value of "margin-bottom" */
  String get marginBottom();

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value);

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse();

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value);

  /** Gets the value of "margin-collapse" */
  String get marginCollapse();

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value);

  /** Gets the value of "margin-end" */
  String get marginEnd();

  /** Sets the value of "margin-end" */
  void set marginEnd(var value);

  /** Gets the value of "margin-left" */
  String get marginLeft();

  /** Sets the value of "margin-left" */
  void set marginLeft(var value);

  /** Gets the value of "margin-right" */
  String get marginRight();

  /** Sets the value of "margin-right" */
  void set marginRight(var value);

  /** Gets the value of "margin-start" */
  String get marginStart();

  /** Sets the value of "margin-start" */
  void set marginStart(var value);

  /** Gets the value of "margin-top" */
  String get marginTop();

  /** Sets the value of "margin-top" */
  void set marginTop(var value);

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse();

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value);

  /** Gets the value of "marquee" */
  String get marquee();

  /** Sets the value of "marquee" */
  void set marquee(var value);

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection();

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value);

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement();

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value);

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition();

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value);

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed();

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value);

  /** Gets the value of "marquee-style" */
  String get marqueeStyle();

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value);

  /** Gets the value of "mask" */
  String get mask();

  /** Sets the value of "mask" */
  void set mask(var value);

  /** Gets the value of "mask-attachment" */
  String get maskAttachment();

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value);

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage();

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value);

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset();

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value);

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat();

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value);

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice();

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value);

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource();

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value);

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth();

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value);

  /** Gets the value of "mask-clip" */
  String get maskClip();

  /** Sets the value of "mask-clip" */
  void set maskClip(var value);

  /** Gets the value of "mask-composite" */
  String get maskComposite();

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value);

  /** Gets the value of "mask-image" */
  String get maskImage();

  /** Sets the value of "mask-image" */
  void set maskImage(var value);

  /** Gets the value of "mask-origin" */
  String get maskOrigin();

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value);

  /** Gets the value of "mask-position" */
  String get maskPosition();

  /** Sets the value of "mask-position" */
  void set maskPosition(var value);

  /** Gets the value of "mask-position-x" */
  String get maskPositionX();

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value);

  /** Gets the value of "mask-position-y" */
  String get maskPositionY();

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value);

  /** Gets the value of "mask-repeat" */
  String get maskRepeat();

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value);

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX();

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value);

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY();

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value);

  /** Gets the value of "mask-size" */
  String get maskSize();

  /** Sets the value of "mask-size" */
  void set maskSize(var value);

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor();

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value);

  /** Gets the value of "max-height" */
  String get maxHeight();

  /** Sets the value of "max-height" */
  void set maxHeight(var value);

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight();

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value);

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth();

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value);

  /** Gets the value of "max-width" */
  String get maxWidth();

  /** Sets the value of "max-width" */
  void set maxWidth(var value);

  /** Gets the value of "min-height" */
  String get minHeight();

  /** Sets the value of "min-height" */
  void set minHeight(var value);

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight();

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value);

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth();

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value);

  /** Gets the value of "min-width" */
  String get minWidth();

  /** Sets the value of "min-width" */
  void set minWidth(var value);

  /** Gets the value of "nbsp-mode" */
  String get nbspMode();

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value);

  /** Gets the value of "opacity" */
  String get opacity();

  /** Sets the value of "opacity" */
  void set opacity(var value);

  /** Gets the value of "orphans" */
  String get orphans();

  /** Sets the value of "orphans" */
  void set orphans(var value);

  /** Gets the value of "outline" */
  String get outline();

  /** Sets the value of "outline" */
  void set outline(var value);

  /** Gets the value of "outline-color" */
  String get outlineColor();

  /** Sets the value of "outline-color" */
  void set outlineColor(var value);

  /** Gets the value of "outline-offset" */
  String get outlineOffset();

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value);

  /** Gets the value of "outline-style" */
  String get outlineStyle();

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value);

  /** Gets the value of "outline-width" */
  String get outlineWidth();

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value);

  /** Gets the value of "overflow" */
  String get overflow();

  /** Sets the value of "overflow" */
  void set overflow(var value);

  /** Gets the value of "overflow-x" */
  String get overflowX();

  /** Sets the value of "overflow-x" */
  void set overflowX(var value);

  /** Gets the value of "overflow-y" */
  String get overflowY();

  /** Sets the value of "overflow-y" */
  void set overflowY(var value);

  /** Gets the value of "padding" */
  String get padding();

  /** Sets the value of "padding" */
  void set padding(var value);

  /** Gets the value of "padding-after" */
  String get paddingAfter();

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value);

  /** Gets the value of "padding-before" */
  String get paddingBefore();

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value);

  /** Gets the value of "padding-bottom" */
  String get paddingBottom();

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value);

  /** Gets the value of "padding-end" */
  String get paddingEnd();

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value);

  /** Gets the value of "padding-left" */
  String get paddingLeft();

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value);

  /** Gets the value of "padding-right" */
  String get paddingRight();

  /** Sets the value of "padding-right" */
  void set paddingRight(var value);

  /** Gets the value of "padding-start" */
  String get paddingStart();

  /** Sets the value of "padding-start" */
  void set paddingStart(var value);

  /** Gets the value of "padding-top" */
  String get paddingTop();

  /** Sets the value of "padding-top" */
  void set paddingTop(var value);

  /** Gets the value of "page" */
  String get page();

  /** Sets the value of "page" */
  void set page(var value);

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter();

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value);

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore();

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value);

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside();

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value);

  /** Gets the value of "perspective" */
  String get perspective();

  /** Sets the value of "perspective" */
  void set perspective(var value);

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin();

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value);

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX();

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value);

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY();

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value);

  /** Gets the value of "pointer-events" */
  String get pointerEvents();

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value);

  /** Gets the value of "position" */
  String get position();

  /** Sets the value of "position" */
  void set position(var value);

  /** Gets the value of "quotes" */
  String get quotes();

  /** Sets the value of "quotes" */
  void set quotes(var value);

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter();

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value);

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore();

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value);

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside();

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value);

  /** Gets the value of "region-overflow" */
  String get regionOverflow();

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value);

  /** Gets the value of "resize" */
  String get resize();

  /** Sets the value of "resize" */
  void set resize(var value);

  /** Gets the value of "right" */
  String get right();

  /** Sets the value of "right" */
  void set right(var value);

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering();

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value);

  /** Gets the value of "size" */
  String get size();

  /** Sets the value of "size" */
  void set size(var value);

  /** Gets the value of "speak" */
  String get speak();

  /** Sets the value of "speak" */
  void set speak(var value);

  /** Gets the value of "src" */
  String get src();

  /** Sets the value of "src" */
  void set src(var value);

  /** Gets the value of "table-layout" */
  String get tableLayout();

  /** Sets the value of "table-layout" */
  void set tableLayout(var value);

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor();

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value);

  /** Gets the value of "text-align" */
  String get textAlign();

  /** Sets the value of "text-align" */
  void set textAlign(var value);

  /** Gets the value of "text-combine" */
  String get textCombine();

  /** Sets the value of "text-combine" */
  void set textCombine(var value);

  /** Gets the value of "text-decoration" */
  String get textDecoration();

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value);

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect();

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value);

  /** Gets the value of "text-emphasis" */
  String get textEmphasis();

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value);

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor();

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value);

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition();

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value);

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle();

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value);

  /** Gets the value of "text-fill-color" */
  String get textFillColor();

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value);

  /** Gets the value of "text-indent" */
  String get textIndent();

  /** Sets the value of "text-indent" */
  void set textIndent(var value);

  /** Gets the value of "text-line-through" */
  String get textLineThrough();

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value);

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor();

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value);

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode();

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value);

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle();

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value);

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth();

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value);

  /** Gets the value of "text-orientation" */
  String get textOrientation();

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value);

  /** Gets the value of "text-overflow" */
  String get textOverflow();

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value);

  /** Gets the value of "text-overline" */
  String get textOverline();

  /** Sets the value of "text-overline" */
  void set textOverline(var value);

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor();

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value);

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode();

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value);

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle();

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value);

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth();

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value);

  /** Gets the value of "text-rendering" */
  String get textRendering();

  /** Sets the value of "text-rendering" */
  void set textRendering(var value);

  /** Gets the value of "text-security" */
  String get textSecurity();

  /** Sets the value of "text-security" */
  void set textSecurity(var value);

  /** Gets the value of "text-shadow" */
  String get textShadow();

  /** Sets the value of "text-shadow" */
  void set textShadow(var value);

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust();

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value);

  /** Gets the value of "text-stroke" */
  String get textStroke();

  /** Sets the value of "text-stroke" */
  void set textStroke(var value);

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor();

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value);

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth();

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value);

  /** Gets the value of "text-transform" */
  String get textTransform();

  /** Sets the value of "text-transform" */
  void set textTransform(var value);

  /** Gets the value of "text-underline" */
  String get textUnderline();

  /** Sets the value of "text-underline" */
  void set textUnderline(var value);

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor();

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value);

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode();

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value);

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle();

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value);

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth();

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value);

  /** Gets the value of "top" */
  String get top();

  /** Sets the value of "top" */
  void set top(var value);

  /** Gets the value of "transform" */
  String get transform();

  /** Sets the value of "transform" */
  void set transform(var value);

  /** Gets the value of "transform-origin" */
  String get transformOrigin();

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value);

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX();

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value);

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY();

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value);

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ();

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value);

  /** Gets the value of "transform-style" */
  String get transformStyle();

  /** Sets the value of "transform-style" */
  void set transformStyle(var value);

  /** Gets the value of "transition" */
  String get transition();

  /** Sets the value of "transition" */
  void set transition(var value);

  /** Gets the value of "transition-delay" */
  String get transitionDelay();

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value);

  /** Gets the value of "transition-duration" */
  String get transitionDuration();

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value);

  /** Gets the value of "transition-property" */
  String get transitionProperty();

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value);

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction();

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value);

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi();

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value);

  /** Gets the value of "unicode-range" */
  String get unicodeRange();

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value);

  /** Gets the value of "user-drag" */
  String get userDrag();

  /** Sets the value of "user-drag" */
  void set userDrag(var value);

  /** Gets the value of "user-modify" */
  String get userModify();

  /** Sets the value of "user-modify" */
  void set userModify(var value);

  /** Gets the value of "user-select" */
  String get userSelect();

  /** Sets the value of "user-select" */
  void set userSelect(var value);

  /** Gets the value of "vertical-align" */
  String get verticalAlign();

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value);

  /** Gets the value of "visibility" */
  String get visibility();

  /** Sets the value of "visibility" */
  void set visibility(var value);

  /** Gets the value of "white-space" */
  String get whiteSpace();

  /** Sets the value of "white-space" */
  void set whiteSpace(var value);

  /** Gets the value of "widows" */
  String get widows();

  /** Sets the value of "widows" */
  void set widows(var value);

  /** Gets the value of "width" */
  String get width();

  /** Sets the value of "width" */
  void set width(var value);

  /** Gets the value of "word-break" */
  String get wordBreak();

  /** Sets the value of "word-break" */
  void set wordBreak(var value);

  /** Gets the value of "word-spacing" */
  String get wordSpacing();

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value);

  /** Gets the value of "word-wrap" */
  String get wordWrap();

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value);

  /** Gets the value of "wrap-shape" */
  String get wrapShape();

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value);

  /** Gets the value of "writing-mode" */
  String get writingMode();

  /** Sets the value of "writing-mode" */
  void set writingMode(var value);

  /** Gets the value of "z-index" */
  String get zIndex();

  /** Sets the value of "z-index" */
  void set zIndex(var value);

  /** Gets the value of "zoom" */
  String get zoom();

  /** Sets the value of "zoom" */
  void set zoom(var value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleRule
interface CSSStyleRule extends CSSRule {

  /** @domName CSSStyleRule.selectorText */
  String selectorText;

  /** @domName CSSStyleRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleSheet
interface CSSStyleSheet extends StyleSheet {

  /** @domName CSSStyleSheet.cssRules */
  final CSSRuleList cssRules;

  /** @domName CSSStyleSheet.ownerRule */
  final CSSRule ownerRule;

  /** @domName CSSStyleSheet.rules */
  final CSSRuleList rules;

  /** @domName CSSStyleSheet.addRule */
  int addRule(String selector, String style, [int index]);

  /** @domName CSSStyleSheet.deleteRule */
  void deleteRule(int index);

  /** @domName CSSStyleSheet.insertRule */
  int insertRule(String rule, int index);

  /** @domName CSSStyleSheet.removeRule */
  void removeRule(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSTransformValue
interface CSSTransformValue extends CSSValueList {

  static final int CSS_MATRIX = 11;

  static final int CSS_MATRIX3D = 21;

  static final int CSS_PERSPECTIVE = 20;

  static final int CSS_ROTATE = 4;

  static final int CSS_ROTATE3D = 17;

  static final int CSS_ROTATEX = 14;

  static final int CSS_ROTATEY = 15;

  static final int CSS_ROTATEZ = 16;

  static final int CSS_SCALE = 5;

  static final int CSS_SCALE3D = 19;

  static final int CSS_SCALEX = 6;

  static final int CSS_SCALEY = 7;

  static final int CSS_SCALEZ = 18;

  static final int CSS_SKEW = 8;

  static final int CSS_SKEWX = 9;

  static final int CSS_SKEWY = 10;

  static final int CSS_TRANSLATE = 1;

  static final int CSS_TRANSLATE3D = 13;

  static final int CSS_TRANSLATEX = 2;

  static final int CSS_TRANSLATEY = 3;

  static final int CSS_TRANSLATEZ = 12;

  /** @domName WebKitCSSTransformValue.operationType */
  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSUnknownRule
interface CSSUnknownRule extends CSSRule {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSValue
interface CSSValue {

  static final int CSS_CUSTOM = 3;

  static final int CSS_INHERIT = 0;

  static final int CSS_PRIMITIVE_VALUE = 1;

  static final int CSS_VALUE_LIST = 2;

  /** @domName CSSValue.cssText */
  String cssText;

  /** @domName CSSValue.cssValueType */
  final int cssValueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSValueList
interface CSSValueList extends CSSValue {

  /** @domName CSSValueList.length */
  final int length;

  /** @domName CSSValueList.item */
  CSSValue item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLCanvasElement
interface CanvasElement extends Element default _Elements {

  CanvasElement([int height, int width]);

  /** @domName HTMLCanvasElement.height */
  int height;

  /** @domName HTMLCanvasElement.width */
  int width;

  /** @domName HTMLCanvasElement.getContext */
  Object getContext(String contextId);

  /** @domName HTMLCanvasElement.toDataURL */
  String toDataURL(String type);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasGradient
interface CanvasGradient {

  /** @domName CanvasGradient.addColorStop */
  void addColorStop(num offset, String color);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasPattern
interface CanvasPattern {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasRenderingContext
interface CanvasRenderingContext {

  /** @domName CanvasRenderingContext.canvas */
  final CanvasElement canvas;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasRenderingContext2D
interface CanvasRenderingContext2D extends CanvasRenderingContext {

  /** @domName CanvasRenderingContext2D.fillStyle */
  Dynamic fillStyle;

  /** @domName CanvasRenderingContext2D.font */
  String font;

  /** @domName CanvasRenderingContext2D.globalAlpha */
  num globalAlpha;

  /** @domName CanvasRenderingContext2D.globalCompositeOperation */
  String globalCompositeOperation;

  /** @domName CanvasRenderingContext2D.lineCap */
  String lineCap;

  /** @domName CanvasRenderingContext2D.lineJoin */
  String lineJoin;

  /** @domName CanvasRenderingContext2D.lineWidth */
  num lineWidth;

  /** @domName CanvasRenderingContext2D.miterLimit */
  num miterLimit;

  /** @domName CanvasRenderingContext2D.shadowBlur */
  num shadowBlur;

  /** @domName CanvasRenderingContext2D.shadowColor */
  String shadowColor;

  /** @domName CanvasRenderingContext2D.shadowOffsetX */
  num shadowOffsetX;

  /** @domName CanvasRenderingContext2D.shadowOffsetY */
  num shadowOffsetY;

  /** @domName CanvasRenderingContext2D.strokeStyle */
  Dynamic strokeStyle;

  /** @domName CanvasRenderingContext2D.textAlign */
  String textAlign;

  /** @domName CanvasRenderingContext2D.textBaseline */
  String textBaseline;

  /** @domName CanvasRenderingContext2D.webkitBackingStorePixelRatio */
  final num webkitBackingStorePixelRatio;

  /** @domName CanvasRenderingContext2D.webkitLineDash */
  List webkitLineDash;

  /** @domName CanvasRenderingContext2D.webkitLineDashOffset */
  num webkitLineDashOffset;

  /** @domName CanvasRenderingContext2D.arc */
  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise);

  /** @domName CanvasRenderingContext2D.arcTo */
  void arcTo(num x1, num y1, num x2, num y2, num radius);

  /** @domName CanvasRenderingContext2D.beginPath */
  void beginPath();

  /** @domName CanvasRenderingContext2D.bezierCurveTo */
  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y);

  /** @domName CanvasRenderingContext2D.clearRect */
  void clearRect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.clearShadow */
  void clearShadow();

  /** @domName CanvasRenderingContext2D.clip */
  void clip();

  /** @domName CanvasRenderingContext2D.closePath */
  void closePath();

  /** @domName CanvasRenderingContext2D.createImageData */
  ImageData createImageData(imagedata_OR_sw, [num sh]);

  /** @domName CanvasRenderingContext2D.createLinearGradient */
  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1);

  /** @domName CanvasRenderingContext2D.createPattern */
  CanvasPattern createPattern(canvas_OR_image, String repetitionType);

  /** @domName CanvasRenderingContext2D.createRadialGradient */
  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1);

  /** @domName CanvasRenderingContext2D.drawImage */
  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]);

  /** @domName CanvasRenderingContext2D.drawImageFromRect */
  void drawImageFromRect(ImageElement image, [num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh, String compositeOperation]);

  /** @domName CanvasRenderingContext2D.fill */
  void fill();

  /** @domName CanvasRenderingContext2D.fillRect */
  void fillRect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.fillText */
  void fillText(String text, num x, num y, [num maxWidth]);

  /** @domName CanvasRenderingContext2D.getImageData */
  ImageData getImageData(num sx, num sy, num sw, num sh);

  /** @domName CanvasRenderingContext2D.isPointInPath */
  bool isPointInPath(num x, num y);

  /** @domName CanvasRenderingContext2D.lineTo */
  void lineTo(num x, num y);

  /** @domName CanvasRenderingContext2D.measureText */
  TextMetrics measureText(String text);

  /** @domName CanvasRenderingContext2D.moveTo */
  void moveTo(num x, num y);

  /** @domName CanvasRenderingContext2D.putImageData */
  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);

  /** @domName CanvasRenderingContext2D.quadraticCurveTo */
  void quadraticCurveTo(num cpx, num cpy, num x, num y);

  /** @domName CanvasRenderingContext2D.rect */
  void rect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.restore */
  void restore();

  /** @domName CanvasRenderingContext2D.rotate */
  void rotate(num angle);

  /** @domName CanvasRenderingContext2D.save */
  void save();

  /** @domName CanvasRenderingContext2D.scale */
  void scale(num sx, num sy);

  /** @domName CanvasRenderingContext2D.setAlpha */
  void setAlpha(num alpha);

  /** @domName CanvasRenderingContext2D.setCompositeOperation */
  void setCompositeOperation(String compositeOperation);

  /** @domName CanvasRenderingContext2D.setFillColor */
  void setFillColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setLineCap */
  void setLineCap(String cap);

  /** @domName CanvasRenderingContext2D.setLineJoin */
  void setLineJoin(String join);

  /** @domName CanvasRenderingContext2D.setLineWidth */
  void setLineWidth(num width);

  /** @domName CanvasRenderingContext2D.setMiterLimit */
  void setMiterLimit(num limit);

  /** @domName CanvasRenderingContext2D.setShadow */
  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r, num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setStrokeColor */
  void setStrokeColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setTransform */
  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy);

  /** @domName CanvasRenderingContext2D.stroke */
  void stroke();

  /** @domName CanvasRenderingContext2D.strokeRect */
  void strokeRect(num x, num y, num width, num height, [num lineWidth]);

  /** @domName CanvasRenderingContext2D.strokeText */
  void strokeText(String text, num x, num y, [num maxWidth]);

  /** @domName CanvasRenderingContext2D.transform */
  void transform(num m11, num m12, num m21, num m22, num dx, num dy);

  /** @domName CanvasRenderingContext2D.translate */
  void translate(num tx, num ty);

  /** @domName CanvasRenderingContext2D.webkitGetImageDataHD */
  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh);

  /** @domName CanvasRenderingContext2D.webkitPutImageDataHD */
  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CharacterData
interface CharacterData extends Node {

  /** @domName CharacterData.data */
  String data;

  /** @domName CharacterData.length */
  final int length;

  /** @domName CharacterData.appendData */
  void appendData(String data);

  /** @domName CharacterData.deleteData */
  void deleteData(int offset, int length);

  /** @domName CharacterData.insertData */
  void insertData(int offset, String data);

  /** @domName CharacterData.replaceData */
  void replaceData(int offset, int length, String data);

  /** @domName CharacterData.substringData */
  String substringData(int offset, int length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ClientRect
interface ClientRect {

  /** @domName ClientRect.bottom */
  final num bottom;

  /** @domName ClientRect.height */
  final num height;

  /** @domName ClientRect.left */
  final num left;

  /** @domName ClientRect.right */
  final num right;

  /** @domName ClientRect.top */
  final num top;

  /** @domName ClientRect.width */
  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ClientRectList
interface ClientRectList {

  /** @domName ClientRectList.length */
  final int length;

  /** @domName ClientRectList.item */
  ClientRect item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Clipboard
interface Clipboard {

  /** @domName Clipboard.dropEffect */
  String dropEffect;

  /** @domName Clipboard.effectAllowed */
  String effectAllowed;

  /** @domName Clipboard.files */
  final FileList files;

  /** @domName Clipboard.items */
  final DataTransferItemList items;

  /** @domName Clipboard.types */
  final List types;

  /** @domName Clipboard.clearData */
  void clearData([String type]);

  /** @domName Clipboard.getData */
  String getData(String type);

  /** @domName Clipboard.setData */
  bool setData(String type, String data);

  /** @domName Clipboard.setDragImage */
  void setDragImage(ImageElement image, int x, int y);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CloseEvent
interface CloseEvent extends Event {

  /** @domName CloseEvent.code */
  final int code;

  /** @domName CloseEvent.reason */
  final String reason;

  /** @domName CloseEvent.wasClean */
  final bool wasClean;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Comment
interface Comment extends CharacterData {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CompositionEvent
interface CompositionEvent extends UIEvent {

  /** @domName CompositionEvent.data */
  final String data;

  /** @domName CompositionEvent.initCompositionEvent */
  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Console
interface Console {

  /** @domName Console.memory */
  final MemoryInfo memory;

  /** @domName Console.profiles */
  final List<ScriptProfile> profiles;

  /** @domName Console.assertCondition */
  void assertCondition(bool condition, Object arg);

  /** @domName Console.count */
  void count();

  /** @domName Console.debug */
  void debug(Object arg);

  /** @domName Console.dir */
  void dir();

  /** @domName Console.dirxml */
  void dirxml();

  /** @domName Console.error */
  void error(Object arg);

  /** @domName Console.group */
  void group(Object arg);

  /** @domName Console.groupCollapsed */
  void groupCollapsed(Object arg);

  /** @domName Console.groupEnd */
  void groupEnd();

  /** @domName Console.info */
  void info(Object arg);

  /** @domName Console.log */
  void log(Object arg);

  /** @domName Console.markTimeline */
  void markTimeline();

  /** @domName Console.profile */
  void profile(String title);

  /** @domName Console.profileEnd */
  void profileEnd(String title);

  /** @domName Console.time */
  void time(String title);

  /** @domName Console.timeEnd */
  void timeEnd(String title, Object arg);

  /** @domName Console.timeStamp */
  void timeStamp(Object arg);

  /** @domName Console.trace */
  void trace(Object arg);

  /** @domName Console.warn */
  void warn(Object arg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLContentElement
interface ContentElement extends Element {

  /** @domName HTMLContentElement.select */
  String select;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ConvolverNode
interface ConvolverNode extends AudioNode {

  /** @domName ConvolverNode.buffer */
  AudioBuffer buffer;

  /** @domName ConvolverNode.normalize */
  bool normalize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Coordinates
interface Coordinates {

  /** @domName Coordinates.accuracy */
  final num accuracy;

  /** @domName Coordinates.altitude */
  final num altitude;

  /** @domName Coordinates.altitudeAccuracy */
  final num altitudeAccuracy;

  /** @domName Coordinates.heading */
  final num heading;

  /** @domName Coordinates.latitude */
  final num latitude;

  /** @domName Coordinates.longitude */
  final num longitude;

  /** @domName Coordinates.speed */
  final num speed;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Counter
interface Counter {

  /** @domName Counter.identifier */
  final String identifier;

  /** @domName Counter.listStyle */
  final String listStyle;

  /** @domName Counter.separator */
  final String separator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Crypto
interface Crypto {

  /** @domName Crypto.getRandomValues */
  void getRandomValues(ArrayBufferView array);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CustomEvent
interface CustomEvent extends Event {

  /** @domName CustomEvent.detail */
  final Object detail;

  /** @domName CustomEvent.initCustomEvent */
  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDListElement
interface DListElement extends Element default _Elements {

  DListElement();

  /** @domName HTMLDListElement.compact */
  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMApplicationCache
interface DOMApplicationCache extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DOMApplicationCacheEvents get on();

  static final int CHECKING = 2;

  static final int DOWNLOADING = 3;

  static final int IDLE = 1;

  static final int OBSOLETE = 5;

  static final int UNCACHED = 0;

  static final int UPDATEREADY = 4;

  /** @domName DOMApplicationCache.status */
  final int status;

  /** @domName DOMApplicationCache.abort */
  void abort();

  /** @domName DOMApplicationCache.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMApplicationCache.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName DOMApplicationCache.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMApplicationCache.swapCache */
  void swapCache();

  /** @domName DOMApplicationCache.update */
  void update();
}

interface DOMApplicationCacheEvents extends Events {

  EventListenerList get cached();

  EventListenerList get checking();

  EventListenerList get downloading();

  EventListenerList get error();

  EventListenerList get noUpdate();

  EventListenerList get obsolete();

  EventListenerList get progress();

  EventListenerList get updateReady();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMException
interface DOMException {

  static final int ABORT_ERR = 20;

  static final int DATA_CLONE_ERR = 25;

  static final int DOMSTRING_SIZE_ERR = 2;

  static final int HIERARCHY_REQUEST_ERR = 3;

  static final int INDEX_SIZE_ERR = 1;

  static final int INUSE_ATTRIBUTE_ERR = 10;

  static final int INVALID_ACCESS_ERR = 15;

  static final int INVALID_CHARACTER_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 13;

  static final int INVALID_NODE_TYPE_ERR = 24;

  static final int INVALID_STATE_ERR = 11;

  static final int NAMESPACE_ERR = 14;

  static final int NETWORK_ERR = 19;

  static final int NOT_FOUND_ERR = 8;

  static final int NOT_SUPPORTED_ERR = 9;

  static final int NO_DATA_ALLOWED_ERR = 6;

  static final int NO_MODIFICATION_ALLOWED_ERR = 7;

  static final int QUOTA_EXCEEDED_ERR = 22;

  static final int SECURITY_ERR = 18;

  static final int SYNTAX_ERR = 12;

  static final int TIMEOUT_ERR = 23;

  static final int TYPE_MISMATCH_ERR = 17;

  static final int URL_MISMATCH_ERR = 21;

  static final int VALIDATION_ERR = 16;

  static final int WRONG_DOCUMENT_ERR = 4;

  /** @domName DOMException.code */
  final int code;

  /** @domName DOMException.message */
  final String message;

  /** @domName DOMException.name */
  final String name;

  /** @domName DOMException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFileSystem
interface DOMFileSystem {

  /** @domName DOMFileSystem.name */
  final String name;

  /** @domName DOMFileSystem.root */
  final DirectoryEntry root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFileSystemSync
interface DOMFileSystemSync {

  /** @domName DOMFileSystemSync.name */
  final String name;

  /** @domName DOMFileSystemSync.root */
  final DirectoryEntrySync root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFormData
interface DOMFormData {

  /** @domName DOMFormData.append */
  void append(String name, String value, String filename);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMImplementation
interface DOMImplementation {

  /** @domName DOMImplementation.createCSSStyleSheet */
  CSSStyleSheet createCSSStyleSheet(String title, String media);

  /** @domName DOMImplementation.createDocument */
  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype);

  /** @domName DOMImplementation.createDocumentType */
  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId);

  /** @domName DOMImplementation.createHTMLDocument */
  Document createHTMLDocument(String title);

  /** @domName DOMImplementation.hasFeature */
  bool hasFeature(String feature, String version);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMMimeType
interface DOMMimeType {

  /** @domName DOMMimeType.description */
  final String description;

  /** @domName DOMMimeType.enabledPlugin */
  final DOMPlugin enabledPlugin;

  /** @domName DOMMimeType.suffixes */
  final String suffixes;

  /** @domName DOMMimeType.type */
  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMMimeTypeArray
interface DOMMimeTypeArray {

  /** @domName DOMMimeTypeArray.length */
  final int length;

  /** @domName DOMMimeTypeArray.item */
  DOMMimeType item(int index);

  /** @domName DOMMimeTypeArray.namedItem */
  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMParser
interface DOMParser default _DOMParserFactoryProvider {

  DOMParser();

  /** @domName DOMParser.parseFromString */
  Document parseFromString(String str, String contentType);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMPlugin
interface DOMPlugin {

  /** @domName DOMPlugin.description */
  final String description;

  /** @domName DOMPlugin.filename */
  final String filename;

  /** @domName DOMPlugin.length */
  final int length;

  /** @domName DOMPlugin.name */
  final String name;

  /** @domName DOMPlugin.item */
  DOMMimeType item(int index);

  /** @domName DOMPlugin.namedItem */
  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMPluginArray
interface DOMPluginArray {

  /** @domName DOMPluginArray.length */
  final int length;

  /** @domName DOMPluginArray.item */
  DOMPlugin item(int index);

  /** @domName DOMPluginArray.namedItem */
  DOMPlugin namedItem(String name);

  /** @domName DOMPluginArray.refresh */
  void refresh(bool reload);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMSelection
interface DOMSelection {

  /** @domName DOMSelection.anchorNode */
  final Node anchorNode;

  /** @domName DOMSelection.anchorOffset */
  final int anchorOffset;

  /** @domName DOMSelection.baseNode */
  final Node baseNode;

  /** @domName DOMSelection.baseOffset */
  final int baseOffset;

  /** @domName DOMSelection.extentNode */
  final Node extentNode;

  /** @domName DOMSelection.extentOffset */
  final int extentOffset;

  /** @domName DOMSelection.focusNode */
  final Node focusNode;

  /** @domName DOMSelection.focusOffset */
  final int focusOffset;

  /** @domName DOMSelection.isCollapsed */
  final bool isCollapsed;

  /** @domName DOMSelection.rangeCount */
  final int rangeCount;

  /** @domName DOMSelection.type */
  final String type;

  /** @domName DOMSelection.addRange */
  void addRange(Range range);

  /** @domName DOMSelection.collapse */
  void collapse(Node node, int index);

  /** @domName DOMSelection.collapseToEnd */
  void collapseToEnd();

  /** @domName DOMSelection.collapseToStart */
  void collapseToStart();

  /** @domName DOMSelection.containsNode */
  bool containsNode(Node node, bool allowPartial);

  /** @domName DOMSelection.deleteFromDocument */
  void deleteFromDocument();

  /** @domName DOMSelection.empty */
  void empty();

  /** @domName DOMSelection.extend */
  void extend(Node node, int offset);

  /** @domName DOMSelection.getRangeAt */
  Range getRangeAt(int index);

  /** @domName DOMSelection.modify */
  void modify(String alter, String direction, String granularity);

  /** @domName DOMSelection.removeAllRanges */
  void removeAllRanges();

  /** @domName DOMSelection.selectAllChildren */
  void selectAllChildren(Node node);

  /** @domName DOMSelection.setBaseAndExtent */
  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset);

  /** @domName DOMSelection.setPosition */
  void setPosition(Node node, int offset);

  /** @domName DOMSelection.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMSettableTokenList
interface DOMSettableTokenList extends DOMTokenList {

  /** @domName DOMSettableTokenList.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMStringList
interface DOMStringList extends List<String> {

  /** @domName DOMStringList.length */
  final int length;

  /** @domName DOMStringList.contains */
  bool contains(String string);

  /** @domName DOMStringList.item */
  String item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMStringMap
interface DOMStringMap {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMTokenList
interface DOMTokenList {

  /** @domName DOMTokenList.length */
  final int length;

  /** @domName DOMTokenList.add */
  void add(String token);

  /** @domName DOMTokenList.contains */
  bool contains(String token);

  /** @domName DOMTokenList.item */
  String item(int index);

  /** @domName DOMTokenList.remove */
  void remove(String token);

  /** @domName DOMTokenList.toString */
  String toString();

  /** @domName DOMTokenList.toggle */
  bool toggle(String token);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMURL
interface DOMURL default _DOMURLFactoryProvider {

  DOMURL();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataTransferItem
interface DataTransferItem {

  /** @domName DataTransferItem.kind */
  final String kind;

  /** @domName DataTransferItem.type */
  final String type;

  /** @domName DataTransferItem.getAsFile */
  Blob getAsFile();

  /** @domName DataTransferItem.getAsString */
  void getAsString([StringCallback callback]);

  /** @domName DataTransferItem.webkitGetAsEntry */
  void webkitGetAsEntry([EntryCallback callback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataTransferItemList
interface DataTransferItemList {

  /** @domName DataTransferItemList.length */
  final int length;

  /** @domName DataTransferItemList.add */
  void add(data_OR_file, [String type]);

  /** @domName DataTransferItemList.clear */
  void clear();

  /** @domName DataTransferItemList.item */
  DataTransferItem item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataView
interface DataView extends ArrayBufferView {

  /** @domName DataView.getFloat32 */
  num getFloat32(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getFloat64 */
  num getFloat64(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getInt16 */
  int getInt16(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getInt32 */
  int getInt32(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getInt8 */
  Object getInt8();

  /** @domName DataView.getUint16 */
  int getUint16(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getUint32 */
  int getUint32(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getUint8 */
  Object getUint8();

  /** @domName DataView.setFloat32 */
  void setFloat32(int byteOffset, num value, [bool littleEndian]);

  /** @domName DataView.setFloat64 */
  void setFloat64(int byteOffset, num value, [bool littleEndian]);

  /** @domName DataView.setInt16 */
  void setInt16(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setInt32 */
  void setInt32(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setInt8 */
  void setInt8();

  /** @domName DataView.setUint16 */
  void setUint16(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setUint32 */
  void setUint32(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setUint8 */
  void setUint8();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Database
interface Database {

  /** @domName Database.version */
  final String version;

  /** @domName Database.changeVersion */
  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback, SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  /** @domName Database.readTransaction */
  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  /** @domName Database.transaction */
  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool DatabaseCallback(database);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DatabaseSync
interface DatabaseSync {

  /** @domName DatabaseSync.lastErrorMessage */
  final String lastErrorMessage;

  /** @domName DatabaseSync.version */
  final String version;

  /** @domName DatabaseSync.changeVersion */
  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback]);

  /** @domName DatabaseSync.readTransaction */
  void readTransaction(SQLTransactionSyncCallback callback);

  /** @domName DatabaseSync.transaction */
  void transaction(SQLTransactionSyncCallback callback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DedicatedWorkerContext
interface DedicatedWorkerContext extends WorkerContext {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DedicatedWorkerContextEvents get on();

  /** @domName DedicatedWorkerContext.postMessage */
  void postMessage(Object message, [List messagePorts]);

  /** @domName DedicatedWorkerContext.webkitPostMessage */
  void webkitPostMessage(Object message, [List transferList]);
}

interface DedicatedWorkerContextEvents extends WorkerContextEvents {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DelayNode
interface DelayNode extends AudioNode {

  /** @domName DelayNode.delayTime */
  final AudioParam delayTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeprecatedPeerConnection
interface DeprecatedPeerConnection extends EventTarget default _DeprecatedPeerConnectionFactoryProvider {

  DeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DeprecatedPeerConnectionEvents get on();

  static final int ACTIVE = 2;

  static final int CLOSED = 3;

  static final int NEGOTIATING = 1;

  static final int NEW = 0;

  /** @domName DeprecatedPeerConnection.localStreams */
  final MediaStreamList localStreams;

  /** @domName DeprecatedPeerConnection.readyState */
  final int readyState;

  /** @domName DeprecatedPeerConnection.remoteStreams */
  final MediaStreamList remoteStreams;

  /** @domName DeprecatedPeerConnection.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DeprecatedPeerConnection.addStream */
  void addStream(MediaStream stream);

  /** @domName DeprecatedPeerConnection.close */
  void close();

  /** @domName DeprecatedPeerConnection.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName DeprecatedPeerConnection.processSignalingMessage */
  void processSignalingMessage(String message);

  /** @domName DeprecatedPeerConnection.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DeprecatedPeerConnection.removeStream */
  void removeStream(MediaStream stream);

  /** @domName DeprecatedPeerConnection.send */
  void send(String text);
}

interface DeprecatedPeerConnectionEvents extends Events {

  EventListenerList get addStream();

  EventListenerList get connecting();

  EventListenerList get message();

  EventListenerList get open();

  EventListenerList get removeStream();

  EventListenerList get stateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDetailsElement
interface DetailsElement extends Element default _Elements {

  DetailsElement();

  /** @domName HTMLDetailsElement.open */
  bool open;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeviceMotionEvent
interface DeviceMotionEvent extends Event {

  /** @domName DeviceMotionEvent.interval */
  final num interval;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeviceOrientationEvent
interface DeviceOrientationEvent extends Event {

  /** @domName DeviceOrientationEvent.absolute */
  final bool absolute;

  /** @domName DeviceOrientationEvent.alpha */
  final num alpha;

  /** @domName DeviceOrientationEvent.beta */
  final num beta;

  /** @domName DeviceOrientationEvent.gamma */
  final num gamma;

  /** @domName DeviceOrientationEvent.initDeviceOrientationEvent */
  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDirectoryElement
interface DirectoryElement extends Element {

  /** @domName HTMLDirectoryElement.compact */
  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryEntry
interface DirectoryEntry extends Entry {

  /** @domName DirectoryEntry.createReader */
  DirectoryReader createReader();

  /** @domName DirectoryEntry.getDirectory */
  void getDirectory(String path, [Object flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName DirectoryEntry.getFile */
  void getFile(String path, [Object flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName DirectoryEntry.removeRecursively */
  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryEntrySync
interface DirectoryEntrySync extends EntrySync {

  /** @domName DirectoryEntrySync.createReader */
  DirectoryReaderSync createReader();

  /** @domName DirectoryEntrySync.getDirectory */
  DirectoryEntrySync getDirectory(String path, Object flags);

  /** @domName DirectoryEntrySync.getFile */
  FileEntrySync getFile(String path, Object flags);

  /** @domName DirectoryEntrySync.removeRecursively */
  void removeRecursively();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryReader
interface DirectoryReader {

  /** @domName DirectoryReader.readEntries */
  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryReaderSync
interface DirectoryReaderSync {

  /** @domName DirectoryReaderSync.readEntries */
  EntryArraySync readEntries();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDivElement
interface DivElement extends Element default _Elements {

  DivElement();

  /** @domName HTMLDivElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName Document
interface Document extends HtmlElement {


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DocumentEvents get on();

  /** @domName HTMLDocument.activeElement */
  final Element activeElement;

  /** @domName Document.body */
  Element body;

  /** @domName Document.charset */
  String charset;

  /** @domName Document.cookie */
  String cookie;

  /** @domName Document.defaultView */
  final Window window;

  /** @domName Document.documentElement */
  final Element documentElement;

  /** @domName Document.domain */
  final String domain;

  /** @domName Document.head */
  final HeadElement head;

  /** @domName Document.lastModified */
  final String lastModified;

  /** @domName Document.preferredStylesheetSet */
  final String preferredStylesheetSet;

  /** @domName Document.readyState */
  final String readyState;

  /** @domName Document.referrer */
  final String referrer;

  /** @domName Document.selectedStylesheetSet */
  String selectedStylesheetSet;

  /** @domName Document.styleSheets */
  final StyleSheetList styleSheets;

  /** @domName Document.title */
  String title;

  /** @domName Document.webkitCurrentFullScreenElement */
  final Element webkitCurrentFullScreenElement;

  /** @domName Document.webkitFullScreenKeyboardInputAllowed */
  final bool webkitFullScreenKeyboardInputAllowed;

  /** @domName Document.webkitFullscreenElement */
  final Element webkitFullscreenElement;

  /** @domName Document.webkitFullscreenEnabled */
  final bool webkitFullscreenEnabled;

  /** @domName Document.webkitHidden */
  final bool webkitHidden;

  /** @domName Document.webkitIsFullScreen */
  final bool webkitIsFullScreen;

  /** @domName Document.webkitVisibilityState */
  final String webkitVisibilityState;

  /** @domName Document.caretRangeFromPoint */
  Range caretRangeFromPoint(int x, int y);

  /** @domName Document.createCDATASection */
  CDATASection createCDATASection(String data);

  /** @domName Document.createDocumentFragment */
  DocumentFragment createDocumentFragment();

  /** @domName Document.createElement */
  Element $dom_createElement(String tagName);

  /** @domName Document.createElementNS */
  Element $dom_createElementNS(String namespaceURI, String qualifiedName);

  /** @domName Document.createEvent */
  Event $dom_createEvent(String eventType);

  /** @domName Document.createRange */
  Range createRange();

  /** @domName Document.createTextNode */
  Text $dom_createTextNode(String data);

  /** @domName Document.createTouch */
  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce);

  /** @domName Document.createTouchList */
  TouchList $dom_createTouchList();

  /** @domName Document.elementFromPoint */
  Element elementFromPoint(int x, int y);

  /** @domName Document.execCommand */
  bool execCommand(String command, bool userInterface, String value);

  /** @domName Document.getCSSCanvasContext */
  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height);

  /** @domName Document.getElementById */
  Element $dom_getElementById(String elementId);

  /** @domName Document.getElementsByClassName */
  NodeList $dom_getElementsByClassName(String tagname);

  /** @domName Document.getElementsByName */
  NodeList $dom_getElementsByName(String elementName);

  /** @domName Document.getElementsByTagName */
  NodeList $dom_getElementsByTagName(String tagname);

  /** @domName Document.queryCommandEnabled */
  bool queryCommandEnabled(String command);

  /** @domName Document.queryCommandIndeterm */
  bool queryCommandIndeterm(String command);

  /** @domName Document.queryCommandState */
  bool queryCommandState(String command);

  /** @domName Document.queryCommandSupported */
  bool queryCommandSupported(String command);

  /** @domName Document.queryCommandValue */
  String queryCommandValue(String command);

  /** @domName Document.querySelector */
  Element query(String selectors);

  /** @domName Document.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

  /** @domName Document.webkitCancelFullScreen */
  void webkitCancelFullScreen();

  /** @domName Document.webkitExitFullscreen */
  void webkitExitFullscreen();

  /** @domName Document.webkitGetFlowByName */
  WebKitNamedFlow webkitGetFlowByName(String name);

}

interface DocumentEvents extends ElementEvents {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get fullscreenChange();

  EventListenerList get fullscreenError();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get readyStateChange();

  EventListenerList get reset();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get selectionChange();

  EventListenerList get submit();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchMove();

  EventListenerList get touchStart();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName DocumentFragment
interface DocumentFragment extends Element default _DocumentFragmentFactoryProvider {

  DocumentFragment();

  DocumentFragment.html(String html);

  // TODO(nweiz): enable this when XML is ported
  // /** WARNING: Currently this doesn't work on Dartium (issue 649). */
  // DocumentFragment.xml(String xml);

  DocumentFragment.svg(String svg);

  DocumentFragment clone(bool deep);


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ElementEvents get on();

  /** @domName DocumentFragment.querySelector */
  Element query(String selectors);

  /** @domName DocumentFragment.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DocumentType
interface DocumentType extends Node {

  /** @domName DocumentType.entities */
  final NamedNodeMap entities;

  /** @domName DocumentType.internalSubset */
  final String internalSubset;

  /** @domName DocumentType.name */
  final String name;

  /** @domName DocumentType.notations */
  final NamedNodeMap notations;

  /** @domName DocumentType.publicId */
  final String publicId;

  /** @domName DocumentType.systemId */
  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DynamicsCompressorNode
interface DynamicsCompressorNode extends AudioNode {

  /** @domName DynamicsCompressorNode.attack */
  final AudioParam attack;

  /** @domName DynamicsCompressorNode.knee */
  final AudioParam knee;

  /** @domName DynamicsCompressorNode.ratio */
  final AudioParam ratio;

  /** @domName DynamicsCompressorNode.reduction */
  final AudioParam reduction;

  /** @domName DynamicsCompressorNode.release */
  final AudioParam release;

  /** @domName DynamicsCompressorNode.threshold */
  final AudioParam threshold;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EXTTextureFilterAnisotropic
interface EXTTextureFilterAnisotropic {

  static final int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  static final int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ElementList extends List<Element> {
  // TODO(jacobr): add element batch manipulation methods.
  ElementList filter(bool f(Element element));

  ElementList getRange(int start, int length);

  Element get first();
  // TODO(jacobr): add insertAt
}

/**
 * All your attribute manipulation needs in one place.
 * Extends the regular Map interface by automatically coercing non-string
 * values to strings.
 */
interface AttributeMap extends Map<String, String> {
  void operator []=(String key, value);
}

/**
 * All your element measurement needs in one place
 */
interface ElementRect {
  // Relative to offsetParent
  ClientRect get client();
  ClientRect get offset();
  ClientRect get scroll();
  // In global coords
  ClientRect get bounding();
  // In global coords
  List<ClientRect> get clientRects();
}

/// @domName Element
interface Element extends Node, NodeSelector default _ElementFactoryProvider {
// TODO(jacobr): switch back to:
// interface Element extends Node, NodeSelector, ElementTraversal default _ElementImpl {
  Element.html(String html);
  Element.tag(String tag);

  AttributeMap get attributes();
  void set attributes(Map<String, String> value);

  /**
   * @domName querySelectorAll, getElementsByClassName, getElementsByTagName,
   *   getElementsByTagNameNS
   */
  ElementList queryAll(String selectors);

  /**
   * @domName childElementCount, firstElementChild, lastElementChild,
   *   children, Node.nodes.add
   */
  ElementList get elements();

  void set elements(Collection<Element> value);

  /** @domName className, classList */
  Set<String> get classes();

  void set classes(Collection<String> value);

  AttributeMap get dataAttributes();
  void set dataAttributes(Map<String, String> value);

  /**
   * @domName getClientRects, getBoundingClientRect, clientHeight, clientWidth,
   * clientTop, clientLeft, offsetHeight, offsetWidth, offsetTop, offsetLeft,
   * scrollHeight, scrollWidth, scrollTop, scrollLeft
   */
  Future<ElementRect> get rect();

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> get computedStyle();

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement);

  Element clone(bool deep);

  Element get parent();


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ElementEvents get on();

  static final int ALLOW_KEYBOARD_INPUT = 1;

  /** @domName Element.childElementCount */
  final int $dom_childElementCount;

  /** @domName HTMLElement.children */
  final HTMLCollection $dom_children;

  /** @domName HTMLElement.className */
  String $dom_className;

  /** @domName Element.clientHeight */
  final int $dom_clientHeight;

  /** @domName Element.clientLeft */
  final int $dom_clientLeft;

  /** @domName Element.clientTop */
  final int $dom_clientTop;

  /** @domName Element.clientWidth */
  final int $dom_clientWidth;

  /** @domName HTMLElement.contentEditable */
  String contentEditable;

  /** @domName Element.dataset */
  final Map<String, String> dataset;

  /** @domName HTMLElement.dir */
  String dir;

  /** @domName HTMLElement.draggable */
  bool draggable;

  /** @domName Element.firstElementChild */
  final Element $dom_firstElementChild;

  /** @domName HTMLElement.hidden */
  bool hidden;

  /** @domName HTMLElement.id */
  String id;

  /** @domName HTMLElement.innerHTML */
  String innerHTML;

  /** @domName HTMLElement.isContentEditable */
  final bool isContentEditable;

  /** @domName HTMLElement.lang */
  String lang;

  /** @domName Element.lastElementChild */
  final Element $dom_lastElementChild;

  /** @domName Element.nextElementSibling */
  final Element nextElementSibling;

  /** @domName Element.offsetHeight */
  final int $dom_offsetHeight;

  /** @domName Element.offsetLeft */
  final int $dom_offsetLeft;

  /** @domName Element.offsetParent */
  final Element offsetParent;

  /** @domName Element.offsetTop */
  final int $dom_offsetTop;

  /** @domName Element.offsetWidth */
  final int $dom_offsetWidth;

  /** @domName HTMLElement.outerHTML */
  final String outerHTML;

  /** @domName Element.previousElementSibling */
  final Element previousElementSibling;

  /** @domName Element.scrollHeight */
  final int $dom_scrollHeight;

  /** @domName Element.scrollLeft */
  int $dom_scrollLeft;

  /** @domName Element.scrollTop */
  int $dom_scrollTop;

  /** @domName Element.scrollWidth */
  final int $dom_scrollWidth;

  /** @domName HTMLElement.spellcheck */
  bool spellcheck;

  /** @domName Element.style */
  final CSSStyleDeclaration style;

  /** @domName HTMLElement.tabIndex */
  int tabIndex;

  /** @domName Element.tagName */
  final String tagName;

  /** @domName HTMLElement.title */
  String title;

  /** @domName HTMLElement.translate */
  bool translate;

  /** @domName Element.webkitRegionOverflow */
  final String webkitRegionOverflow;

  /** @domName HTMLElement.webkitdropzone */
  String webkitdropzone;

  /** @domName Element.blur */
  void blur();

  /** @domName HTMLElement.click */
  void click();

  /** @domName Element.focus */
  void focus();

  /** @domName Element.getAttribute */
  String $dom_getAttribute(String name);

  /** @domName Element.getBoundingClientRect */
  ClientRect $dom_getBoundingClientRect();

  /** @domName Element.getClientRects */
  ClientRectList $dom_getClientRects();

  /** @domName Element.getElementsByClassName */
  NodeList $dom_getElementsByClassName(String name);

  /** @domName Element.getElementsByTagName */
  NodeList $dom_getElementsByTagName(String name);

  /** @domName Element.hasAttribute */
  bool $dom_hasAttribute(String name);

  /** @domName HTMLElement.insertAdjacentElement */
  Element insertAdjacentElement(String where, Element element);

  /** @domName HTMLElement.insertAdjacentHTML */
  void insertAdjacentHTML(String where, String html);

  /** @domName HTMLElement.insertAdjacentText */
  void insertAdjacentText(String where, String text);

  /** @domName Element.querySelector */
  Element query(String selectors);

  /** @domName Element.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

  /** @domName Element.removeAttribute */
  void $dom_removeAttribute(String name);

  /** @domName Element.scrollByLines */
  void scrollByLines(int lines);

  /** @domName Element.scrollByPages */
  void scrollByPages(int pages);

  /** @domName Element.scrollIntoViewIfNeeded */
  void scrollIntoView([bool centerIfNeeded]);

  /** @domName Element.setAttribute */
  void $dom_setAttribute(String name, String value);

  /** @domName Element.webkitMatchesSelector */
  bool matchesSelector(String selectors);

  /** @domName Element.webkitRequestFullScreen */
  void webkitRequestFullScreen(int flags);

  /** @domName Element.webkitRequestFullscreen */
  void webkitRequestFullscreen();

}

interface ElementEvents extends Events {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get fullscreenChange();

  EventListenerList get fullscreenError();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get reset();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get submit();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchEnter();

  EventListenerList get touchLeave();

  EventListenerList get touchMove();

  EventListenerList get touchStart();

  EventListenerList get transitionEnd();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ElementTimeControl
interface ElementTimeControl {

  /** @domName ElementTimeControl.beginElement */
  void beginElement();

  /** @domName ElementTimeControl.beginElementAt */
  void beginElementAt(num offset);

  /** @domName ElementTimeControl.endElement */
  void endElement();

  /** @domName ElementTimeControl.endElementAt */
  void endElementAt(num offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ElementTraversal
interface ElementTraversal {

  /** @domName ElementTraversal.childElementCount */
  final int childElementCount;

  /** @domName ElementTraversal.firstElementChild */
  final Element firstElementChild;

  /** @domName ElementTraversal.lastElementChild */
  final Element lastElementChild;

  /** @domName ElementTraversal.nextElementSibling */
  final Element nextElementSibling;

  /** @domName ElementTraversal.previousElementSibling */
  final Element previousElementSibling;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLEmbedElement
interface EmbedElement extends Element default _Elements {

  EmbedElement();

  /** @domName HTMLEmbedElement.align */
  String align;

  /** @domName HTMLEmbedElement.height */
  String height;

  /** @domName HTMLEmbedElement.name */
  String name;

  /** @domName HTMLEmbedElement.src */
  String src;

  /** @domName HTMLEmbedElement.type */
  String type;

  /** @domName HTMLEmbedElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Entity
interface Entity extends Node {

  /** @domName Entity.notationName */
  final String notationName;

  /** @domName Entity.publicId */
  final String publicId;

  /** @domName Entity.systemId */
  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntityReference
interface EntityReference extends Node {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntriesCallback(EntryArray entries);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Entry
interface Entry {

  /** @domName Entry.filesystem */
  final DOMFileSystem filesystem;

  /** @domName Entry.fullPath */
  final String fullPath;

  /** @domName Entry.isDirectory */
  final bool isDirectory;

  /** @domName Entry.isFile */
  final bool isFile;

  /** @domName Entry.name */
  final String name;

  /** @domName Entry.copyTo */
  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.getMetadata */
  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName Entry.getParent */
  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.moveTo */
  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.remove */
  void remove(VoidCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName Entry.toURL */
  String toURL();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntryArray
interface EntryArray {

  /** @domName EntryArray.length */
  final int length;

  /** @domName EntryArray.item */
  Entry item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntryArraySync
interface EntryArraySync {

  /** @domName EntryArraySync.length */
  final int length;

  /** @domName EntryArraySync.item */
  EntrySync item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntryCallback(Entry entry);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntrySync
interface EntrySync {

  /** @domName EntrySync.filesystem */
  final DOMFileSystemSync filesystem;

  /** @domName EntrySync.fullPath */
  final String fullPath;

  /** @domName EntrySync.isDirectory */
  final bool isDirectory;

  /** @domName EntrySync.isFile */
  final bool isFile;

  /** @domName EntrySync.name */
  final String name;

  /** @domName EntrySync.copyTo */
  EntrySync copyTo(DirectoryEntrySync parent, String name);

  /** @domName EntrySync.getMetadata */
  Metadata getMetadata();

  /** @domName EntrySync.getParent */
  EntrySync getParent();

  /** @domName EntrySync.moveTo */
  EntrySync moveTo(DirectoryEntrySync parent, String name);

  /** @domName EntrySync.remove */
  void remove();

  /** @domName EntrySync.toURL */
  String toURL();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool ErrorCallback(FileError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ErrorEvent
interface ErrorEvent extends Event {

  /** @domName ErrorEvent.filename */
  final String filename;

  /** @domName ErrorEvent.lineno */
  final int lineno;

  /** @domName ErrorEvent.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Event
interface Event default _EventFactoryProvider {

  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  Event(String type, [bool canBubble, bool cancelable]);

  static final int AT_TARGET = 2;

  static final int BLUR = 8192;

  static final int BUBBLING_PHASE = 3;

  static final int CAPTURING_PHASE = 1;

  static final int CHANGE = 32768;

  static final int CLICK = 64;

  static final int DBLCLICK = 128;

  static final int DRAGDROP = 2048;

  static final int FOCUS = 4096;

  static final int KEYDOWN = 256;

  static final int KEYPRESS = 1024;

  static final int KEYUP = 512;

  static final int MOUSEDOWN = 1;

  static final int MOUSEDRAG = 32;

  static final int MOUSEMOVE = 16;

  static final int MOUSEOUT = 8;

  static final int MOUSEOVER = 4;

  static final int MOUSEUP = 2;

  static final int NONE = 0;

  static final int SELECT = 16384;

  /** @domName Event.bubbles */
  final bool bubbles;

  /** @domName Event.cancelBubble */
  bool cancelBubble;

  /** @domName Event.cancelable */
  final bool cancelable;

  /** @domName Event.clipboardData */
  final Clipboard clipboardData;

  /** @domName Event.currentTarget */
  final EventTarget currentTarget;

  /** @domName Event.defaultPrevented */
  final bool defaultPrevented;

  /** @domName Event.eventPhase */
  final int eventPhase;

  /** @domName Event.returnValue */
  bool returnValue;

  /** @domName Event.srcElement */
  final EventTarget srcElement;

  /** @domName Event.target */
  final EventTarget target;

  /** @domName Event.timeStamp */
  final int timeStamp;

  /** @domName Event.type */
  final String type;

  /** @domName Event.initEvent */
  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg);

  /** @domName Event.preventDefault */
  void preventDefault();

  /** @domName Event.stopImmediatePropagation */
  void stopImmediatePropagation();

  /** @domName Event.stopPropagation */
  void stopPropagation();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EventException
interface EventException {

  static final int DISPATCH_REQUEST_ERR = 1;

  static final int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  /** @domName EventException.code */
  final int code;

  /** @domName EventException.message */
  final String message;

  /** @domName EventException.name */
  final String name;

  /** @domName EventException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EventSource
interface EventSource extends EventTarget default _EventSourceFactoryProvider {

  EventSource(String scriptUrl);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  EventSourceEvents get on();

  static final int CLOSED = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  /** @domName EventSource.URL */
  final String URL;

  /** @domName EventSource.readyState */
  final int readyState;

  /** @domName EventSource.url */
  final String url;

  /** @domName EventSource.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName EventSource.close */
  void close();

  /** @domName EventSource.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName EventSource.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface EventSourceEvents extends Events {

  EventListenerList get error();

  EventListenerList get message();

  EventListenerList get open();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EventListenerList {
  EventListenerList add(EventListener handler, [bool useCapture]);

  EventListenerList remove(EventListener handler, [bool useCapture]);

  bool dispatch(Event evt);
}

interface Events {
  EventListenerList operator [](String type);
}

/// @domName EventTarget
interface EventTarget {

  /** @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent */
  final Events on;

  /** @domName EventTarget.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName EventTarget.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName EventTarget.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFieldSetElement
interface FieldSetElement extends Element default _Elements {

  FieldSetElement();

  /** @domName HTMLFieldSetElement.disabled */
  bool disabled;

  /** @domName HTMLFieldSetElement.form */
  final FormElement form;

  /** @domName HTMLFieldSetElement.name */
  String name;

  /** @domName HTMLFieldSetElement.type */
  final String type;

  /** @domName HTMLFieldSetElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLFieldSetElement.validity */
  final ValidityState validity;

  /** @domName HTMLFieldSetElement.willValidate */
  final bool willValidate;

  /** @domName HTMLFieldSetElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLFieldSetElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName File
interface File extends Blob {

  /** @domName File.lastModifiedDate */
  final Date lastModifiedDate;

  /** @domName File.name */
  final String name;

  /** @domName File.webkitRelativePath */
  final String webkitRelativePath;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileCallback(File file);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileEntry
interface FileEntry extends Entry {

  /** @domName FileEntry.createWriter */
  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName FileEntry.file */
  void file(FileCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileEntrySync
interface FileEntrySync extends EntrySync {

  /** @domName FileEntrySync.createWriter */
  FileWriterSync createWriter();

  /** @domName FileEntrySync.file */
  File file();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileError
interface FileError {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  /** @domName FileError.code */
  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileException
interface FileException {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  /** @domName FileException.code */
  final int code;

  /** @domName FileException.message */
  final String message;

  /** @domName FileException.name */
  final String name;

  /** @domName FileException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileList
interface FileList extends List<File> {

  /** @domName FileList.length */
  final int length;

  /** @domName FileList.item */
  File item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileReader
interface FileReader extends EventTarget default _FileReaderFactoryProvider {

  FileReader();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FileReaderEvents get on();

  static final int DONE = 2;

  static final int EMPTY = 0;

  static final int LOADING = 1;

  /** @domName FileReader.error */
  final FileError error;

  /** @domName FileReader.readyState */
  final int readyState;

  /** @domName FileReader.result */
  final Object result;

  /** @domName FileReader.abort */
  void abort();

  /** @domName FileReader.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileReader.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName FileReader.readAsArrayBuffer */
  void readAsArrayBuffer(Blob blob);

  /** @domName FileReader.readAsBinaryString */
  void readAsBinaryString(Blob blob);

  /** @domName FileReader.readAsDataURL */
  void readAsDataURL(Blob blob);

  /** @domName FileReader.readAsText */
  void readAsText(Blob blob, [String encoding]);

  /** @domName FileReader.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface FileReaderEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileReaderSync
interface FileReaderSync default _FileReaderSyncFactoryProvider {

  FileReaderSync();

  /** @domName FileReaderSync.readAsArrayBuffer */
  ArrayBuffer readAsArrayBuffer(Blob blob);

  /** @domName FileReaderSync.readAsBinaryString */
  String readAsBinaryString(Blob blob);

  /** @domName FileReaderSync.readAsDataURL */
  String readAsDataURL(Blob blob);

  /** @domName FileReaderSync.readAsText */
  String readAsText(Blob blob, [String encoding]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileSystemCallback(DOMFileSystem fileSystem);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileWriter
interface FileWriter extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FileWriterEvents get on();

  static final int DONE = 2;

  static final int INIT = 0;

  static final int WRITING = 1;

  /** @domName FileWriter.error */
  final FileError error;

  /** @domName FileWriter.length */
  final int length;

  /** @domName FileWriter.position */
  final int position;

  /** @domName FileWriter.readyState */
  final int readyState;

  /** @domName FileWriter.abort */
  void abort();

  /** @domName FileWriter.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileWriter.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName FileWriter.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileWriter.seek */
  void seek(int position);

  /** @domName FileWriter.truncate */
  void truncate(int size);

  /** @domName FileWriter.write */
  void write(Blob data);
}

interface FileWriterEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get progress();

  EventListenerList get write();

  EventListenerList get writeEnd();

  EventListenerList get writeStart();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileWriterCallback(FileWriter fileWriter);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileWriterSync
interface FileWriterSync {

  /** @domName FileWriterSync.length */
  final int length;

  /** @domName FileWriterSync.position */
  final int position;

  /** @domName FileWriterSync.seek */
  void seek(int position);

  /** @domName FileWriterSync.truncate */
  void truncate(int size);

  /** @domName FileWriterSync.write */
  void write(Blob data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Float32Array
interface Float32Array extends ArrayBufferView, List<num> default _TypedArrayFactoryProvider {

  Float32Array(int length);

  Float32Array.fromList(List<num> list);

  Float32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 4;

  /** @domName Float32Array.length */
  final int length;

  /** @domName Float32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Float32Array.subarray */
  Float32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Float64Array
interface Float64Array extends ArrayBufferView, List<num> default _TypedArrayFactoryProvider {

  Float64Array(int length);

  Float64Array.fromList(List<num> list);

  Float64Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 8;

  /** @domName Float64Array.length */
  final int length;

  /** @domName Float64Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Float64Array.subarray */
  Float64Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFontElement
interface FontElement extends Element {

  /** @domName HTMLFontElement.color */
  String color;

  /** @domName HTMLFontElement.face */
  String face;

  /** @domName HTMLFontElement.size */
  String size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFormElement
interface FormElement extends Element {

  /** @domName HTMLFormElement.acceptCharset */
  String acceptCharset;

  /** @domName HTMLFormElement.action */
  String action;

  /** @domName HTMLFormElement.autocomplete */
  String autocomplete;

  /** @domName HTMLFormElement.encoding */
  String encoding;

  /** @domName HTMLFormElement.enctype */
  String enctype;

  /** @domName HTMLFormElement.length */
  final int length;

  /** @domName HTMLFormElement.method */
  String method;

  /** @domName HTMLFormElement.name */
  String name;

  /** @domName HTMLFormElement.noValidate */
  bool noValidate;

  /** @domName HTMLFormElement.target */
  String target;

  /** @domName HTMLFormElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLFormElement.reset */
  void reset();

  /** @domName HTMLFormElement.submit */
  void submit();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFrameElement
interface FrameElement extends Element {

  /** @domName HTMLFrameElement.contentDocument */
  final Document contentDocument;

  /** @domName HTMLFrameElement.contentWindow */
  final Window contentWindow;

  /** @domName HTMLFrameElement.frameBorder */
  String frameBorder;

  /** @domName HTMLFrameElement.height */
  final int height;

  /** @domName HTMLFrameElement.location */
  String location;

  /** @domName HTMLFrameElement.longDesc */
  String longDesc;

  /** @domName HTMLFrameElement.marginHeight */
  String marginHeight;

  /** @domName HTMLFrameElement.marginWidth */
  String marginWidth;

  /** @domName HTMLFrameElement.name */
  String name;

  /** @domName HTMLFrameElement.noResize */
  bool noResize;

  /** @domName HTMLFrameElement.scrolling */
  String scrolling;

  /** @domName HTMLFrameElement.src */
  String src;

  /** @domName HTMLFrameElement.width */
  final int width;

  /** @domName HTMLFrameElement.getSVGDocument */
  SVGDocument getSVGDocument();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFrameSetElement
interface FrameSetElement extends Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FrameSetElementEvents get on();

  /** @domName HTMLFrameSetElement.cols */
  String cols;

  /** @domName HTMLFrameSetElement.rows */
  String rows;
}

interface FrameSetElementEvents extends ElementEvents {

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get load();

  EventListenerList get message();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get popState();

  EventListenerList get resize();

  EventListenerList get storage();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Geolocation
interface Geolocation {

  /** @domName Geolocation.clearWatch */
  void clearWatch(int watchId);

  /** @domName Geolocation.getCurrentPosition */
  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);

  /** @domName Geolocation.watchPosition */
  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Geoposition
interface Geoposition {

  /** @domName Geoposition.coords */
  final Coordinates coords;

  /** @domName Geoposition.timestamp */
  final int timestamp;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHRElement
interface HRElement extends Element default _Elements {

  HRElement();

  /** @domName HTMLHRElement.align */
  String align;

  /** @domName HTMLHRElement.noShade */
  bool noShade;

  /** @domName HTMLHRElement.size */
  String size;

  /** @domName HTMLHRElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAllCollection
interface HTMLAllCollection {

  /** @domName HTMLAllCollection.length */
  final int length;

  /** @domName HTMLAllCollection.item */
  Node item(int index);

  /** @domName HTMLAllCollection.namedItem */
  Node namedItem(String name);

  /** @domName HTMLAllCollection.tags */
  NodeList tags(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLCollection
interface HTMLCollection extends List<Node> {

  /** @domName HTMLCollection.length */
  final int length;

  /** @domName HTMLCollection.item */
  Node item(int index);

  /** @domName HTMLCollection.namedItem */
  Node namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptionsCollection
interface HTMLOptionsCollection extends HTMLCollection {

  /** @domName HTMLOptionsCollection.length */
  int length;

  /** @domName HTMLOptionsCollection.selectedIndex */
  int selectedIndex;

  /** @domName HTMLOptionsCollection.remove */
  void remove(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HashChangeEvent
interface HashChangeEvent extends Event {

  /** @domName HashChangeEvent.newURL */
  final String newURL;

  /** @domName HashChangeEvent.oldURL */
  final String oldURL;

  /** @domName HashChangeEvent.initHashChangeEvent */
  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHeadElement
interface HeadElement extends Element default _Elements {

  HeadElement();

  /** @domName HTMLHeadElement.profile */
  String profile;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHeadingElement
interface HeadingElement extends Element {

  /** @domName HTMLHeadingElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName History
interface History {

  /** @domName History.length */
  final int length;

  /** @domName History.state */
  final Dynamic state;

  /** @domName History.back */
  void back();

  /** @domName History.forward */
  void forward();

  /** @domName History.go */
  void go(int distance);

  /** @domName History.pushState */
  void pushState(Object data, String title, [String url]);

  /** @domName History.replaceState */
  void replaceState(Object data, String title, [String url]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHtmlElement
interface HtmlElement extends Element default _Elements {

  HtmlElement();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBAny
interface IDBAny {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBCursor
interface IDBCursor {

  static final int NEXT = 0;

  static final int NEXT_NO_DUPLICATE = 1;

  static final int PREV = 2;

  static final int PREV_NO_DUPLICATE = 3;

  /** @domName IDBCursor.direction */
  final String direction;

  /** @domName IDBCursor.key */
  final Dynamic key;

  /** @domName IDBCursor.primaryKey */
  final Dynamic primaryKey;

  /** @domName IDBCursor.source */
  final Dynamic source;

  /** @domName IDBCursor.advance */
  void advance(int count);

  /** @domName IDBCursor.continueFunction */
  void continueFunction([/*IDBKey*/ key]);

  /** @domName IDBCursor.delete */
  IDBRequest delete();

  /** @domName IDBCursor.update */
  IDBRequest update(/*SerializedScriptValue*/ value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBCursorWithValue
interface IDBCursorWithValue extends IDBCursor {

  /** @domName IDBCursorWithValue.value */
  final Dynamic value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBDatabase
interface IDBDatabase extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBDatabaseEvents get on();

  /** @domName IDBDatabase.name */
  final String name;

  /** @domName IDBDatabase.objectStoreNames */
  final List<String> objectStoreNames;

  /** @domName IDBDatabase.version */
  final String version;

  /** @domName IDBDatabase.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBDatabase.close */
  void close();

  /** @domName IDBDatabase.createObjectStore */
  IDBObjectStore createObjectStore(String name, [Map options]);

  /** @domName IDBDatabase.deleteObjectStore */
  void deleteObjectStore(String name);

  /** @domName IDBDatabase.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBDatabase.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBDatabase.setVersion */
  IDBVersionChangeRequest setVersion(String version);

  /** @domName IDBDatabase.transaction */
  IDBTransaction transaction(storeName_OR_storeNames, mode);
}

interface IDBDatabaseEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get versionChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBDatabaseException
interface IDBDatabaseException {

  static final int ABORT_ERR = 8;

  static final int CONSTRAINT_ERR = 4;

  static final int DATA_ERR = 5;

  static final int NON_TRANSIENT_ERR = 2;

  static final int NOT_ALLOWED_ERR = 6;

  static final int NOT_FOUND_ERR = 3;

  static final int NO_ERR = 0;

  static final int QUOTA_ERR = 11;

  static final int READ_ONLY_ERR = 9;

  static final int TIMEOUT_ERR = 10;

  static final int TRANSACTION_INACTIVE_ERR = 7;

  static final int UNKNOWN_ERR = 1;

  static final int VER_ERR = 12;

  /** @domName IDBDatabaseException.code */
  final int code;

  /** @domName IDBDatabaseException.message */
  final String message;

  /** @domName IDBDatabaseException.name */
  final String name;

  /** @domName IDBDatabaseException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBFactory
interface IDBFactory {

  /** @domName IDBFactory.cmp */
  int cmp(/*IDBKey*/ first, /*IDBKey*/ second);

  /** @domName IDBFactory.deleteDatabase */
  IDBVersionChangeRequest deleteDatabase(String name);

  /** @domName IDBFactory.getDatabaseNames */
  IDBRequest getDatabaseNames();

  /** @domName IDBFactory.open */
  IDBRequest open(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBIndex
interface IDBIndex {

  /** @domName IDBIndex.keyPath */
  final String keyPath;

  /** @domName IDBIndex.multiEntry */
  final bool multiEntry;

  /** @domName IDBIndex.name */
  final String name;

  /** @domName IDBIndex.objectStore */
  final IDBObjectStore objectStore;

  /** @domName IDBIndex.unique */
  final bool unique;

  /** @domName IDBIndex.count */
  IDBRequest count([key_OR_range]);

  /** @domName IDBIndex.get */
  IDBRequest get(key);

  /** @domName IDBIndex.getKey */
  IDBRequest getKey(key);

  /** @domName IDBIndex.openCursor */
  IDBRequest openCursor([key_OR_range, direction]);

  /** @domName IDBIndex.openKeyCursor */
  IDBRequest openKeyCursor([key_OR_range, direction]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBKey
interface IDBKey {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBKeyRange
interface IDBKeyRange default _IDBKeyRangeFactoryProvider {

  /**
   * @domName IDBKeyRange.only
   */
  IDBKeyRange.only(/*IDBKey*/ value);

  /**
   * @domName IDBKeyRange.lowerBound
   */
  IDBKeyRange.lowerBound(/*IDBKey*/ bound, [bool open]);

  /**
   * @domName IDBKeyRange.upperBound
   */
  IDBKeyRange.upperBound(/*IDBKey*/ bound, [bool open]);

  /**
   * @domName IDBKeyRange.bound
   */
  IDBKeyRange.bound(/*IDBKey*/ lower, /*IDBKey*/ upper,
                    [bool lowerOpen, bool upperOpen]);


  /** @domName IDBKeyRange.lower */
  final Dynamic lower;

  /** @domName IDBKeyRange.lowerOpen */
  final bool lowerOpen;

  /** @domName IDBKeyRange.upper */
  final Dynamic upper;

  /** @domName IDBKeyRange.upperOpen */
  final bool upperOpen;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBObjectStore
interface IDBObjectStore {

  /** @domName IDBObjectStore.indexNames */
  final List<String> indexNames;

  /** @domName IDBObjectStore.keyPath */
  final String keyPath;

  /** @domName IDBObjectStore.name */
  final String name;

  /** @domName IDBObjectStore.transaction */
  final IDBTransaction transaction;

  /** @domName IDBObjectStore.add */
  IDBRequest add(/*SerializedScriptValue*/ value, [/*IDBKey*/ key]);

  /** @domName IDBObjectStore.clear */
  IDBRequest clear();

  /** @domName IDBObjectStore.count */
  IDBRequest count([key_OR_range]);

  /** @domName IDBObjectStore.createIndex */
  IDBIndex createIndex(String name, String keyPath, [Map options]);

  /** @domName IDBObjectStore.delete */
  IDBRequest delete(key_OR_keyRange);

  /** @domName IDBObjectStore.deleteIndex */
  void deleteIndex(String name);

  /** @domName IDBObjectStore.getObject */
  IDBRequest getObject(key);

  /** @domName IDBObjectStore.index */
  IDBIndex index(String name);

  /** @domName IDBObjectStore.openCursor */
  IDBRequest openCursor([key_OR_range, direction]);

  /** @domName IDBObjectStore.put */
  IDBRequest put(/*SerializedScriptValue*/ value, [/*IDBKey*/ key]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBRequest
interface IDBRequest extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBRequestEvents get on();

  /** @domName IDBRequest.errorCode */
  final int errorCode;

  /** @domName IDBRequest.readyState */
  final String readyState;

  /** @domName IDBRequest.result */
  final Dynamic result;

  /** @domName IDBRequest.source */
  final Dynamic source;

  /** @domName IDBRequest.transaction */
  final IDBTransaction transaction;

  /** @domName IDBRequest.webkitErrorMessage */
  final String webkitErrorMessage;

  /** @domName IDBRequest.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBRequest.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBRequest.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface IDBRequestEvents extends Events {

  EventListenerList get error();

  EventListenerList get success();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBTransaction
interface IDBTransaction extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBTransactionEvents get on();

  static final int READ_ONLY = 0;

  static final int READ_WRITE = 1;

  static final int VERSION_CHANGE = 2;

  /** @domName IDBTransaction.db */
  final IDBDatabase db;

  /** @domName IDBTransaction.mode */
  final String mode;

  /** @domName IDBTransaction.abort */
  void abort();

  /** @domName IDBTransaction.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBTransaction.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBTransaction.objectStore */
  IDBObjectStore objectStore(String name);

  /** @domName IDBTransaction.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface IDBTransactionEvents extends Events {

  EventListenerList get abort();

  EventListenerList get complete();

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeEvent
interface IDBVersionChangeEvent extends Event {

  /** @domName IDBVersionChangeEvent.version */
  final String version;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeRequest
interface IDBVersionChangeRequest extends IDBRequest, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBVersionChangeRequestEvents get on();
}

interface IDBVersionChangeRequestEvents extends IDBRequestEvents {

  EventListenerList get blocked();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLIFrameElement
interface IFrameElement extends Element default _Elements {

  IFrameElement();

  /** @domName HTMLIFrameElement.align */
  String align;

  /** @domName HTMLIFrameElement.contentWindow */
  final Window contentWindow;

  /** @domName HTMLIFrameElement.frameBorder */
  String frameBorder;

  /** @domName HTMLIFrameElement.height */
  String height;

  /** @domName HTMLIFrameElement.longDesc */
  String longDesc;

  /** @domName HTMLIFrameElement.marginHeight */
  String marginHeight;

  /** @domName HTMLIFrameElement.marginWidth */
  String marginWidth;

  /** @domName HTMLIFrameElement.name */
  String name;

  /** @domName HTMLIFrameElement.sandbox */
  String sandbox;

  /** @domName HTMLIFrameElement.scrolling */
  String scrolling;

  /** @domName HTMLIFrameElement.src */
  String src;

  /** @domName HTMLIFrameElement.srcdoc */
  String srcdoc;

  /** @domName HTMLIFrameElement.width */
  String width;

  /** @domName HTMLIFrameElement.getSVGDocument */
  SVGDocument getSVGDocument();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool IceCallback(IceCandidate candidate, bool moreToFollow, PeerConnection00 source);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IceCandidate
interface IceCandidate default _IceCandidateFactoryProvider {

  IceCandidate(String label, String candidateLine);

  /** @domName IceCandidate.label */
  final String label;

  /** @domName IceCandidate.toSdp */
  String toSdp();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ImageData
interface ImageData {

  /** @domName ImageData.data */
  final Uint8ClampedArray data;

  /** @domName ImageData.height */
  final int height;

  /** @domName ImageData.width */
  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLImageElement
interface ImageElement extends Element default _Elements {

  ImageElement([String src, int height, int width]);

  /** @domName HTMLImageElement.align */
  String align;

  /** @domName HTMLImageElement.alt */
  String alt;

  /** @domName HTMLImageElement.border */
  String border;

  /** @domName HTMLImageElement.complete */
  final bool complete;

  /** @domName HTMLImageElement.crossOrigin */
  String crossOrigin;

  /** @domName HTMLImageElement.height */
  int height;

  /** @domName HTMLImageElement.hspace */
  int hspace;

  /** @domName HTMLImageElement.isMap */
  bool isMap;

  /** @domName HTMLImageElement.longDesc */
  String longDesc;

  /** @domName HTMLImageElement.lowsrc */
  String lowsrc;

  /** @domName HTMLImageElement.name */
  String name;

  /** @domName HTMLImageElement.naturalHeight */
  final int naturalHeight;

  /** @domName HTMLImageElement.naturalWidth */
  final int naturalWidth;

  /** @domName HTMLImageElement.src */
  String src;

  /** @domName HTMLImageElement.useMap */
  String useMap;

  /** @domName HTMLImageElement.vspace */
  int vspace;

  /** @domName HTMLImageElement.width */
  int width;

  /** @domName HTMLImageElement.x */
  final int x;

  /** @domName HTMLImageElement.y */
  final int y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLInputElement
interface InputElement extends Element default _Elements {

  InputElement([String type]);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  InputElementEvents get on();

  /** @domName HTMLInputElement.accept */
  String accept;

  /** @domName HTMLInputElement.align */
  String align;

  /** @domName HTMLInputElement.alt */
  String alt;

  /** @domName HTMLInputElement.autocomplete */
  String autocomplete;

  /** @domName HTMLInputElement.autofocus */
  bool autofocus;

  /** @domName HTMLInputElement.checked */
  bool checked;

  /** @domName HTMLInputElement.defaultChecked */
  bool defaultChecked;

  /** @domName HTMLInputElement.defaultValue */
  String defaultValue;

  /** @domName HTMLInputElement.disabled */
  bool disabled;

  /** @domName HTMLInputElement.files */
  final FileList files;

  /** @domName HTMLInputElement.form */
  final FormElement form;

  /** @domName HTMLInputElement.formAction */
  String formAction;

  /** @domName HTMLInputElement.formEnctype */
  String formEnctype;

  /** @domName HTMLInputElement.formMethod */
  String formMethod;

  /** @domName HTMLInputElement.formNoValidate */
  bool formNoValidate;

  /** @domName HTMLInputElement.formTarget */
  String formTarget;

  /** @domName HTMLInputElement.height */
  int height;

  /** @domName HTMLInputElement.incremental */
  bool incremental;

  /** @domName HTMLInputElement.indeterminate */
  bool indeterminate;

  /** @domName HTMLInputElement.labels */
  final NodeList labels;

  /** @domName HTMLInputElement.max */
  String max;

  /** @domName HTMLInputElement.maxLength */
  int maxLength;

  /** @domName HTMLInputElement.min */
  String min;

  /** @domName HTMLInputElement.multiple */
  bool multiple;

  /** @domName HTMLInputElement.name */
  String name;

  /** @domName HTMLInputElement.pattern */
  String pattern;

  /** @domName HTMLInputElement.placeholder */
  String placeholder;

  /** @domName HTMLInputElement.readOnly */
  bool readOnly;

  /** @domName HTMLInputElement.required */
  bool required;

  /** @domName HTMLInputElement.selectionDirection */
  String selectionDirection;

  /** @domName HTMLInputElement.selectionEnd */
  int selectionEnd;

  /** @domName HTMLInputElement.selectionStart */
  int selectionStart;

  /** @domName HTMLInputElement.size */
  int size;

  /** @domName HTMLInputElement.src */
  String src;

  /** @domName HTMLInputElement.step */
  String step;

  /** @domName HTMLInputElement.type */
  String type;

  /** @domName HTMLInputElement.useMap */
  String useMap;

  /** @domName HTMLInputElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLInputElement.validity */
  final ValidityState validity;

  /** @domName HTMLInputElement.value */
  String value;

  /** @domName HTMLInputElement.valueAsDate */
  Date valueAsDate;

  /** @domName HTMLInputElement.valueAsNumber */
  num valueAsNumber;

  /** @domName HTMLInputElement.webkitGrammar */
  bool webkitGrammar;

  /** @domName HTMLInputElement.webkitSpeech */
  bool webkitSpeech;

  /** @domName HTMLInputElement.webkitdirectory */
  bool webkitdirectory;

  /** @domName HTMLInputElement.width */
  int width;

  /** @domName HTMLInputElement.willValidate */
  final bool willValidate;

  /** @domName HTMLInputElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLInputElement.select */
  void select();

  /** @domName HTMLInputElement.setCustomValidity */
  void setCustomValidity(String error);

  /** @domName HTMLInputElement.setSelectionRange */
  void setSelectionRange(int start, int end, [String direction]);

  /** @domName HTMLInputElement.stepDown */
  void stepDown([int n]);

  /** @domName HTMLInputElement.stepUp */
  void stepUp([int n]);
}

interface InputElementEvents extends ElementEvents {

  EventListenerList get speechChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int16Array
interface Int16Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int16Array(int length);

  Int16Array.fromList(List<int> list);

  Int16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 2;

  /** @domName Int16Array.length */
  final int length;

  /** @domName Int16Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int16Array.subarray */
  Int16Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int32Array
interface Int32Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int32Array(int length);

  Int32Array.fromList(List<int> list);

  Int32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 4;

  /** @domName Int32Array.length */
  final int length;

  /** @domName Int32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int32Array.subarray */
  Int32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int8Array
interface Int8Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int8Array(int length);

  Int8Array.fromList(List<int> list);

  Int8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 1;

  /** @domName Int8Array.length */
  final int length;

  /** @domName Int8Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int8Array.subarray */
  Int8Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName JavaScriptAudioNode
interface JavaScriptAudioNode extends AudioNode, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  JavaScriptAudioNodeEvents get on();

  /** @domName JavaScriptAudioNode.bufferSize */
  final int bufferSize;
}

interface JavaScriptAudioNodeEvents extends Events {

  EventListenerList get audioProcess();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName JavaScriptCallFrame
interface JavaScriptCallFrame {

  static final int CATCH_SCOPE = 4;

  static final int CLOSURE_SCOPE = 3;

  static final int GLOBAL_SCOPE = 0;

  static final int LOCAL_SCOPE = 1;

  static final int WITH_SCOPE = 2;

  /** @domName JavaScriptCallFrame.caller */
  final JavaScriptCallFrame caller;

  /** @domName JavaScriptCallFrame.column */
  final int column;

  /** @domName JavaScriptCallFrame.functionName */
  final String functionName;

  /** @domName JavaScriptCallFrame.line */
  final int line;

  /** @domName JavaScriptCallFrame.scopeChain */
  final List scopeChain;

  /** @domName JavaScriptCallFrame.sourceID */
  final int sourceID;

  /** @domName JavaScriptCallFrame.thisObject */
  final Object thisObject;

  /** @domName JavaScriptCallFrame.type */
  final String type;

  /** @domName JavaScriptCallFrame.evaluate */
  void evaluate(String script);

  /** @domName JavaScriptCallFrame.scopeType */
  int scopeType(int scopeIndex);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName KeyboardEvent
interface KeyboardEvent extends UIEvent {

  /** @domName KeyboardEvent.altGraphKey */
  final bool altGraphKey;

  /** @domName KeyboardEvent.altKey */
  final bool altKey;

  /** @domName KeyboardEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName KeyboardEvent.keyIdentifier */
  final String keyIdentifier;

  /** @domName KeyboardEvent.keyLocation */
  final int keyLocation;

  /** @domName KeyboardEvent.metaKey */
  final bool metaKey;

  /** @domName KeyboardEvent.shiftKey */
  final bool shiftKey;

  /** @domName KeyboardEvent.initKeyboardEvent */
  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLKeygenElement
interface KeygenElement extends Element default _Elements {

  KeygenElement();

  /** @domName HTMLKeygenElement.autofocus */
  bool autofocus;

  /** @domName HTMLKeygenElement.challenge */
  String challenge;

  /** @domName HTMLKeygenElement.disabled */
  bool disabled;

  /** @domName HTMLKeygenElement.form */
  final FormElement form;

  /** @domName HTMLKeygenElement.keytype */
  String keytype;

  /** @domName HTMLKeygenElement.labels */
  final NodeList labels;

  /** @domName HTMLKeygenElement.name */
  String name;

  /** @domName HTMLKeygenElement.type */
  final String type;

  /** @domName HTMLKeygenElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLKeygenElement.validity */
  final ValidityState validity;

  /** @domName HTMLKeygenElement.willValidate */
  final bool willValidate;

  /** @domName HTMLKeygenElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLKeygenElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLIElement
interface LIElement extends Element default _Elements {

  LIElement();

  /** @domName HTMLLIElement.type */
  String type;

  /** @domName HTMLLIElement.value */
  int value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLabelElement
interface LabelElement extends Element default _Elements {

  LabelElement();

  /** @domName HTMLLabelElement.control */
  final Element control;

  /** @domName HTMLLabelElement.form */
  final FormElement form;

  /** @domName HTMLLabelElement.htmlFor */
  String htmlFor;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLegendElement
interface LegendElement extends Element default _Elements {

  LegendElement();

  /** @domName HTMLLegendElement.align */
  String align;

  /** @domName HTMLLegendElement.form */
  final FormElement form;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLinkElement
interface LinkElement extends Element default _Elements {

  LinkElement();

  /** @domName HTMLLinkElement.charset */
  String charset;

  /** @domName HTMLLinkElement.disabled */
  bool disabled;

  /** @domName HTMLLinkElement.href */
  String href;

  /** @domName HTMLLinkElement.hreflang */
  String hreflang;

  /** @domName HTMLLinkElement.media */
  String media;

  /** @domName HTMLLinkElement.rel */
  String rel;

  /** @domName HTMLLinkElement.rev */
  String rev;

  /** @domName HTMLLinkElement.sheet */
  final StyleSheet sheet;

  /** @domName HTMLLinkElement.sizes */
  DOMSettableTokenList sizes;

  /** @domName HTMLLinkElement.target */
  String target;

  /** @domName HTMLLinkElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName LocalMediaStream
interface LocalMediaStream extends MediaStream {

  /** @domName LocalMediaStream.stop */
  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Location
interface Location {

  /** @domName Location.ancestorOrigins */
  final List<String> ancestorOrigins;

  /** @domName Location.hash */
  String hash;

  /** @domName Location.host */
  String host;

  /** @domName Location.hostname */
  String hostname;

  /** @domName Location.href */
  String href;

  /** @domName Location.origin */
  final String origin;

  /** @domName Location.pathname */
  String pathname;

  /** @domName Location.port */
  String port;

  /** @domName Location.protocol */
  String protocol;

  /** @domName Location.search */
  String search;

  /** @domName Location.assign */
  void assign(String url);

  /** @domName Location.reload */
  void reload();

  /** @domName Location.replace */
  void replace(String url);

  /** @domName Location.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMapElement
interface MapElement extends Element default _Elements {

  MapElement();

  /** @domName HTMLMapElement.areas */
  final HTMLCollection areas;

  /** @domName HTMLMapElement.name */
  String name;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMarqueeElement
interface MarqueeElement extends Element {

  /** @domName HTMLMarqueeElement.behavior */
  String behavior;

  /** @domName HTMLMarqueeElement.bgColor */
  String bgColor;

  /** @domName HTMLMarqueeElement.direction */
  String direction;

  /** @domName HTMLMarqueeElement.height */
  String height;

  /** @domName HTMLMarqueeElement.hspace */
  int hspace;

  /** @domName HTMLMarqueeElement.loop */
  int loop;

  /** @domName HTMLMarqueeElement.scrollAmount */
  int scrollAmount;

  /** @domName HTMLMarqueeElement.scrollDelay */
  int scrollDelay;

  /** @domName HTMLMarqueeElement.trueSpeed */
  bool trueSpeed;

  /** @domName HTMLMarqueeElement.vspace */
  int vspace;

  /** @domName HTMLMarqueeElement.width */
  String width;

  /** @domName HTMLMarqueeElement.start */
  void start();

  /** @domName HTMLMarqueeElement.stop */
  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaController
interface MediaController extends EventTarget default _MediaControllerFactoryProvider {

  MediaController();

  /** @domName MediaController.buffered */
  final TimeRanges buffered;

  /** @domName MediaController.currentTime */
  num currentTime;

  /** @domName MediaController.defaultPlaybackRate */
  num defaultPlaybackRate;

  /** @domName MediaController.duration */
  final num duration;

  /** @domName MediaController.muted */
  bool muted;

  /** @domName MediaController.paused */
  final bool paused;

  /** @domName MediaController.playbackRate */
  num playbackRate;

  /** @domName MediaController.played */
  final TimeRanges played;

  /** @domName MediaController.seekable */
  final TimeRanges seekable;

  /** @domName MediaController.volume */
  num volume;

  /** @domName MediaController.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaController.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName MediaController.pause */
  void pause();

  /** @domName MediaController.play */
  void play();

  /** @domName MediaController.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMediaElement
interface MediaElement extends Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaElementEvents get on();

  static final int EOS_DECODE_ERR = 2;

  static final int EOS_NETWORK_ERR = 1;

  static final int EOS_NO_ERROR = 0;

  static final int HAVE_CURRENT_DATA = 2;

  static final int HAVE_ENOUGH_DATA = 4;

  static final int HAVE_FUTURE_DATA = 3;

  static final int HAVE_METADATA = 1;

  static final int HAVE_NOTHING = 0;

  static final int NETWORK_EMPTY = 0;

  static final int NETWORK_IDLE = 1;

  static final int NETWORK_LOADING = 2;

  static final int NETWORK_NO_SOURCE = 3;

  static final int SOURCE_CLOSED = 0;

  static final int SOURCE_ENDED = 2;

  static final int SOURCE_OPEN = 1;

  /** @domName HTMLMediaElement.autoplay */
  bool autoplay;

  /** @domName HTMLMediaElement.buffered */
  final TimeRanges buffered;

  /** @domName HTMLMediaElement.controller */
  MediaController controller;

  /** @domName HTMLMediaElement.controls */
  bool controls;

  /** @domName HTMLMediaElement.currentSrc */
  final String currentSrc;

  /** @domName HTMLMediaElement.currentTime */
  num currentTime;

  /** @domName HTMLMediaElement.defaultMuted */
  bool defaultMuted;

  /** @domName HTMLMediaElement.defaultPlaybackRate */
  num defaultPlaybackRate;

  /** @domName HTMLMediaElement.duration */
  final num duration;

  /** @domName HTMLMediaElement.ended */
  final bool ended;

  /** @domName HTMLMediaElement.error */
  final MediaError error;

  /** @domName HTMLMediaElement.initialTime */
  final num initialTime;

  /** @domName HTMLMediaElement.loop */
  bool loop;

  /** @domName HTMLMediaElement.mediaGroup */
  String mediaGroup;

  /** @domName HTMLMediaElement.muted */
  bool muted;

  /** @domName HTMLMediaElement.networkState */
  final int networkState;

  /** @domName HTMLMediaElement.paused */
  final bool paused;

  /** @domName HTMLMediaElement.playbackRate */
  num playbackRate;

  /** @domName HTMLMediaElement.played */
  final TimeRanges played;

  /** @domName HTMLMediaElement.preload */
  String preload;

  /** @domName HTMLMediaElement.readyState */
  final int readyState;

  /** @domName HTMLMediaElement.seekable */
  final TimeRanges seekable;

  /** @domName HTMLMediaElement.seeking */
  final bool seeking;

  /** @domName HTMLMediaElement.src */
  String src;

  /** @domName HTMLMediaElement.startTime */
  final num startTime;

  /** @domName HTMLMediaElement.textTracks */
  final TextTrackList textTracks;

  /** @domName HTMLMediaElement.volume */
  num volume;

  /** @domName HTMLMediaElement.webkitAudioDecodedByteCount */
  final int webkitAudioDecodedByteCount;

  /** @domName HTMLMediaElement.webkitClosedCaptionsVisible */
  bool webkitClosedCaptionsVisible;

  /** @domName HTMLMediaElement.webkitHasClosedCaptions */
  final bool webkitHasClosedCaptions;

  /** @domName HTMLMediaElement.webkitMediaSourceURL */
  final String webkitMediaSourceURL;

  /** @domName HTMLMediaElement.webkitPreservesPitch */
  bool webkitPreservesPitch;

  /** @domName HTMLMediaElement.webkitSourceState */
  final int webkitSourceState;

  /** @domName HTMLMediaElement.webkitVideoDecodedByteCount */
  final int webkitVideoDecodedByteCount;

  /** @domName HTMLMediaElement.addTextTrack */
  TextTrack addTextTrack(String kind, [String label, String language]);

  /** @domName HTMLMediaElement.canPlayType */
  String canPlayType(String type, String keySystem);

  /** @domName HTMLMediaElement.load */
  void load();

  /** @domName HTMLMediaElement.pause */
  void pause();

  /** @domName HTMLMediaElement.play */
  void play();

  /** @domName HTMLMediaElement.webkitAddKey */
  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData, String sessionId]);

  /** @domName HTMLMediaElement.webkitCancelKeyRequest */
  void webkitCancelKeyRequest(String keySystem, String sessionId);

  /** @domName HTMLMediaElement.webkitGenerateKeyRequest */
  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData]);

  /** @domName HTMLMediaElement.webkitSourceAppend */
  void webkitSourceAppend(Uint8Array data);

  /** @domName HTMLMediaElement.webkitSourceEndOfStream */
  void webkitSourceEndOfStream(int status);
}

interface MediaElementEvents extends ElementEvents {

  EventListenerList get keyAdded();

  EventListenerList get keyError();

  EventListenerList get keyMessage();

  EventListenerList get needKey();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaElementAudioSourceNode
interface MediaElementAudioSourceNode extends AudioSourceNode {

  /** @domName MediaElementAudioSourceNode.mediaElement */
  final MediaElement mediaElement;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaError
interface MediaError {

  static final int MEDIA_ERR_ABORTED = 1;

  static final int MEDIA_ERR_DECODE = 3;

  static final int MEDIA_ERR_ENCRYPTED = 5;

  static final int MEDIA_ERR_NETWORK = 2;

  static final int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  /** @domName MediaError.code */
  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaKeyError
interface MediaKeyError {

  static final int MEDIA_KEYERR_CLIENT = 2;

  static final int MEDIA_KEYERR_DOMAIN = 6;

  static final int MEDIA_KEYERR_HARDWARECHANGE = 5;

  static final int MEDIA_KEYERR_OUTPUT = 4;

  static final int MEDIA_KEYERR_SERVICE = 3;

  static final int MEDIA_KEYERR_UNKNOWN = 1;

  /** @domName MediaKeyError.code */
  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaKeyEvent
interface MediaKeyEvent extends Event {

  /** @domName MediaKeyEvent.defaultURL */
  final String defaultURL;

  /** @domName MediaKeyEvent.errorCode */
  final MediaKeyError errorCode;

  /** @domName MediaKeyEvent.initData */
  final Uint8Array initData;

  /** @domName MediaKeyEvent.keySystem */
  final String keySystem;

  /** @domName MediaKeyEvent.message */
  final Uint8Array message;

  /** @domName MediaKeyEvent.sessionId */
  final String sessionId;

  /** @domName MediaKeyEvent.systemCode */
  final int systemCode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaList
interface MediaList extends List<String> {

  /** @domName MediaList.length */
  final int length;

  /** @domName MediaList.mediaText */
  String mediaText;

  /** @domName MediaList.appendMedium */
  void appendMedium(String newMedium);

  /** @domName MediaList.deleteMedium */
  void deleteMedium(String oldMedium);

  /** @domName MediaList.item */
  String item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaQueryList
interface MediaQueryList {

  /** @domName MediaQueryList.matches */
  final bool matches;

  /** @domName MediaQueryList.media */
  final String media;

  /** @domName MediaQueryList.addListener */
  void addListener(MediaQueryListListener listener);

  /** @domName MediaQueryList.removeListener */
  void removeListener(MediaQueryListListener listener);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaQueryListListener
interface MediaQueryListListener {

  /** @domName MediaQueryListListener.queryChanged */
  void queryChanged(MediaQueryList list);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStream
interface MediaStream extends EventTarget default _MediaStreamFactoryProvider {

  MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaStreamEvents get on();

  static final int ENDED = 2;

  static final int LIVE = 1;

  /** @domName MediaStream.audioTracks */
  final MediaStreamTrackList audioTracks;

  /** @domName MediaStream.label */
  final String label;

  /** @domName MediaStream.readyState */
  final int readyState;

  /** @domName MediaStream.videoTracks */
  final MediaStreamTrackList videoTracks;

  /** @domName MediaStream.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaStream.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName MediaStream.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface MediaStreamEvents extends Events {

  EventListenerList get ended();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamEvent
interface MediaStreamEvent extends Event {

  /** @domName MediaStreamEvent.stream */
  final MediaStream stream;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamList
interface MediaStreamList {

  /** @domName MediaStreamList.length */
  final int length;

  /** @domName MediaStreamList.item */
  MediaStream item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrack
interface MediaStreamTrack {

  /** @domName MediaStreamTrack.enabled */
  bool enabled;

  /** @domName MediaStreamTrack.kind */
  final String kind;

  /** @domName MediaStreamTrack.label */
  final String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrackList
interface MediaStreamTrackList {

  /** @domName MediaStreamTrackList.length */
  final int length;

  /** @domName MediaStreamTrackList.item */
  MediaStreamTrack item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MemoryInfo
interface MemoryInfo {

  /** @domName MemoryInfo.jsHeapSizeLimit */
  final int jsHeapSizeLimit;

  /** @domName MemoryInfo.totalJSHeapSize */
  final int totalJSHeapSize;

  /** @domName MemoryInfo.usedJSHeapSize */
  final int usedJSHeapSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMenuElement
interface MenuElement extends Element default _Elements {

  MenuElement();

  /** @domName HTMLMenuElement.compact */
  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessageChannel
interface MessageChannel default _MessageChannelFactoryProvider {

  MessageChannel();

  /** @domName MessageChannel.port1 */
  final MessagePort port1;

  /** @domName MessageChannel.port2 */
  final MessagePort port2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessageEvent
interface MessageEvent extends Event {

  /** @domName MessageEvent.data */
  final Object data;

  /** @domName MessageEvent.lastEventId */
  final String lastEventId;

  /** @domName MessageEvent.origin */
  final String origin;

  /** @domName MessageEvent.ports */
  final List ports;

  /** @domName MessageEvent.source */
  final Window source;

  /** @domName MessageEvent.initMessageEvent */
  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts);

  /** @domName MessageEvent.webkitInitMessageEvent */
  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessagePort
interface MessagePort extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MessagePortEvents get on();

  /** @domName MessagePort.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MessagePort.close */
  void close();

  /** @domName MessagePort.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName MessagePort.postMessage */
  void postMessage(String message, [List messagePorts]);

  /** @domName MessagePort.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MessagePort.start */
  void start();

  /** @domName MessagePort.webkitPostMessage */
  void webkitPostMessage(String message, [List transfer]);
}

interface MessagePortEvents extends Events {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMetaElement
interface MetaElement extends Element {

  /** @domName HTMLMetaElement.content */
  String content;

  /** @domName HTMLMetaElement.httpEquiv */
  String httpEquiv;

  /** @domName HTMLMetaElement.name */
  String name;

  /** @domName HTMLMetaElement.scheme */
  String scheme;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Metadata
interface Metadata {

  /** @domName Metadata.modificationTime */
  final Date modificationTime;

  /** @domName Metadata.size */
  final int size;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool MetadataCallback(Metadata metadata);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMeterElement
interface MeterElement extends Element default _Elements {

  MeterElement();

  /** @domName HTMLMeterElement.high */
  num high;

  /** @domName HTMLMeterElement.labels */
  final NodeList labels;

  /** @domName HTMLMeterElement.low */
  num low;

  /** @domName HTMLMeterElement.max */
  num max;

  /** @domName HTMLMeterElement.min */
  num min;

  /** @domName HTMLMeterElement.optimum */
  num optimum;

  /** @domName HTMLMeterElement.value */
  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLModElement
interface ModElement extends Element {

  /** @domName HTMLModElement.cite */
  String cite;

  /** @domName HTMLModElement.dateTime */
  String dateTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MouseEvent
interface MouseEvent extends UIEvent default _MouseEventFactoryProvider {

  MouseEvent(String type, Window view, int detail, int screenX, int screenY,
      int clientX, int clientY, int button, [bool canBubble, bool cancelable,
      bool ctrlKey, bool altKey, bool shiftKey, bool metaKey,
      EventTarget relatedTarget]);


  /** @domName MouseEvent.altKey */
  final bool altKey;

  /** @domName MouseEvent.button */
  final int button;

  /** @domName MouseEvent.clientX */
  final int clientX;

  /** @domName MouseEvent.clientY */
  final int clientY;

  /** @domName MouseEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName MouseEvent.dataTransfer */
  final Clipboard dataTransfer;

  /** @domName MouseEvent.fromElement */
  final Node fromElement;

  /** @domName MouseEvent.metaKey */
  final bool metaKey;

  /** @domName MouseEvent.offsetX */
  final int offsetX;

  /** @domName MouseEvent.offsetY */
  final int offsetY;

  /** @domName MouseEvent.relatedTarget */
  final EventTarget relatedTarget;

  /** @domName MouseEvent.screenX */
  final int screenX;

  /** @domName MouseEvent.screenY */
  final int screenY;

  /** @domName MouseEvent.shiftKey */
  final bool shiftKey;

  /** @domName MouseEvent.toElement */
  final Node toElement;

  /** @domName MouseEvent.webkitMovementX */
  final int webkitMovementX;

  /** @domName MouseEvent.webkitMovementY */
  final int webkitMovementY;

  /** @domName MouseEvent.x */
  final int x;

  /** @domName MouseEvent.y */
  final int y;

  /** @domName MouseEvent.initMouseEvent */
  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationCallback
interface MutationCallback {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationEvent
interface MutationEvent extends Event {

  static final int ADDITION = 2;

  static final int MODIFICATION = 1;

  static final int REMOVAL = 3;

  /** @domName MutationEvent.attrChange */
  final int attrChange;

  /** @domName MutationEvent.attrName */
  final String attrName;

  /** @domName MutationEvent.newValue */
  final String newValue;

  /** @domName MutationEvent.prevValue */
  final String prevValue;

  /** @domName MutationEvent.relatedNode */
  final Node relatedNode;

  /** @domName MutationEvent.initMutationEvent */
  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationRecord
interface MutationRecord {

  /** @domName MutationRecord.addedNodes */
  final NodeList addedNodes;

  /** @domName MutationRecord.attributeName */
  final String attributeName;

  /** @domName MutationRecord.attributeNamespace */
  final String attributeNamespace;

  /** @domName MutationRecord.nextSibling */
  final Node nextSibling;

  /** @domName MutationRecord.oldValue */
  final String oldValue;

  /** @domName MutationRecord.previousSibling */
  final Node previousSibling;

  /** @domName MutationRecord.removedNodes */
  final NodeList removedNodes;

  /** @domName MutationRecord.target */
  final Node target;

  /** @domName MutationRecord.type */
  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NamedNodeMap
interface NamedNodeMap extends List<Node> {

  /** @domName NamedNodeMap.length */
  final int length;

  /** @domName NamedNodeMap.getNamedItem */
  Node getNamedItem(String name);

  /** @domName NamedNodeMap.getNamedItemNS */
  Node getNamedItemNS(String namespaceURI, String localName);

  /** @domName NamedNodeMap.item */
  Node item(int index);

  /** @domName NamedNodeMap.removeNamedItem */
  Node removeNamedItem(String name);

  /** @domName NamedNodeMap.removeNamedItemNS */
  Node removeNamedItemNS(String namespaceURI, String localName);

  /** @domName NamedNodeMap.setNamedItem */
  Node setNamedItem(Node node);

  /** @domName NamedNodeMap.setNamedItemNS */
  Node setNamedItemNS(Node node);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Navigator
interface Navigator {

  /** @domName Navigator.appCodeName */
  final String appCodeName;

  /** @domName Navigator.appName */
  final String appName;

  /** @domName Navigator.appVersion */
  final String appVersion;

  /** @domName Navigator.cookieEnabled */
  final bool cookieEnabled;

  /** @domName Navigator.geolocation */
  final Geolocation geolocation;

  /** @domName Navigator.language */
  final String language;

  /** @domName Navigator.mimeTypes */
  final DOMMimeTypeArray mimeTypes;

  /** @domName Navigator.onLine */
  final bool onLine;

  /** @domName Navigator.platform */
  final String platform;

  /** @domName Navigator.plugins */
  final DOMPluginArray plugins;

  /** @domName Navigator.product */
  final String product;

  /** @domName Navigator.productSub */
  final String productSub;

  /** @domName Navigator.userAgent */
  final String userAgent;

  /** @domName Navigator.vendor */
  final String vendor;

  /** @domName Navigator.vendorSub */
  final String vendorSub;

  /** @domName Navigator.webkitBattery */
  final BatteryManager webkitBattery;

  /** @domName Navigator.webkitPointer */
  final PointerLock webkitPointer;

  /** @domName Navigator.getStorageUpdates */
  void getStorageUpdates();

  /** @domName Navigator.javaEnabled */
  bool javaEnabled();

  /** @domName Navigator.registerProtocolHandler */
  void registerProtocolHandler(String scheme, String url, String title);

  /** @domName Navigator.webkitGetUserMedia */
  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NavigatorUserMediaError
interface NavigatorUserMediaError {

  static final int PERMISSION_DENIED = 1;

  /** @domName NavigatorUserMediaError.code */
  final int code;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaSuccessCallback(LocalMediaStream stream);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Node
interface Node extends EventTarget {
  NodeList get nodes();

  void set nodes(Collection<Node> value);

  /**
   * Replaces this node with another node.
   * @domName Node.replaceChild
   */
  Node replaceWith(Node otherNode);

  /**
   * Removes this node from the DOM.
   * @domName Node.removeChild
   */
  Node remove();


  static final int ATTRIBUTE_NODE = 2;

  static final int CDATA_SECTION_NODE = 4;

  static final int COMMENT_NODE = 8;

  static final int DOCUMENT_FRAGMENT_NODE = 11;

  static final int DOCUMENT_NODE = 9;

  static final int DOCUMENT_POSITION_CONTAINED_BY = 0x10;

  static final int DOCUMENT_POSITION_CONTAINS = 0x08;

  static final int DOCUMENT_POSITION_DISCONNECTED = 0x01;

  static final int DOCUMENT_POSITION_FOLLOWING = 0x04;

  static final int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  static final int DOCUMENT_POSITION_PRECEDING = 0x02;

  static final int DOCUMENT_TYPE_NODE = 10;

  static final int ELEMENT_NODE = 1;

  static final int ENTITY_NODE = 6;

  static final int ENTITY_REFERENCE_NODE = 5;

  static final int NOTATION_NODE = 12;

  static final int PROCESSING_INSTRUCTION_NODE = 7;

  static final int TEXT_NODE = 3;

  /** @domName Node.attributes */
  final NamedNodeMap $dom_attributes;

  /** @domName Node.childNodes */
  final NodeList $dom_childNodes;

  /** @domName Node.firstChild */
  final Node $dom_firstChild;

  /** @domName Node.lastChild */
  final Node $dom_lastChild;

  /** @domName Node.nextSibling */
  final Node nextNode;

  /** @domName Node.nodeType */
  final int $dom_nodeType;

  /** @domName Node.ownerDocument */
  final Document document;

  /** @domName Node.parentNode */
  final Node parent;

  /** @domName Node.previousSibling */
  final Node previousNode;

  /** @domName Node.textContent */
  String text;

  /** @domName Node.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Node.appendChild */
  Node $dom_appendChild(Node newChild);

  /** @domName Node.cloneNode */
  Node clone(bool deep);

  /** @domName Node.contains */
  bool contains(Node other);

  /** @domName Node.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName Node.hasChildNodes */
  bool hasChildNodes();

  /** @domName Node.insertBefore */
  Node insertBefore(Node newChild, Node refChild);

  /** @domName Node.removeChild */
  Node $dom_removeChild(Node oldChild);

  /** @domName Node.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Node.replaceChild */
  Node $dom_replaceChild(Node newChild, Node oldChild);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeFilter
interface NodeFilter {

  static final int FILTER_ACCEPT = 1;

  static final int FILTER_REJECT = 2;

  static final int FILTER_SKIP = 3;

  static final int SHOW_ALL = 0xFFFFFFFF;

  static final int SHOW_ATTRIBUTE = 0x00000002;

  static final int SHOW_CDATA_SECTION = 0x00000008;

  static final int SHOW_COMMENT = 0x00000080;

  static final int SHOW_DOCUMENT = 0x00000100;

  static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  static final int SHOW_DOCUMENT_TYPE = 0x00000200;

  static final int SHOW_ELEMENT = 0x00000001;

  static final int SHOW_ENTITY = 0x00000020;

  static final int SHOW_ENTITY_REFERENCE = 0x00000010;

  static final int SHOW_NOTATION = 0x00000800;

  static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  static final int SHOW_TEXT = 0x00000004;

  /** @domName NodeFilter.acceptNode */
  int acceptNode(Node n);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeIterator
interface NodeIterator {

  /** @domName NodeIterator.expandEntityReferences */
  final bool expandEntityReferences;

  /** @domName NodeIterator.filter */
  final NodeFilter filter;

  /** @domName NodeIterator.pointerBeforeReferenceNode */
  final bool pointerBeforeReferenceNode;

  /** @domName NodeIterator.referenceNode */
  final Node referenceNode;

  /** @domName NodeIterator.root */
  final Node root;

  /** @domName NodeIterator.whatToShow */
  final int whatToShow;

  /** @domName NodeIterator.detach */
  void detach();

  /** @domName NodeIterator.nextNode */
  Node nextNode();

  /** @domName NodeIterator.previousNode */
  Node previousNode();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeList
interface NodeList extends List<Node> {

  NodeList filter(bool f(Node element));

  NodeList getRange(int start, int length);

  Node get first();


  /** @domName NodeList.length */
  final int length;

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeSelector
interface NodeSelector {

  // TODO(nweiz): add this back once DocumentFragment is ported.
  // ElementList queryAll(String selectors);


  /** @domName NodeSelector.querySelector */
  Element query(String selectors);

  /** @domName NodeSelector.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Notation
interface Notation extends Node {

  /** @domName Notation.publicId */
  final String publicId;

  /** @domName Notation.systemId */
  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Notification
interface Notification extends EventTarget default _NotificationFactoryProvider {

  Notification(String title, [Map options]);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  NotificationEvents get on();

  /** @domName Notification.dir */
  String dir;

  /** @domName Notification.replaceId */
  String replaceId;

  /** @domName Notification.tag */
  String tag;

  /** @domName Notification.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Notification.cancel */
  void cancel();

  /** @domName Notification.close */
  void close();

  /** @domName Notification.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName Notification.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName Notification.show */
  void show();
}

interface NotificationEvents extends Events {

  EventListenerList get click();

  EventListenerList get close();

  EventListenerList get display();

  EventListenerList get error();

  EventListenerList get show();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NotificationCenter
interface NotificationCenter {

  /** @domName NotificationCenter.checkPermission */
  int checkPermission();

  /** @domName NotificationCenter.createHTMLNotification */
  Notification createHTMLNotification(String url);

  /** @domName NotificationCenter.createNotification */
  Notification createNotification(String iconUrl, String title, String body);

  /** @domName NotificationCenter.requestPermission */
  void requestPermission(VoidCallback callback);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NotificationPermissionCallback(String permission);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESStandardDerivatives
interface OESStandardDerivatives {

  static final int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESTextureFloat
interface OESTextureFloat {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESVertexArrayObject
interface OESVertexArrayObject {

  static final int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  /** @domName OESVertexArrayObject.bindVertexArrayOES */
  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  /** @domName OESVertexArrayObject.createVertexArrayOES */
  WebGLVertexArrayObjectOES createVertexArrayOES();

  /** @domName OESVertexArrayObject.deleteVertexArrayOES */
  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  /** @domName OESVertexArrayObject.isVertexArrayOES */
  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOListElement
interface OListElement extends Element default _Elements {

  OListElement();

  /** @domName HTMLOListElement.compact */
  bool compact;

  /** @domName HTMLOListElement.reversed */
  bool reversed;

  /** @domName HTMLOListElement.start */
  int start;

  /** @domName HTMLOListElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLObjectElement
interface ObjectElement extends Element default _Elements {

  ObjectElement();

  /** @domName HTMLObjectElement.align */
  String align;

  /** @domName HTMLObjectElement.archive */
  String archive;

  /** @domName HTMLObjectElement.border */
  String border;

  /** @domName HTMLObjectElement.code */
  String code;

  /** @domName HTMLObjectElement.codeBase */
  String codeBase;

  /** @domName HTMLObjectElement.codeType */
  String codeType;

  /** @domName HTMLObjectElement.contentDocument */
  final Document contentDocument;

  /** @domName HTMLObjectElement.data */
  String data;

  /** @domName HTMLObjectElement.declare */
  bool declare;

  /** @domName HTMLObjectElement.form */
  final FormElement form;

  /** @domName HTMLObjectElement.height */
  String height;

  /** @domName HTMLObjectElement.hspace */
  int hspace;

  /** @domName HTMLObjectElement.name */
  String name;

  /** @domName HTMLObjectElement.standby */
  String standby;

  /** @domName HTMLObjectElement.type */
  String type;

  /** @domName HTMLObjectElement.useMap */
  String useMap;

  /** @domName HTMLObjectElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLObjectElement.validity */
  final ValidityState validity;

  /** @domName HTMLObjectElement.vspace */
  int vspace;

  /** @domName HTMLObjectElement.width */
  String width;

  /** @domName HTMLObjectElement.willValidate */
  final bool willValidate;

  /** @domName HTMLObjectElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLObjectElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OfflineAudioCompletionEvent
interface OfflineAudioCompletionEvent extends Event {

  /** @domName OfflineAudioCompletionEvent.renderedBuffer */
  final AudioBuffer renderedBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OperationNotAllowedException
interface OperationNotAllowedException {

  static final int NOT_ALLOWED_ERR = 1;

  /** @domName OperationNotAllowedException.code */
  final int code;

  /** @domName OperationNotAllowedException.message */
  final String message;

  /** @domName OperationNotAllowedException.name */
  final String name;

  /** @domName OperationNotAllowedException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptGroupElement
interface OptGroupElement extends Element default _Elements {

  OptGroupElement();

  /** @domName HTMLOptGroupElement.disabled */
  bool disabled;

  /** @domName HTMLOptGroupElement.label */
  String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptionElement
interface OptionElement extends Element default _OptionElementFactoryProvider {

  OptionElement([String data, String value, bool defaultSelected, bool selected]);

  /** @domName HTMLOptionElement.defaultSelected */
  bool defaultSelected;

  /** @domName HTMLOptionElement.disabled */
  bool disabled;

  /** @domName HTMLOptionElement.form */
  final FormElement form;

  /** @domName HTMLOptionElement.index */
  final int index;

  /** @domName HTMLOptionElement.label */
  String label;

  /** @domName HTMLOptionElement.selected */
  bool selected;

  /** @domName HTMLOptionElement.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Oscillator
interface Oscillator extends AudioSourceNode {

  static final int CUSTOM = 4;

  static final int FINISHED_STATE = 3;

  static final int PLAYING_STATE = 2;

  static final int SAWTOOTH = 2;

  static final int SCHEDULED_STATE = 1;

  static final int SINE = 0;

  static final int SQUARE = 1;

  static final int TRIANGLE = 3;

  static final int UNSCHEDULED_STATE = 0;

  /** @domName Oscillator.detune */
  final AudioParam detune;

  /** @domName Oscillator.frequency */
  final AudioParam frequency;

  /** @domName Oscillator.playbackState */
  final int playbackState;

  /** @domName Oscillator.type */
  int type;

  /** @domName Oscillator.noteOff */
  void noteOff(num when);

  /** @domName Oscillator.noteOn */
  void noteOn(num when);

  /** @domName Oscillator.setWaveTable */
  void setWaveTable(WaveTable waveTable);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOutputElement
interface OutputElement extends Element default _Elements {

  OutputElement();

  /** @domName HTMLOutputElement.defaultValue */
  String defaultValue;

  /** @domName HTMLOutputElement.form */
  final FormElement form;

  /** @domName HTMLOutputElement.htmlFor */
  DOMSettableTokenList htmlFor;

  /** @domName HTMLOutputElement.labels */
  final NodeList labels;

  /** @domName HTMLOutputElement.name */
  String name;

  /** @domName HTMLOutputElement.type */
  final String type;

  /** @domName HTMLOutputElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLOutputElement.validity */
  final ValidityState validity;

  /** @domName HTMLOutputElement.value */
  String value;

  /** @domName HTMLOutputElement.willValidate */
  final bool willValidate;

  /** @domName HTMLOutputElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLOutputElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OverflowEvent
interface OverflowEvent extends Event {

  static final int BOTH = 2;

  static final int HORIZONTAL = 0;

  static final int VERTICAL = 1;

  /** @domName OverflowEvent.horizontalOverflow */
  final bool horizontalOverflow;

  /** @domName OverflowEvent.orient */
  final int orient;

  /** @domName OverflowEvent.verticalOverflow */
  final bool verticalOverflow;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PageTransitionEvent
interface PageTransitionEvent extends Event {

  /** @domName PageTransitionEvent.persisted */
  final bool persisted;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLParagraphElement
interface ParagraphElement extends Element default _Elements {

  ParagraphElement();

  /** @domName HTMLParagraphElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLParamElement
interface ParamElement extends Element default _Elements {

  ParamElement();

  /** @domName HTMLParamElement.name */
  String name;

  /** @domName HTMLParamElement.type */
  String type;

  /** @domName HTMLParamElement.value */
  String value;

  /** @domName HTMLParamElement.valueType */
  String valueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PeerConnection00
interface PeerConnection00 extends EventTarget default _PeerConnection00FactoryProvider {

  PeerConnection00(String serverConfiguration, IceCallback iceCallback);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  PeerConnection00Events get on();

  static final int ACTIVE = 2;

  static final int CLOSED = 3;

  static final int ICE_CHECKING = 0x300;

  static final int ICE_CLOSED = 0x700;

  static final int ICE_COMPLETED = 0x500;

  static final int ICE_CONNECTED = 0x400;

  static final int ICE_FAILED = 0x600;

  static final int ICE_GATHERING = 0x100;

  static final int ICE_WAITING = 0x200;

  static final int NEW = 0;

  static final int OPENING = 1;

  static final int SDP_ANSWER = 0x300;

  static final int SDP_OFFER = 0x100;

  static final int SDP_PRANSWER = 0x200;

  /** @domName PeerConnection00.iceState */
  final int iceState;

  /** @domName PeerConnection00.localDescription */
  final SessionDescription localDescription;

  /** @domName PeerConnection00.localStreams */
  final MediaStreamList localStreams;

  /** @domName PeerConnection00.readyState */
  final int readyState;

  /** @domName PeerConnection00.remoteDescription */
  final SessionDescription remoteDescription;

  /** @domName PeerConnection00.remoteStreams */
  final MediaStreamList remoteStreams;

  /** @domName PeerConnection00.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName PeerConnection00.addStream */
  void addStream(MediaStream stream, [Map mediaStreamHints]);

  /** @domName PeerConnection00.close */
  void close();

  /** @domName PeerConnection00.createAnswer */
  SessionDescription createAnswer(String offer, [Map mediaHints]);

  /** @domName PeerConnection00.createOffer */
  SessionDescription createOffer([Map mediaHints]);

  /** @domName PeerConnection00.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName PeerConnection00.processIceMessage */
  void processIceMessage(IceCandidate candidate);

  /** @domName PeerConnection00.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName PeerConnection00.removeStream */
  void removeStream(MediaStream stream);

  /** @domName PeerConnection00.setLocalDescription */
  void setLocalDescription(int action, SessionDescription desc);

  /** @domName PeerConnection00.setRemoteDescription */
  void setRemoteDescription(int action, SessionDescription desc);

  /** @domName PeerConnection00.startIce */
  void startIce([Map iceOptions]);
}

interface PeerConnection00Events extends Events {

  EventListenerList get addStream();

  EventListenerList get connecting();

  EventListenerList get open();

  EventListenerList get removeStream();

  EventListenerList get stateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Performance
interface Performance {

  /** @domName Performance.memory */
  final MemoryInfo memory;

  /** @domName Performance.navigation */
  final PerformanceNavigation navigation;

  /** @domName Performance.timing */
  final PerformanceTiming timing;

  /** @domName Performance.webkitNow */
  num webkitNow();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PerformanceNavigation
interface PerformanceNavigation {

  static final int TYPE_BACK_FORWARD = 2;

  static final int TYPE_NAVIGATE = 0;

  static final int TYPE_RELOAD = 1;

  static final int TYPE_RESERVED = 255;

  /** @domName PerformanceNavigation.redirectCount */
  final int redirectCount;

  /** @domName PerformanceNavigation.type */
  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PerformanceTiming
interface PerformanceTiming {

  /** @domName PerformanceTiming.connectEnd */
  final int connectEnd;

  /** @domName PerformanceTiming.connectStart */
  final int connectStart;

  /** @domName PerformanceTiming.domComplete */
  final int domComplete;

  /** @domName PerformanceTiming.domContentLoadedEventEnd */
  final int domContentLoadedEventEnd;

  /** @domName PerformanceTiming.domContentLoadedEventStart */
  final int domContentLoadedEventStart;

  /** @domName PerformanceTiming.domInteractive */
  final int domInteractive;

  /** @domName PerformanceTiming.domLoading */
  final int domLoading;

  /** @domName PerformanceTiming.domainLookupEnd */
  final int domainLookupEnd;

  /** @domName PerformanceTiming.domainLookupStart */
  final int domainLookupStart;

  /** @domName PerformanceTiming.fetchStart */
  final int fetchStart;

  /** @domName PerformanceTiming.loadEventEnd */
  final int loadEventEnd;

  /** @domName PerformanceTiming.loadEventStart */
  final int loadEventStart;

  /** @domName PerformanceTiming.navigationStart */
  final int navigationStart;

  /** @domName PerformanceTiming.redirectEnd */
  final int redirectEnd;

  /** @domName PerformanceTiming.redirectStart */
  final int redirectStart;

  /** @domName PerformanceTiming.requestStart */
  final int requestStart;

  /** @domName PerformanceTiming.responseEnd */
  final int responseEnd;

  /** @domName PerformanceTiming.responseStart */
  final int responseStart;

  /** @domName PerformanceTiming.secureConnectionStart */
  final int secureConnectionStart;

  /** @domName PerformanceTiming.unloadEventEnd */
  final int unloadEventEnd;

  /** @domName PerformanceTiming.unloadEventStart */
  final int unloadEventStart;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitPoint
interface Point default _PointFactoryProvider {

  Point(num x, num y);

  /** @domName WebKitPoint.x */
  num x;

  /** @domName WebKitPoint.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PointerLock
interface PointerLock {

  /** @domName PointerLock.isLocked */
  final bool isLocked;

  /** @domName PointerLock.lock */
  void lock(Element target, [VoidCallback successCallback, VoidCallback failureCallback]);

  /** @domName PointerLock.unlock */
  void unlock();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PopStateEvent
interface PopStateEvent extends Event {

  /** @domName PopStateEvent.state */
  final Object state;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionCallback(Geoposition position);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PositionError
interface PositionError {

  static final int PERMISSION_DENIED = 1;

  static final int POSITION_UNAVAILABLE = 2;

  static final int TIMEOUT = 3;

  /** @domName PositionError.code */
  final int code;

  /** @domName PositionError.message */
  final String message;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionErrorCallback(PositionError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLPreElement
interface PreElement extends Element default _Elements {

  PreElement();

  /** @domName HTMLPreElement.width */
  int width;

  /** @domName HTMLPreElement.wrap */
  bool wrap;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ProcessingInstruction
interface ProcessingInstruction extends Node {

  /** @domName ProcessingInstruction.data */
  String data;

  /** @domName ProcessingInstruction.sheet */
  final StyleSheet sheet;

  /** @domName ProcessingInstruction.target */
  final String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLProgressElement
interface ProgressElement extends Element default _Elements {

  ProgressElement();

  /** @domName HTMLProgressElement.labels */
  final NodeList labels;

  /** @domName HTMLProgressElement.max */
  num max;

  /** @domName HTMLProgressElement.position */
  final num position;

  /** @domName HTMLProgressElement.value */
  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ProgressEvent
interface ProgressEvent extends Event {

  /** @domName ProgressEvent.lengthComputable */
  final bool lengthComputable;

  /** @domName ProgressEvent.loaded */
  final int loaded;

  /** @domName ProgressEvent.total */
  final int total;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLQuoteElement
interface QuoteElement extends Element {

  /** @domName HTMLQuoteElement.cite */
  String cite;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RGBColor
interface RGBColor {

  /** @domName RGBColor.blue */
  final CSSPrimitiveValue blue;

  /** @domName RGBColor.green */
  final CSSPrimitiveValue green;

  /** @domName RGBColor.red */
  final CSSPrimitiveValue red;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RadioNodeList
interface RadioNodeList extends NodeList {

  /** @domName RadioNodeList.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Range
interface Range {

  static final int END_TO_END = 2;

  static final int END_TO_START = 3;

  static final int NODE_AFTER = 1;

  static final int NODE_BEFORE = 0;

  static final int NODE_BEFORE_AND_AFTER = 2;

  static final int NODE_INSIDE = 3;

  static final int START_TO_END = 1;

  static final int START_TO_START = 0;

  /** @domName Range.collapsed */
  final bool collapsed;

  /** @domName Range.commonAncestorContainer */
  final Node commonAncestorContainer;

  /** @domName Range.endContainer */
  final Node endContainer;

  /** @domName Range.endOffset */
  final int endOffset;

  /** @domName Range.startContainer */
  final Node startContainer;

  /** @domName Range.startOffset */
  final int startOffset;

  /** @domName Range.cloneContents */
  DocumentFragment cloneContents();

  /** @domName Range.cloneRange */
  Range cloneRange();

  /** @domName Range.collapse */
  void collapse(bool toStart);

  /** @domName Range.compareNode */
  int compareNode(Node refNode);

  /** @domName Range.comparePoint */
  int comparePoint(Node refNode, int offset);

  /** @domName Range.createContextualFragment */
  DocumentFragment createContextualFragment(String html);

  /** @domName Range.deleteContents */
  void deleteContents();

  /** @domName Range.detach */
  void detach();

  /** @domName Range.expand */
  void expand(String unit);

  /** @domName Range.extractContents */
  DocumentFragment extractContents();

  /** @domName Range.getBoundingClientRect */
  ClientRect getBoundingClientRect();

  /** @domName Range.getClientRects */
  ClientRectList getClientRects();

  /** @domName Range.insertNode */
  void insertNode(Node newNode);

  /** @domName Range.intersectsNode */
  bool intersectsNode(Node refNode);

  /** @domName Range.isPointInRange */
  bool isPointInRange(Node refNode, int offset);

  /** @domName Range.selectNode */
  void selectNode(Node refNode);

  /** @domName Range.selectNodeContents */
  void selectNodeContents(Node refNode);

  /** @domName Range.setEnd */
  void setEnd(Node refNode, int offset);

  /** @domName Range.setEndAfter */
  void setEndAfter(Node refNode);

  /** @domName Range.setEndBefore */
  void setEndBefore(Node refNode);

  /** @domName Range.setStart */
  void setStart(Node refNode, int offset);

  /** @domName Range.setStartAfter */
  void setStartAfter(Node refNode);

  /** @domName Range.setStartBefore */
  void setStartBefore(Node refNode);

  /** @domName Range.surroundContents */
  void surroundContents(Node newParent);

  /** @domName Range.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RangeException
interface RangeException {

  static final int BAD_BOUNDARYPOINTS_ERR = 1;

  static final int INVALID_NODE_TYPE_ERR = 2;

  /** @domName RangeException.code */
  final int code;

  /** @domName RangeException.message */
  final String message;

  /** @domName RangeException.name */
  final String name;

  /** @domName RangeException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RealtimeAnalyserNode
interface RealtimeAnalyserNode extends AudioNode {

  /** @domName RealtimeAnalyserNode.fftSize */
  int fftSize;

  /** @domName RealtimeAnalyserNode.frequencyBinCount */
  final int frequencyBinCount;

  /** @domName RealtimeAnalyserNode.maxDecibels */
  num maxDecibels;

  /** @domName RealtimeAnalyserNode.minDecibels */
  num minDecibels;

  /** @domName RealtimeAnalyserNode.smoothingTimeConstant */
  num smoothingTimeConstant;

  /** @domName RealtimeAnalyserNode.getByteFrequencyData */
  void getByteFrequencyData(Uint8Array array);

  /** @domName RealtimeAnalyserNode.getByteTimeDomainData */
  void getByteTimeDomainData(Uint8Array array);

  /** @domName RealtimeAnalyserNode.getFloatFrequencyData */
  void getFloatFrequencyData(Float32Array array);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Rect
interface Rect {

  /** @domName Rect.bottom */
  final CSSPrimitiveValue bottom;

  /** @domName Rect.left */
  final CSSPrimitiveValue left;

  /** @domName Rect.right */
  final CSSPrimitiveValue right;

  /** @domName Rect.top */
  final CSSPrimitiveValue top;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool RequestAnimationFrameCallback(int time);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLError
interface SQLError {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  /** @domName SQLError.code */
  final int code;

  /** @domName SQLError.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLException
interface SQLException {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  /** @domName SQLException.code */
  final int code;

  /** @domName SQLException.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLResultSet
interface SQLResultSet {

  /** @domName SQLResultSet.insertId */
  final int insertId;

  /** @domName SQLResultSet.rows */
  final SQLResultSetRowList rows;

  /** @domName SQLResultSet.rowsAffected */
  final int rowsAffected;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLResultSetRowList
interface SQLResultSetRowList {

  /** @domName SQLResultSetRowList.length */
  final int length;

  /** @domName SQLResultSetRowList.item */
  Object item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementCallback(SQLTransaction transaction, SQLResultSet resultSet);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementErrorCallback(SQLTransaction transaction, SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLTransaction
interface SQLTransaction {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionCallback(SQLTransaction transaction);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionErrorCallback(SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLTransactionSync
interface SQLTransactionSync {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionSyncCallback(SQLTransactionSync transaction);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAElement
interface SVGAElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGAElement.target */
  final SVGAnimatedString target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphDefElement
interface SVGAltGlyphDefElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphElement
interface SVGAltGlyphElement extends SVGTextPositioningElement, SVGURIReference {

  /** @domName SVGAltGlyphElement.format */
  String format;

  /** @domName SVGAltGlyphElement.glyphRef */
  String glyphRef;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphItemElement
interface SVGAltGlyphItemElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAngle
interface SVGAngle {

  static final int SVG_ANGLETYPE_DEG = 2;

  static final int SVG_ANGLETYPE_GRAD = 4;

  static final int SVG_ANGLETYPE_RAD = 3;

  static final int SVG_ANGLETYPE_UNKNOWN = 0;

  static final int SVG_ANGLETYPE_UNSPECIFIED = 1;

  /** @domName SVGAngle.unitType */
  final int unitType;

  /** @domName SVGAngle.value */
  num value;

  /** @domName SVGAngle.valueAsString */
  String valueAsString;

  /** @domName SVGAngle.valueInSpecifiedUnits */
  num valueInSpecifiedUnits;

  /** @domName SVGAngle.convertToSpecifiedUnits */
  void convertToSpecifiedUnits(int unitType);

  /** @domName SVGAngle.newValueSpecifiedUnits */
  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateColorElement
interface SVGAnimateColorElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateElement
interface SVGAnimateElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateMotionElement
interface SVGAnimateMotionElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateTransformElement
interface SVGAnimateTransformElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedAngle
interface SVGAnimatedAngle {

  /** @domName SVGAnimatedAngle.animVal */
  final SVGAngle animVal;

  /** @domName SVGAnimatedAngle.baseVal */
  final SVGAngle baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedBoolean
interface SVGAnimatedBoolean {

  /** @domName SVGAnimatedBoolean.animVal */
  final bool animVal;

  /** @domName SVGAnimatedBoolean.baseVal */
  bool baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedEnumeration
interface SVGAnimatedEnumeration {

  /** @domName SVGAnimatedEnumeration.animVal */
  final int animVal;

  /** @domName SVGAnimatedEnumeration.baseVal */
  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedInteger
interface SVGAnimatedInteger {

  /** @domName SVGAnimatedInteger.animVal */
  final int animVal;

  /** @domName SVGAnimatedInteger.baseVal */
  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedLength
interface SVGAnimatedLength {

  /** @domName SVGAnimatedLength.animVal */
  final SVGLength animVal;

  /** @domName SVGAnimatedLength.baseVal */
  final SVGLength baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedLengthList
interface SVGAnimatedLengthList {

  /** @domName SVGAnimatedLengthList.animVal */
  final SVGLengthList animVal;

  /** @domName SVGAnimatedLengthList.baseVal */
  final SVGLengthList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedNumber
interface SVGAnimatedNumber {

  /** @domName SVGAnimatedNumber.animVal */
  final num animVal;

  /** @domName SVGAnimatedNumber.baseVal */
  num baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedNumberList
interface SVGAnimatedNumberList {

  /** @domName SVGAnimatedNumberList.animVal */
  final SVGNumberList animVal;

  /** @domName SVGAnimatedNumberList.baseVal */
  final SVGNumberList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedPreserveAspectRatio
interface SVGAnimatedPreserveAspectRatio {

  /** @domName SVGAnimatedPreserveAspectRatio.animVal */
  final SVGPreserveAspectRatio animVal;

  /** @domName SVGAnimatedPreserveAspectRatio.baseVal */
  final SVGPreserveAspectRatio baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedRect
interface SVGAnimatedRect {

  /** @domName SVGAnimatedRect.animVal */
  final SVGRect animVal;

  /** @domName SVGAnimatedRect.baseVal */
  final SVGRect baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedString
interface SVGAnimatedString {

  /** @domName SVGAnimatedString.animVal */
  final String animVal;

  /** @domName SVGAnimatedString.baseVal */
  String baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedTransformList
interface SVGAnimatedTransformList {

  /** @domName SVGAnimatedTransformList.animVal */
  final SVGTransformList animVal;

  /** @domName SVGAnimatedTransformList.baseVal */
  final SVGTransformList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimationElement
interface SVGAnimationElement extends SVGElement, SVGTests, SVGExternalResourcesRequired, ElementTimeControl {

  /** @domName SVGAnimationElement.targetElement */
  final SVGElement targetElement;

  /** @domName SVGAnimationElement.getCurrentTime */
  num getCurrentTime();

  /** @domName SVGAnimationElement.getSimpleDuration */
  num getSimpleDuration();

  /** @domName SVGAnimationElement.getStartTime */
  num getStartTime();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGCircleElement
interface SVGCircleElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGCircleElement.cx */
  final SVGAnimatedLength cx;

  /** @domName SVGCircleElement.cy */
  final SVGAnimatedLength cy;

  /** @domName SVGCircleElement.r */
  final SVGAnimatedLength r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGClipPathElement
interface SVGClipPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGClipPathElement.clipPathUnits */
  final SVGAnimatedEnumeration clipPathUnits;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGColor
interface SVGColor extends CSSValue {

  static final int SVG_COLORTYPE_CURRENTCOLOR = 3;

  static final int SVG_COLORTYPE_RGBCOLOR = 1;

  static final int SVG_COLORTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_COLORTYPE_UNKNOWN = 0;

  /** @domName SVGColor.colorType */
  final int colorType;

  /** @domName SVGColor.rgbColor */
  final RGBColor rgbColor;

  /** @domName SVGColor.setColor */
  void setColor(int colorType, String rgbColor, String iccColor);

  /** @domName SVGColor.setRGBColor */
  void setRGBColor(String rgbColor);

  /** @domName SVGColor.setRGBColorICCColor */
  void setRGBColorICCColor(String rgbColor, String iccColor);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGComponentTransferFunctionElement
interface SVGComponentTransferFunctionElement extends SVGElement {

  static final int SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;

  /** @domName SVGComponentTransferFunctionElement.amplitude */
  final SVGAnimatedNumber amplitude;

  /** @domName SVGComponentTransferFunctionElement.exponent */
  final SVGAnimatedNumber exponent;

  /** @domName SVGComponentTransferFunctionElement.intercept */
  final SVGAnimatedNumber intercept;

  /** @domName SVGComponentTransferFunctionElement.offset */
  final SVGAnimatedNumber offset;

  /** @domName SVGComponentTransferFunctionElement.slope */
  final SVGAnimatedNumber slope;

  /** @domName SVGComponentTransferFunctionElement.tableValues */
  final SVGAnimatedNumberList tableValues;

  /** @domName SVGComponentTransferFunctionElement.type */
  final SVGAnimatedEnumeration type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGCursorElement
interface SVGCursorElement extends SVGElement, SVGURIReference, SVGTests, SVGExternalResourcesRequired {

  /** @domName SVGCursorElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGCursorElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDefsElement
interface SVGDefsElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDescElement
interface SVGDescElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDocument
interface SVGDocument extends Document {

  /** @domName SVGDocument.rootElement */
  final SVGSVGElement rootElement;

  /** @domName SVGDocument.createEvent */
  Event $dom_createEvent(String eventType);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName SVGElement
interface SVGElement extends Element default _SVGElementFactoryProvider {

  SVGElement.tag(String tag);
  SVGElement.svg(String svg);

  SVGElement clone(bool deep);


  /** @domName SVGElement.id */
  String id;

  /** @domName SVGElement.ownerSVGElement */
  final SVGSVGElement ownerSVGElement;

  /** @domName SVGElement.viewportElement */
  final SVGElement viewportElement;

  /** @domName SVGElement.xmlbase */
  String xmlbase;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGElementInstance
interface SVGElementInstance {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SVGElementInstanceEvents get on();

  /** @domName SVGElementInstance.childNodes */
  final SVGElementInstanceList childNodes;

  /** @domName SVGElementInstance.correspondingElement */
  final SVGElement correspondingElement;

  /** @domName SVGElementInstance.correspondingUseElement */
  final SVGUseElement correspondingUseElement;

  /** @domName SVGElementInstance.firstChild */
  final SVGElementInstance firstChild;

  /** @domName SVGElementInstance.lastChild */
  final SVGElementInstance lastChild;

  /** @domName SVGElementInstance.nextSibling */
  final SVGElementInstance nextSibling;

  /** @domName SVGElementInstance.parentNode */
  final SVGElementInstance parentNode;

  /** @domName SVGElementInstance.previousSibling */
  final SVGElementInstance previousSibling;

  /** @domName SVGElementInstance.addEventListener */
  void addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SVGElementInstance.dispatchEvent */
  bool dispatchEvent(Event event);

  /** @domName SVGElementInstance.removeEventListener */
  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface SVGElementInstanceEvents extends Events {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get input();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get reset();

  EventListenerList get resize();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get submit();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGElementInstanceList
interface SVGElementInstanceList {

  /** @domName SVGElementInstanceList.length */
  final int length;

  /** @domName SVGElementInstanceList.item */
  SVGElementInstance item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGEllipseElement
interface SVGEllipseElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGEllipseElement.cx */
  final SVGAnimatedLength cx;

  /** @domName SVGEllipseElement.cy */
  final SVGAnimatedLength cy;

  /** @domName SVGEllipseElement.rx */
  final SVGAnimatedLength rx;

  /** @domName SVGEllipseElement.ry */
  final SVGAnimatedLength ry;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGException
interface SVGException {

  static final int SVG_INVALID_VALUE_ERR = 1;

  static final int SVG_MATRIX_NOT_INVERTABLE = 2;

  static final int SVG_WRONG_TYPE_ERR = 0;

  /** @domName SVGException.code */
  final int code;

  /** @domName SVGException.message */
  final String message;

  /** @domName SVGException.name */
  final String name;

  /** @domName SVGException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGExternalResourcesRequired
interface SVGExternalResourcesRequired {

  /** @domName SVGExternalResourcesRequired.externalResourcesRequired */
  final SVGAnimatedBoolean externalResourcesRequired;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEBlendElement
interface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FEBLEND_MODE_DARKEN = 4;

  static final int SVG_FEBLEND_MODE_LIGHTEN = 5;

  static final int SVG_FEBLEND_MODE_MULTIPLY = 2;

  static final int SVG_FEBLEND_MODE_NORMAL = 1;

  static final int SVG_FEBLEND_MODE_SCREEN = 3;

  static final int SVG_FEBLEND_MODE_UNKNOWN = 0;

  /** @domName SVGFEBlendElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEBlendElement.in2 */
  final SVGAnimatedString in2;

  /** @domName SVGFEBlendElement.mode */
  final SVGAnimatedEnumeration mode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEColorMatrixElement
interface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;

  static final int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;

  static final int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;

  static final int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;

  static final int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;

  /** @domName SVGFEColorMatrixElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEColorMatrixElement.type */
  final SVGAnimatedEnumeration type;

  /** @domName SVGFEColorMatrixElement.values */
  final SVGAnimatedNumberList values;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEComponentTransferElement
interface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEComponentTransferElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFECompositeElement
interface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;

  static final int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;

  static final int SVG_FECOMPOSITE_OPERATOR_IN = 2;

  static final int SVG_FECOMPOSITE_OPERATOR_OUT = 3;

  static final int SVG_FECOMPOSITE_OPERATOR_OVER = 1;

  static final int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;

  static final int SVG_FECOMPOSITE_OPERATOR_XOR = 5;

  /** @domName SVGFECompositeElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFECompositeElement.in2 */
  final SVGAnimatedString in2;

  /** @domName SVGFECompositeElement.k1 */
  final SVGAnimatedNumber k1;

  /** @domName SVGFECompositeElement.k2 */
  final SVGAnimatedNumber k2;

  /** @domName SVGFECompositeElement.k3 */
  final SVGAnimatedNumber k3;

  /** @domName SVGFECompositeElement.k4 */
  final SVGAnimatedNumber k4;

  /** @domName SVGFECompositeElement.operator */
  final SVGAnimatedEnumeration operator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEConvolveMatrixElement
interface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_EDGEMODE_DUPLICATE = 1;

  static final int SVG_EDGEMODE_NONE = 3;

  static final int SVG_EDGEMODE_UNKNOWN = 0;

  static final int SVG_EDGEMODE_WRAP = 2;

  /** @domName SVGFEConvolveMatrixElement.bias */
  final SVGAnimatedNumber bias;

  /** @domName SVGFEConvolveMatrixElement.divisor */
  final SVGAnimatedNumber divisor;

  /** @domName SVGFEConvolveMatrixElement.edgeMode */
  final SVGAnimatedEnumeration edgeMode;

  /** @domName SVGFEConvolveMatrixElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEConvolveMatrixElement.kernelMatrix */
  final SVGAnimatedNumberList kernelMatrix;

  /** @domName SVGFEConvolveMatrixElement.kernelUnitLengthX */
  final SVGAnimatedNumber kernelUnitLengthX;

  /** @domName SVGFEConvolveMatrixElement.kernelUnitLengthY */
  final SVGAnimatedNumber kernelUnitLengthY;

  /** @domName SVGFEConvolveMatrixElement.orderX */
  final SVGAnimatedInteger orderX;

  /** @domName SVGFEConvolveMatrixElement.orderY */
  final SVGAnimatedInteger orderY;

  /** @domName SVGFEConvolveMatrixElement.preserveAlpha */
  final SVGAnimatedBoolean preserveAlpha;

  /** @domName SVGFEConvolveMatrixElement.targetX */
  final SVGAnimatedInteger targetX;

  /** @domName SVGFEConvolveMatrixElement.targetY */
  final SVGAnimatedInteger targetY;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDiffuseLightingElement
interface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEDiffuseLightingElement.diffuseConstant */
  final SVGAnimatedNumber diffuseConstant;

  /** @domName SVGFEDiffuseLightingElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEDiffuseLightingElement.kernelUnitLengthX */
  final SVGAnimatedNumber kernelUnitLengthX;

  /** @domName SVGFEDiffuseLightingElement.kernelUnitLengthY */
  final SVGAnimatedNumber kernelUnitLengthY;

  /** @domName SVGFEDiffuseLightingElement.surfaceScale */
  final SVGAnimatedNumber surfaceScale;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDisplacementMapElement
interface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_CHANNEL_A = 4;

  static final int SVG_CHANNEL_B = 3;

  static final int SVG_CHANNEL_G = 2;

  static final int SVG_CHANNEL_R = 1;

  static final int SVG_CHANNEL_UNKNOWN = 0;

  /** @domName SVGFEDisplacementMapElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEDisplacementMapElement.in2 */
  final SVGAnimatedString in2;

  /** @domName SVGFEDisplacementMapElement.scale */
  final SVGAnimatedNumber scale;

  /** @domName SVGFEDisplacementMapElement.xChannelSelector */
  final SVGAnimatedEnumeration xChannelSelector;

  /** @domName SVGFEDisplacementMapElement.yChannelSelector */
  final SVGAnimatedEnumeration yChannelSelector;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDistantLightElement
interface SVGFEDistantLightElement extends SVGElement {

  /** @domName SVGFEDistantLightElement.azimuth */
  final SVGAnimatedNumber azimuth;

  /** @domName SVGFEDistantLightElement.elevation */
  final SVGAnimatedNumber elevation;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDropShadowElement
interface SVGFEDropShadowElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEDropShadowElement.dx */
  final SVGAnimatedNumber dx;

  /** @domName SVGFEDropShadowElement.dy */
  final SVGAnimatedNumber dy;

  /** @domName SVGFEDropShadowElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEDropShadowElement.stdDeviationX */
  final SVGAnimatedNumber stdDeviationX;

  /** @domName SVGFEDropShadowElement.stdDeviationY */
  final SVGAnimatedNumber stdDeviationY;

  /** @domName SVGFEDropShadowElement.setStdDeviation */
  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFloodElement
interface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncAElement
interface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncBElement
interface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncGElement
interface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncRElement
interface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEGaussianBlurElement
interface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEGaussianBlurElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEGaussianBlurElement.stdDeviationX */
  final SVGAnimatedNumber stdDeviationX;

  /** @domName SVGFEGaussianBlurElement.stdDeviationY */
  final SVGAnimatedNumber stdDeviationY;

  /** @domName SVGFEGaussianBlurElement.setStdDeviation */
  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEImageElement
interface SVGFEImageElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEImageElement.preserveAspectRatio */
  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMergeElement
interface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMergeNodeElement
interface SVGFEMergeNodeElement extends SVGElement {

  /** @domName SVGFEMergeNodeElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMorphologyElement
interface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;

  static final int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;

  static final int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;

  /** @domName SVGFEMorphologyElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEMorphologyElement.operator */
  final SVGAnimatedEnumeration operator;

  /** @domName SVGFEMorphologyElement.radiusX */
  final SVGAnimatedNumber radiusX;

  /** @domName SVGFEMorphologyElement.radiusY */
  final SVGAnimatedNumber radiusY;

  /** @domName SVGFEMorphologyElement.setRadius */
  void setRadius(num radiusX, num radiusY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEOffsetElement
interface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEOffsetElement.dx */
  final SVGAnimatedNumber dx;

  /** @domName SVGFEOffsetElement.dy */
  final SVGAnimatedNumber dy;

  /** @domName SVGFEOffsetElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEPointLightElement
interface SVGFEPointLightElement extends SVGElement {

  /** @domName SVGFEPointLightElement.x */
  final SVGAnimatedNumber x;

  /** @domName SVGFEPointLightElement.y */
  final SVGAnimatedNumber y;

  /** @domName SVGFEPointLightElement.z */
  final SVGAnimatedNumber z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFESpecularLightingElement
interface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFESpecularLightingElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFESpecularLightingElement.specularConstant */
  final SVGAnimatedNumber specularConstant;

  /** @domName SVGFESpecularLightingElement.specularExponent */
  final SVGAnimatedNumber specularExponent;

  /** @domName SVGFESpecularLightingElement.surfaceScale */
  final SVGAnimatedNumber surfaceScale;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFESpotLightElement
interface SVGFESpotLightElement extends SVGElement {

  /** @domName SVGFESpotLightElement.limitingConeAngle */
  final SVGAnimatedNumber limitingConeAngle;

  /** @domName SVGFESpotLightElement.pointsAtX */
  final SVGAnimatedNumber pointsAtX;

  /** @domName SVGFESpotLightElement.pointsAtY */
  final SVGAnimatedNumber pointsAtY;

  /** @domName SVGFESpotLightElement.pointsAtZ */
  final SVGAnimatedNumber pointsAtZ;

  /** @domName SVGFESpotLightElement.specularExponent */
  final SVGAnimatedNumber specularExponent;

  /** @domName SVGFESpotLightElement.x */
  final SVGAnimatedNumber x;

  /** @domName SVGFESpotLightElement.y */
  final SVGAnimatedNumber y;

  /** @domName SVGFESpotLightElement.z */
  final SVGAnimatedNumber z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFETileElement
interface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFETileElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFETurbulenceElement
interface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_STITCHTYPE_NOSTITCH = 2;

  static final int SVG_STITCHTYPE_STITCH = 1;

  static final int SVG_STITCHTYPE_UNKNOWN = 0;

  static final int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;

  static final int SVG_TURBULENCE_TYPE_TURBULENCE = 2;

  static final int SVG_TURBULENCE_TYPE_UNKNOWN = 0;

  /** @domName SVGFETurbulenceElement.baseFrequencyX */
  final SVGAnimatedNumber baseFrequencyX;

  /** @domName SVGFETurbulenceElement.baseFrequencyY */
  final SVGAnimatedNumber baseFrequencyY;

  /** @domName SVGFETurbulenceElement.numOctaves */
  final SVGAnimatedInteger numOctaves;

  /** @domName SVGFETurbulenceElement.seed */
  final SVGAnimatedNumber seed;

  /** @domName SVGFETurbulenceElement.stitchTiles */
  final SVGAnimatedEnumeration stitchTiles;

  /** @domName SVGFETurbulenceElement.type */
  final SVGAnimatedEnumeration type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFilterElement
interface SVGFilterElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  /** @domName SVGFilterElement.filterResX */
  final SVGAnimatedInteger filterResX;

  /** @domName SVGFilterElement.filterResY */
  final SVGAnimatedInteger filterResY;

  /** @domName SVGFilterElement.filterUnits */
  final SVGAnimatedEnumeration filterUnits;

  /** @domName SVGFilterElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGFilterElement.primitiveUnits */
  final SVGAnimatedEnumeration primitiveUnits;

  /** @domName SVGFilterElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGFilterElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGFilterElement.y */
  final SVGAnimatedLength y;

  /** @domName SVGFilterElement.setFilterRes */
  void setFilterRes(int filterResX, int filterResY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFilterPrimitiveStandardAttributes
interface SVGFilterPrimitiveStandardAttributes extends SVGStylable {

  /** @domName SVGFilterPrimitiveStandardAttributes.height */
  final SVGAnimatedLength height;

  /** @domName SVGFilterPrimitiveStandardAttributes.result */
  final SVGAnimatedString result;

  /** @domName SVGFilterPrimitiveStandardAttributes.width */
  final SVGAnimatedLength width;

  /** @domName SVGFilterPrimitiveStandardAttributes.x */
  final SVGAnimatedLength x;

  /** @domName SVGFilterPrimitiveStandardAttributes.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFitToViewBox
interface SVGFitToViewBox {

  /** @domName SVGFitToViewBox.preserveAspectRatio */
  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  /** @domName SVGFitToViewBox.viewBox */
  final SVGAnimatedRect viewBox;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontElement
interface SVGFontElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceElement
interface SVGFontFaceElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceFormatElement
interface SVGFontFaceFormatElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceNameElement
interface SVGFontFaceNameElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceSrcElement
interface SVGFontFaceSrcElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceUriElement
interface SVGFontFaceUriElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGForeignObjectElement
interface SVGForeignObjectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGForeignObjectElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGForeignObjectElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGForeignObjectElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGForeignObjectElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGElement
interface SVGGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGlyphElement
interface SVGGlyphElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGlyphRefElement
interface SVGGlyphRefElement extends SVGElement, SVGURIReference, SVGStylable {

  /** @domName SVGGlyphRefElement.dx */
  num dx;

  /** @domName SVGGlyphRefElement.dy */
  num dy;

  /** @domName SVGGlyphRefElement.format */
  String format;

  /** @domName SVGGlyphRefElement.glyphRef */
  String glyphRef;

  /** @domName SVGGlyphRefElement.x */
  num x;

  /** @domName SVGGlyphRefElement.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGradientElement
interface SVGGradientElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired, SVGStylable {

  static final int SVG_SPREADMETHOD_PAD = 1;

  static final int SVG_SPREADMETHOD_REFLECT = 2;

  static final int SVG_SPREADMETHOD_REPEAT = 3;

  static final int SVG_SPREADMETHOD_UNKNOWN = 0;

  /** @domName SVGGradientElement.gradientTransform */
  final SVGAnimatedTransformList gradientTransform;

  /** @domName SVGGradientElement.gradientUnits */
  final SVGAnimatedEnumeration gradientUnits;

  /** @domName SVGGradientElement.spreadMethod */
  final SVGAnimatedEnumeration spreadMethod;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGHKernElement
interface SVGHKernElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGImageElement
interface SVGImageElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGImageElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGImageElement.preserveAspectRatio */
  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  /** @domName SVGImageElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGImageElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGImageElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLangSpace
interface SVGLangSpace {

  /** @domName SVGLangSpace.xmllang */
  String xmllang;

  /** @domName SVGLangSpace.xmlspace */
  String xmlspace;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLength
interface SVGLength {

  static final int SVG_LENGTHTYPE_CM = 6;

  static final int SVG_LENGTHTYPE_EMS = 3;

  static final int SVG_LENGTHTYPE_EXS = 4;

  static final int SVG_LENGTHTYPE_IN = 8;

  static final int SVG_LENGTHTYPE_MM = 7;

  static final int SVG_LENGTHTYPE_NUMBER = 1;

  static final int SVG_LENGTHTYPE_PC = 10;

  static final int SVG_LENGTHTYPE_PERCENTAGE = 2;

  static final int SVG_LENGTHTYPE_PT = 9;

  static final int SVG_LENGTHTYPE_PX = 5;

  static final int SVG_LENGTHTYPE_UNKNOWN = 0;

  /** @domName SVGLength.unitType */
  final int unitType;

  /** @domName SVGLength.value */
  num value;

  /** @domName SVGLength.valueAsString */
  String valueAsString;

  /** @domName SVGLength.valueInSpecifiedUnits */
  num valueInSpecifiedUnits;

  /** @domName SVGLength.convertToSpecifiedUnits */
  void convertToSpecifiedUnits(int unitType);

  /** @domName SVGLength.newValueSpecifiedUnits */
  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLengthList
interface SVGLengthList {

  /** @domName SVGLengthList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGLengthList.appendItem */
  SVGLength appendItem(SVGLength item);

  /** @domName SVGLengthList.clear */
  void clear();

  /** @domName SVGLengthList.getItem */
  SVGLength getItem(int index);

  /** @domName SVGLengthList.initialize */
  SVGLength initialize(SVGLength item);

  /** @domName SVGLengthList.insertItemBefore */
  SVGLength insertItemBefore(SVGLength item, int index);

  /** @domName SVGLengthList.removeItem */
  SVGLength removeItem(int index);

  /** @domName SVGLengthList.replaceItem */
  SVGLength replaceItem(SVGLength item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLineElement
interface SVGLineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGLineElement.x1 */
  final SVGAnimatedLength x1;

  /** @domName SVGLineElement.x2 */
  final SVGAnimatedLength x2;

  /** @domName SVGLineElement.y1 */
  final SVGAnimatedLength y1;

  /** @domName SVGLineElement.y2 */
  final SVGAnimatedLength y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLinearGradientElement
interface SVGLinearGradientElement extends SVGGradientElement {

  /** @domName SVGLinearGradientElement.x1 */
  final SVGAnimatedLength x1;

  /** @domName SVGLinearGradientElement.x2 */
  final SVGAnimatedLength x2;

  /** @domName SVGLinearGradientElement.y1 */
  final SVGAnimatedLength y1;

  /** @domName SVGLinearGradientElement.y2 */
  final SVGAnimatedLength y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLocatable
interface SVGLocatable {

  /** @domName SVGLocatable.farthestViewportElement */
  final SVGElement farthestViewportElement;

  /** @domName SVGLocatable.nearestViewportElement */
  final SVGElement nearestViewportElement;

  /** @domName SVGLocatable.getBBox */
  SVGRect getBBox();

  /** @domName SVGLocatable.getCTM */
  SVGMatrix getCTM();

  /** @domName SVGLocatable.getScreenCTM */
  SVGMatrix getScreenCTM();

  /** @domName SVGLocatable.getTransformToElement */
  SVGMatrix getTransformToElement(SVGElement element);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMPathElement
interface SVGMPathElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMarkerElement
interface SVGMarkerElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  static final int SVG_MARKERUNITS_STROKEWIDTH = 2;

  static final int SVG_MARKERUNITS_UNKNOWN = 0;

  static final int SVG_MARKERUNITS_USERSPACEONUSE = 1;

  static final int SVG_MARKER_ORIENT_ANGLE = 2;

  static final int SVG_MARKER_ORIENT_AUTO = 1;

  static final int SVG_MARKER_ORIENT_UNKNOWN = 0;

  /** @domName SVGMarkerElement.markerHeight */
  final SVGAnimatedLength markerHeight;

  /** @domName SVGMarkerElement.markerUnits */
  final SVGAnimatedEnumeration markerUnits;

  /** @domName SVGMarkerElement.markerWidth */
  final SVGAnimatedLength markerWidth;

  /** @domName SVGMarkerElement.orientAngle */
  final SVGAnimatedAngle orientAngle;

  /** @domName SVGMarkerElement.orientType */
  final SVGAnimatedEnumeration orientType;

  /** @domName SVGMarkerElement.refX */
  final SVGAnimatedLength refX;

  /** @domName SVGMarkerElement.refY */
  final SVGAnimatedLength refY;

  /** @domName SVGMarkerElement.setOrientToAngle */
  void setOrientToAngle(SVGAngle angle);

  /** @domName SVGMarkerElement.setOrientToAuto */
  void setOrientToAuto();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMaskElement
interface SVGMaskElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  /** @domName SVGMaskElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGMaskElement.maskContentUnits */
  final SVGAnimatedEnumeration maskContentUnits;

  /** @domName SVGMaskElement.maskUnits */
  final SVGAnimatedEnumeration maskUnits;

  /** @domName SVGMaskElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGMaskElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGMaskElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMatrix
interface SVGMatrix {

  /** @domName SVGMatrix.a */
  num a;

  /** @domName SVGMatrix.b */
  num b;

  /** @domName SVGMatrix.c */
  num c;

  /** @domName SVGMatrix.d */
  num d;

  /** @domName SVGMatrix.e */
  num e;

  /** @domName SVGMatrix.f */
  num f;

  /** @domName SVGMatrix.flipX */
  SVGMatrix flipX();

  /** @domName SVGMatrix.flipY */
  SVGMatrix flipY();

  /** @domName SVGMatrix.inverse */
  SVGMatrix inverse();

  /** @domName SVGMatrix.multiply */
  SVGMatrix multiply(SVGMatrix secondMatrix);

  /** @domName SVGMatrix.rotate */
  SVGMatrix rotate(num angle);

  /** @domName SVGMatrix.rotateFromVector */
  SVGMatrix rotateFromVector(num x, num y);

  /** @domName SVGMatrix.scale */
  SVGMatrix scale(num scaleFactor);

  /** @domName SVGMatrix.scaleNonUniform */
  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY);

  /** @domName SVGMatrix.skewX */
  SVGMatrix skewX(num angle);

  /** @domName SVGMatrix.skewY */
  SVGMatrix skewY(num angle);

  /** @domName SVGMatrix.translate */
  SVGMatrix translate(num x, num y);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMetadataElement
interface SVGMetadataElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMissingGlyphElement
interface SVGMissingGlyphElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGNumber
interface SVGNumber {

  /** @domName SVGNumber.value */
  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGNumberList
interface SVGNumberList {

  /** @domName SVGNumberList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGNumberList.appendItem */
  SVGNumber appendItem(SVGNumber item);

  /** @domName SVGNumberList.clear */
  void clear();

  /** @domName SVGNumberList.getItem */
  SVGNumber getItem(int index);

  /** @domName SVGNumberList.initialize */
  SVGNumber initialize(SVGNumber item);

  /** @domName SVGNumberList.insertItemBefore */
  SVGNumber insertItemBefore(SVGNumber item, int index);

  /** @domName SVGNumberList.removeItem */
  SVGNumber removeItem(int index);

  /** @domName SVGNumberList.replaceItem */
  SVGNumber replaceItem(SVGNumber item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPaint
interface SVGPaint extends SVGColor {

  static final int SVG_PAINTTYPE_CURRENTCOLOR = 102;

  static final int SVG_PAINTTYPE_NONE = 101;

  static final int SVG_PAINTTYPE_RGBCOLOR = 1;

  static final int SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_PAINTTYPE_UNKNOWN = 0;

  static final int SVG_PAINTTYPE_URI = 107;

  static final int SVG_PAINTTYPE_URI_CURRENTCOLOR = 104;

  static final int SVG_PAINTTYPE_URI_NONE = 103;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR = 105;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR = 106;

  /** @domName SVGPaint.paintType */
  final int paintType;

  /** @domName SVGPaint.uri */
  final String uri;

  /** @domName SVGPaint.setPaint */
  void setPaint(int paintType, String uri, String rgbColor, String iccColor);

  /** @domName SVGPaint.setUri */
  void setUri(String uri);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathElement
interface SVGPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPathElement.animatedNormalizedPathSegList */
  final SVGPathSegList animatedNormalizedPathSegList;

  /** @domName SVGPathElement.animatedPathSegList */
  final SVGPathSegList animatedPathSegList;

  /** @domName SVGPathElement.normalizedPathSegList */
  final SVGPathSegList normalizedPathSegList;

  /** @domName SVGPathElement.pathLength */
  final SVGAnimatedNumber pathLength;

  /** @domName SVGPathElement.pathSegList */
  final SVGPathSegList pathSegList;

  /** @domName SVGPathElement.createSVGPathSegArcAbs */
  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  /** @domName SVGPathElement.createSVGPathSegArcRel */
  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  /** @domName SVGPathElement.createSVGPathSegClosePath */
  SVGPathSegClosePath createSVGPathSegClosePath();

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicAbs */
  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicRel */
  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicSmoothAbs */
  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicSmoothRel */
  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticAbs */
  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticRel */
  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothAbs */
  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothRel */
  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoAbs */
  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoHorizontalAbs */
  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x);

  /** @domName SVGPathElement.createSVGPathSegLinetoHorizontalRel */
  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x);

  /** @domName SVGPathElement.createSVGPathSegLinetoRel */
  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoVerticalAbs */
  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoVerticalRel */
  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y);

  /** @domName SVGPathElement.createSVGPathSegMovetoAbs */
  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegMovetoRel */
  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y);

  /** @domName SVGPathElement.getPathSegAtLength */
  int getPathSegAtLength(num distance);

  /** @domName SVGPathElement.getPointAtLength */
  SVGPoint getPointAtLength(num distance);

  /** @domName SVGPathElement.getTotalLength */
  num getTotalLength();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSeg
interface SVGPathSeg {

  static final int PATHSEG_ARC_ABS = 10;

  static final int PATHSEG_ARC_REL = 11;

  static final int PATHSEG_CLOSEPATH = 1;

  static final int PATHSEG_CURVETO_CUBIC_ABS = 6;

  static final int PATHSEG_CURVETO_CUBIC_REL = 7;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;

  static final int PATHSEG_CURVETO_QUADRATIC_ABS = 8;

  static final int PATHSEG_CURVETO_QUADRATIC_REL = 9;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

  static final int PATHSEG_LINETO_ABS = 4;

  static final int PATHSEG_LINETO_HORIZONTAL_ABS = 12;

  static final int PATHSEG_LINETO_HORIZONTAL_REL = 13;

  static final int PATHSEG_LINETO_REL = 5;

  static final int PATHSEG_LINETO_VERTICAL_ABS = 14;

  static final int PATHSEG_LINETO_VERTICAL_REL = 15;

  static final int PATHSEG_MOVETO_ABS = 2;

  static final int PATHSEG_MOVETO_REL = 3;

  static final int PATHSEG_UNKNOWN = 0;

  /** @domName SVGPathSeg.pathSegType */
  final int pathSegType;

  /** @domName SVGPathSeg.pathSegTypeAsLetter */
  final String pathSegTypeAsLetter;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegArcAbs
interface SVGPathSegArcAbs extends SVGPathSeg {

  /** @domName SVGPathSegArcAbs.angle */
  num angle;

  /** @domName SVGPathSegArcAbs.largeArcFlag */
  bool largeArcFlag;

  /** @domName SVGPathSegArcAbs.r1 */
  num r1;

  /** @domName SVGPathSegArcAbs.r2 */
  num r2;

  /** @domName SVGPathSegArcAbs.sweepFlag */
  bool sweepFlag;

  /** @domName SVGPathSegArcAbs.x */
  num x;

  /** @domName SVGPathSegArcAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegArcRel
interface SVGPathSegArcRel extends SVGPathSeg {

  /** @domName SVGPathSegArcRel.angle */
  num angle;

  /** @domName SVGPathSegArcRel.largeArcFlag */
  bool largeArcFlag;

  /** @domName SVGPathSegArcRel.r1 */
  num r1;

  /** @domName SVGPathSegArcRel.r2 */
  num r2;

  /** @domName SVGPathSegArcRel.sweepFlag */
  bool sweepFlag;

  /** @domName SVGPathSegArcRel.x */
  num x;

  /** @domName SVGPathSegArcRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegClosePath
interface SVGPathSegClosePath extends SVGPathSeg {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicAbs
interface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicAbs.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoCubicAbs.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicAbs.y1 */
  num y1;

  /** @domName SVGPathSegCurvetoCubicAbs.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicRel
interface SVGPathSegCurvetoCubicRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicRel.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicRel.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoCubicRel.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicRel.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicRel.y1 */
  num y1;

  /** @domName SVGPathSegCurvetoCubicRel.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicSmoothAbs
interface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicSmoothRel
interface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicSmoothRel.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticAbs
interface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticAbs.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoQuadraticAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoQuadraticAbs.y1 */
  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticRel
interface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticRel.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticRel.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoQuadraticRel.y */
  num y;

  /** @domName SVGPathSegCurvetoQuadraticRel.y1 */
  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticSmoothAbs
interface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticSmoothAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticSmoothAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticSmoothRel
interface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticSmoothRel.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticSmoothRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoAbs
interface SVGPathSegLinetoAbs extends SVGPathSeg {

  /** @domName SVGPathSegLinetoAbs.x */
  num x;

  /** @domName SVGPathSegLinetoAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoHorizontalAbs
interface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {

  /** @domName SVGPathSegLinetoHorizontalAbs.x */
  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoHorizontalRel
interface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {

  /** @domName SVGPathSegLinetoHorizontalRel.x */
  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoRel
interface SVGPathSegLinetoRel extends SVGPathSeg {

  /** @domName SVGPathSegLinetoRel.x */
  num x;

  /** @domName SVGPathSegLinetoRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoVerticalAbs
interface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {

  /** @domName SVGPathSegLinetoVerticalAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoVerticalRel
interface SVGPathSegLinetoVerticalRel extends SVGPathSeg {

  /** @domName SVGPathSegLinetoVerticalRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegList
interface SVGPathSegList {

  /** @domName SVGPathSegList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGPathSegList.appendItem */
  SVGPathSeg appendItem(SVGPathSeg newItem);

  /** @domName SVGPathSegList.clear */
  void clear();

  /** @domName SVGPathSegList.getItem */
  SVGPathSeg getItem(int index);

  /** @domName SVGPathSegList.initialize */
  SVGPathSeg initialize(SVGPathSeg newItem);

  /** @domName SVGPathSegList.insertItemBefore */
  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index);

  /** @domName SVGPathSegList.removeItem */
  SVGPathSeg removeItem(int index);

  /** @domName SVGPathSegList.replaceItem */
  SVGPathSeg replaceItem(SVGPathSeg newItem, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegMovetoAbs
interface SVGPathSegMovetoAbs extends SVGPathSeg {

  /** @domName SVGPathSegMovetoAbs.x */
  num x;

  /** @domName SVGPathSegMovetoAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegMovetoRel
interface SVGPathSegMovetoRel extends SVGPathSeg {

  /** @domName SVGPathSegMovetoRel.x */
  num x;

  /** @domName SVGPathSegMovetoRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPatternElement
interface SVGPatternElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  /** @domName SVGPatternElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGPatternElement.patternContentUnits */
  final SVGAnimatedEnumeration patternContentUnits;

  /** @domName SVGPatternElement.patternTransform */
  final SVGAnimatedTransformList patternTransform;

  /** @domName SVGPatternElement.patternUnits */
  final SVGAnimatedEnumeration patternUnits;

  /** @domName SVGPatternElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGPatternElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGPatternElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPoint
interface SVGPoint {

  /** @domName SVGPoint.x */
  num x;

  /** @domName SVGPoint.y */
  num y;

  /** @domName SVGPoint.matrixTransform */
  SVGPoint matrixTransform(SVGMatrix matrix);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPointList
interface SVGPointList {

  /** @domName SVGPointList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGPointList.appendItem */
  SVGPoint appendItem(SVGPoint item);

  /** @domName SVGPointList.clear */
  void clear();

  /** @domName SVGPointList.getItem */
  SVGPoint getItem(int index);

  /** @domName SVGPointList.initialize */
  SVGPoint initialize(SVGPoint item);

  /** @domName SVGPointList.insertItemBefore */
  SVGPoint insertItemBefore(SVGPoint item, int index);

  /** @domName SVGPointList.removeItem */
  SVGPoint removeItem(int index);

  /** @domName SVGPointList.replaceItem */
  SVGPoint replaceItem(SVGPoint item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPolygonElement
interface SVGPolygonElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPolygonElement.animatedPoints */
  final SVGPointList animatedPoints;

  /** @domName SVGPolygonElement.points */
  final SVGPointList points;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPolylineElement
interface SVGPolylineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPolylineElement.animatedPoints */
  final SVGPointList animatedPoints;

  /** @domName SVGPolylineElement.points */
  final SVGPointList points;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPreserveAspectRatio
interface SVGPreserveAspectRatio {

  static final int SVG_MEETORSLICE_MEET = 1;

  static final int SVG_MEETORSLICE_SLICE = 2;

  static final int SVG_MEETORSLICE_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_NONE = 1;

  static final int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;

  /** @domName SVGPreserveAspectRatio.align */
  int align;

  /** @domName SVGPreserveAspectRatio.meetOrSlice */
  int meetOrSlice;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRadialGradientElement
interface SVGRadialGradientElement extends SVGGradientElement {

  /** @domName SVGRadialGradientElement.cx */
  final SVGAnimatedLength cx;

  /** @domName SVGRadialGradientElement.cy */
  final SVGAnimatedLength cy;

  /** @domName SVGRadialGradientElement.fx */
  final SVGAnimatedLength fx;

  /** @domName SVGRadialGradientElement.fy */
  final SVGAnimatedLength fy;

  /** @domName SVGRadialGradientElement.r */
  final SVGAnimatedLength r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRect
interface SVGRect {

  /** @domName SVGRect.height */
  num height;

  /** @domName SVGRect.width */
  num width;

  /** @domName SVGRect.x */
  num x;

  /** @domName SVGRect.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRectElement
interface SVGRectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGRectElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGRectElement.rx */
  final SVGAnimatedLength rx;

  /** @domName SVGRectElement.ry */
  final SVGAnimatedLength ry;

  /** @domName SVGRectElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGRectElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGRectElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRenderingIntent
interface SVGRenderingIntent {

  static final int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;

  static final int RENDERING_INTENT_AUTO = 1;

  static final int RENDERING_INTENT_PERCEPTUAL = 2;

  static final int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;

  static final int RENDERING_INTENT_SATURATION = 4;

  static final int RENDERING_INTENT_UNKNOWN = 0;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName SVGSVGElement
interface SVGSVGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGLocatable, SVGFitToViewBox, SVGZoomAndPan
    default _SVGSVGElementFactoryProvider {
  SVGSVGElement();


  /** @domName SVGSVGElement.contentScriptType */
  String contentScriptType;

  /** @domName SVGSVGElement.contentStyleType */
  String contentStyleType;

  /** @domName SVGSVGElement.currentScale */
  num currentScale;

  /** @domName SVGSVGElement.currentTranslate */
  final SVGPoint currentTranslate;

  /** @domName SVGSVGElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGSVGElement.pixelUnitToMillimeterX */
  final num pixelUnitToMillimeterX;

  /** @domName SVGSVGElement.pixelUnitToMillimeterY */
  final num pixelUnitToMillimeterY;

  /** @domName SVGSVGElement.screenPixelToMillimeterX */
  final num screenPixelToMillimeterX;

  /** @domName SVGSVGElement.screenPixelToMillimeterY */
  final num screenPixelToMillimeterY;

  /** @domName SVGSVGElement.useCurrentView */
  bool useCurrentView;

  /** @domName SVGSVGElement.viewport */
  final SVGRect viewport;

  /** @domName SVGSVGElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGSVGElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGSVGElement.y */
  final SVGAnimatedLength y;

  /** @domName SVGSVGElement.animationsPaused */
  bool animationsPaused();

  /** @domName SVGSVGElement.checkEnclosure */
  bool checkEnclosure(SVGElement element, SVGRect rect);

  /** @domName SVGSVGElement.checkIntersection */
  bool checkIntersection(SVGElement element, SVGRect rect);

  /** @domName SVGSVGElement.createSVGAngle */
  SVGAngle createSVGAngle();

  /** @domName SVGSVGElement.createSVGLength */
  SVGLength createSVGLength();

  /** @domName SVGSVGElement.createSVGMatrix */
  SVGMatrix createSVGMatrix();

  /** @domName SVGSVGElement.createSVGNumber */
  SVGNumber createSVGNumber();

  /** @domName SVGSVGElement.createSVGPoint */
  SVGPoint createSVGPoint();

  /** @domName SVGSVGElement.createSVGRect */
  SVGRect createSVGRect();

  /** @domName SVGSVGElement.createSVGTransform */
  SVGTransform createSVGTransform();

  /** @domName SVGSVGElement.createSVGTransformFromMatrix */
  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  /** @domName SVGSVGElement.deselectAll */
  void deselectAll();

  /** @domName SVGSVGElement.forceRedraw */
  void forceRedraw();

  /** @domName SVGSVGElement.getCurrentTime */
  num getCurrentTime();

  /** @domName SVGSVGElement.getElementById */
  Element getElementById(String elementId);

  /** @domName SVGSVGElement.getEnclosureList */
  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement);

  /** @domName SVGSVGElement.getIntersectionList */
  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement);

  /** @domName SVGSVGElement.pauseAnimations */
  void pauseAnimations();

  /** @domName SVGSVGElement.setCurrentTime */
  void setCurrentTime(num seconds);

  /** @domName SVGSVGElement.suspendRedraw */
  int suspendRedraw(int maxWaitMilliseconds);

  /** @domName SVGSVGElement.unpauseAnimations */
  void unpauseAnimations();

  /** @domName SVGSVGElement.unsuspendRedraw */
  void unsuspendRedraw(int suspendHandleId);

  /** @domName SVGSVGElement.unsuspendRedrawAll */
  void unsuspendRedrawAll();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGScriptElement
interface SVGScriptElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {

  /** @domName SVGScriptElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSetElement
interface SVGSetElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStopElement
interface SVGStopElement extends SVGElement, SVGStylable {

  /** @domName SVGStopElement.offset */
  final SVGAnimatedNumber offset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStringList
interface SVGStringList {

  /** @domName SVGStringList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGStringList.appendItem */
  String appendItem(String item);

  /** @domName SVGStringList.clear */
  void clear();

  /** @domName SVGStringList.getItem */
  String getItem(int index);

  /** @domName SVGStringList.initialize */
  String initialize(String item);

  /** @domName SVGStringList.insertItemBefore */
  String insertItemBefore(String item, int index);

  /** @domName SVGStringList.removeItem */
  String removeItem(int index);

  /** @domName SVGStringList.replaceItem */
  String replaceItem(String item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStylable
interface SVGStylable {

  /** @domName SVGStylable.className */
  final SVGAnimatedString $dom_svgClassName;

  /** @domName SVGStylable.style */
  final CSSStyleDeclaration style;

  /** @domName SVGStylable.getPresentationAttribute */
  CSSValue getPresentationAttribute(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStyleElement
interface SVGStyleElement extends SVGElement, SVGLangSpace {

  /** @domName SVGStyleElement.disabled */
  bool disabled;

  /** @domName SVGStyleElement.media */
  String media;

  /** @domName SVGStyleElement.title */
  String title;

  /** @domName SVGStyleElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSwitchElement
interface SVGSwitchElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSymbolElement
interface SVGSymbolElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTRefElement
interface SVGTRefElement extends SVGTextPositioningElement, SVGURIReference {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTSpanElement
interface SVGTSpanElement extends SVGTextPositioningElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTests
interface SVGTests {

  /** @domName SVGTests.requiredExtensions */
  final SVGStringList requiredExtensions;

  /** @domName SVGTests.requiredFeatures */
  final SVGStringList requiredFeatures;

  /** @domName SVGTests.systemLanguage */
  final SVGStringList systemLanguage;

  /** @domName SVGTests.hasExtension */
  bool hasExtension(String extension);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextContentElement
interface SVGTextContentElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  static final int LENGTHADJUST_SPACING = 1;

  static final int LENGTHADJUST_SPACINGANDGLYPHS = 2;

  static final int LENGTHADJUST_UNKNOWN = 0;

  /** @domName SVGTextContentElement.lengthAdjust */
  final SVGAnimatedEnumeration lengthAdjust;

  /** @domName SVGTextContentElement.textLength */
  final SVGAnimatedLength textLength;

  /** @domName SVGTextContentElement.getCharNumAtPosition */
  int getCharNumAtPosition(SVGPoint point);

  /** @domName SVGTextContentElement.getComputedTextLength */
  num getComputedTextLength();

  /** @domName SVGTextContentElement.getEndPositionOfChar */
  SVGPoint getEndPositionOfChar(int offset);

  /** @domName SVGTextContentElement.getExtentOfChar */
  SVGRect getExtentOfChar(int offset);

  /** @domName SVGTextContentElement.getNumberOfChars */
  int getNumberOfChars();

  /** @domName SVGTextContentElement.getRotationOfChar */
  num getRotationOfChar(int offset);

  /** @domName SVGTextContentElement.getStartPositionOfChar */
  SVGPoint getStartPositionOfChar(int offset);

  /** @domName SVGTextContentElement.getSubStringLength */
  num getSubStringLength(int offset, int length);

  /** @domName SVGTextContentElement.selectSubString */
  void selectSubString(int offset, int length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextElement
interface SVGTextElement extends SVGTextPositioningElement, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextPathElement
interface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {

  static final int TEXTPATH_METHODTYPE_ALIGN = 1;

  static final int TEXTPATH_METHODTYPE_STRETCH = 2;

  static final int TEXTPATH_METHODTYPE_UNKNOWN = 0;

  static final int TEXTPATH_SPACINGTYPE_AUTO = 1;

  static final int TEXTPATH_SPACINGTYPE_EXACT = 2;

  static final int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;

  /** @domName SVGTextPathElement.method */
  final SVGAnimatedEnumeration method;

  /** @domName SVGTextPathElement.spacing */
  final SVGAnimatedEnumeration spacing;

  /** @domName SVGTextPathElement.startOffset */
  final SVGAnimatedLength startOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextPositioningElement
interface SVGTextPositioningElement extends SVGTextContentElement {

  /** @domName SVGTextPositioningElement.dx */
  final SVGAnimatedLengthList dx;

  /** @domName SVGTextPositioningElement.dy */
  final SVGAnimatedLengthList dy;

  /** @domName SVGTextPositioningElement.rotate */
  final SVGAnimatedNumberList rotate;

  /** @domName SVGTextPositioningElement.x */
  final SVGAnimatedLengthList x;

  /** @domName SVGTextPositioningElement.y */
  final SVGAnimatedLengthList y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTitleElement
interface SVGTitleElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransform
interface SVGTransform {

  static final int SVG_TRANSFORM_MATRIX = 1;

  static final int SVG_TRANSFORM_ROTATE = 4;

  static final int SVG_TRANSFORM_SCALE = 3;

  static final int SVG_TRANSFORM_SKEWX = 5;

  static final int SVG_TRANSFORM_SKEWY = 6;

  static final int SVG_TRANSFORM_TRANSLATE = 2;

  static final int SVG_TRANSFORM_UNKNOWN = 0;

  /** @domName SVGTransform.angle */
  final num angle;

  /** @domName SVGTransform.matrix */
  final SVGMatrix matrix;

  /** @domName SVGTransform.type */
  final int type;

  /** @domName SVGTransform.setMatrix */
  void setMatrix(SVGMatrix matrix);

  /** @domName SVGTransform.setRotate */
  void setRotate(num angle, num cx, num cy);

  /** @domName SVGTransform.setScale */
  void setScale(num sx, num sy);

  /** @domName SVGTransform.setSkewX */
  void setSkewX(num angle);

  /** @domName SVGTransform.setSkewY */
  void setSkewY(num angle);

  /** @domName SVGTransform.setTranslate */
  void setTranslate(num tx, num ty);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransformList
interface SVGTransformList {

  /** @domName SVGTransformList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGTransformList.appendItem */
  SVGTransform appendItem(SVGTransform item);

  /** @domName SVGTransformList.clear */
  void clear();

  /** @domName SVGTransformList.consolidate */
  SVGTransform consolidate();

  /** @domName SVGTransformList.createSVGTransformFromMatrix */
  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  /** @domName SVGTransformList.getItem */
  SVGTransform getItem(int index);

  /** @domName SVGTransformList.initialize */
  SVGTransform initialize(SVGTransform item);

  /** @domName SVGTransformList.insertItemBefore */
  SVGTransform insertItemBefore(SVGTransform item, int index);

  /** @domName SVGTransformList.removeItem */
  SVGTransform removeItem(int index);

  /** @domName SVGTransformList.replaceItem */
  SVGTransform replaceItem(SVGTransform item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransformable
interface SVGTransformable extends SVGLocatable {

  /** @domName SVGTransformable.transform */
  final SVGAnimatedTransformList transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGURIReference
interface SVGURIReference {

  /** @domName SVGURIReference.href */
  final SVGAnimatedString href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGUnitTypes
interface SVGUnitTypes {

  static final int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;

  static final int SVG_UNIT_TYPE_UNKNOWN = 0;

  static final int SVG_UNIT_TYPE_USERSPACEONUSE = 1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGUseElement
interface SVGUseElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGUseElement.animatedInstanceRoot */
  final SVGElementInstance animatedInstanceRoot;

  /** @domName SVGUseElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGUseElement.instanceRoot */
  final SVGElementInstance instanceRoot;

  /** @domName SVGUseElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGUseElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGUseElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGVKernElement
interface SVGVKernElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGViewElement
interface SVGViewElement extends SVGElement, SVGExternalResourcesRequired, SVGFitToViewBox, SVGZoomAndPan {

  /** @domName SVGViewElement.viewTarget */
  final SVGStringList viewTarget;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGViewSpec
interface SVGViewSpec extends SVGZoomAndPan, SVGFitToViewBox {

  /** @domName SVGViewSpec.preserveAspectRatioString */
  final String preserveAspectRatioString;

  /** @domName SVGViewSpec.transform */
  final SVGTransformList transform;

  /** @domName SVGViewSpec.transformString */
  final String transformString;

  /** @domName SVGViewSpec.viewBoxString */
  final String viewBoxString;

  /** @domName SVGViewSpec.viewTarget */
  final SVGElement viewTarget;

  /** @domName SVGViewSpec.viewTargetString */
  final String viewTargetString;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGZoomAndPan
interface SVGZoomAndPan {

  static final int SVG_ZOOMANDPAN_DISABLE = 1;

  static final int SVG_ZOOMANDPAN_MAGNIFY = 2;

  static final int SVG_ZOOMANDPAN_UNKNOWN = 0;

  /** @domName SVGZoomAndPan.zoomAndPan */
  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGZoomEvent
interface SVGZoomEvent extends UIEvent {

  /** @domName SVGZoomEvent.newScale */
  final num newScale;

  /** @domName SVGZoomEvent.newTranslate */
  final SVGPoint newTranslate;

  /** @domName SVGZoomEvent.previousScale */
  final num previousScale;

  /** @domName SVGZoomEvent.previousTranslate */
  final SVGPoint previousTranslate;

  /** @domName SVGZoomEvent.zoomRectScreen */
  final SVGRect zoomRectScreen;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Screen
interface Screen {

  /** @domName Screen.availHeight */
  final int availHeight;

  /** @domName Screen.availLeft */
  final int availLeft;

  /** @domName Screen.availTop */
  final int availTop;

  /** @domName Screen.availWidth */
  final int availWidth;

  /** @domName Screen.colorDepth */
  final int colorDepth;

  /** @domName Screen.height */
  final int height;

  /** @domName Screen.pixelDepth */
  final int pixelDepth;

  /** @domName Screen.width */
  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLScriptElement
interface ScriptElement extends Element default _Elements {

  ScriptElement();

  /** @domName HTMLScriptElement.async */
  bool async;

  /** @domName HTMLScriptElement.charset */
  String charset;

  /** @domName HTMLScriptElement.crossOrigin */
  String crossOrigin;

  /** @domName HTMLScriptElement.defer */
  bool defer;

  /** @domName HTMLScriptElement.event */
  String event;

  /** @domName HTMLScriptElement.htmlFor */
  String htmlFor;

  /** @domName HTMLScriptElement.src */
  String src;

  /** @domName HTMLScriptElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProfile
interface ScriptProfile {

  /** @domName ScriptProfile.head */
  final ScriptProfileNode head;

  /** @domName ScriptProfile.title */
  final String title;

  /** @domName ScriptProfile.uid */
  final int uid;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProfileNode
interface ScriptProfileNode {

  /** @domName ScriptProfileNode.callUID */
  final int callUID;

  /** @domName ScriptProfileNode.children */
  final List<ScriptProfileNode> children;

  /** @domName ScriptProfileNode.functionName */
  final String functionName;

  /** @domName ScriptProfileNode.lineNumber */
  final int lineNumber;

  /** @domName ScriptProfileNode.numberOfCalls */
  final int numberOfCalls;

  /** @domName ScriptProfileNode.selfTime */
  final num selfTime;

  /** @domName ScriptProfileNode.totalTime */
  final num totalTime;

  /** @domName ScriptProfileNode.url */
  final String url;

  /** @domName ScriptProfileNode.visible */
  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSelectElement
interface SelectElement extends Element {

  /** @domName HTMLSelectElement.autofocus */
  bool autofocus;

  /** @domName HTMLSelectElement.disabled */
  bool disabled;

  /** @domName HTMLSelectElement.form */
  final FormElement form;

  /** @domName HTMLSelectElement.labels */
  final NodeList labels;

  /** @domName HTMLSelectElement.length */
  int length;

  /** @domName HTMLSelectElement.multiple */
  bool multiple;

  /** @domName HTMLSelectElement.name */
  String name;

  /** @domName HTMLSelectElement.options */
  final HTMLOptionsCollection options;

  /** @domName HTMLSelectElement.required */
  bool required;

  /** @domName HTMLSelectElement.selectedIndex */
  int selectedIndex;

  /** @domName HTMLSelectElement.selectedOptions */
  final HTMLCollection selectedOptions;

  /** @domName HTMLSelectElement.size */
  int size;

  /** @domName HTMLSelectElement.type */
  final String type;

  /** @domName HTMLSelectElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLSelectElement.validity */
  final ValidityState validity;

  /** @domName HTMLSelectElement.value */
  String value;

  /** @domName HTMLSelectElement.willValidate */
  final bool willValidate;

  /** @domName HTMLSelectElement.add */
  void add(Element element, Element before);

  /** @domName HTMLSelectElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLSelectElement.item */
  Node item(int index);

  /** @domName HTMLSelectElement.namedItem */
  Node namedItem(String name);

  /** @domName HTMLSelectElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SessionDescription
interface SessionDescription default _SessionDescriptionFactoryProvider {

  SessionDescription(String sdp);

  /** @domName SessionDescription.addCandidate */
  void addCandidate(IceCandidate candidate);

  /** @domName SessionDescription.toSdp */
  String toSdp();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLShadowElement
interface ShadowElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ShadowRoot
interface ShadowRoot extends DocumentFragment default _ShadowRootFactoryProvider {

  ShadowRoot(Element host);

  /** @domName ShadowRoot.activeElement */
  final Element activeElement;

  /** @domName ShadowRoot.applyAuthorStyles */
  bool applyAuthorStyles;

  /** @domName ShadowRoot.host */
  final Element host;

  /** @domName ShadowRoot.innerHTML */
  String innerHTML;

  /** @domName ShadowRoot.selection */
  final DOMSelection selection;

  /** @domName ShadowRoot.getElementById */
  Element getElementById(String elementId);

  /** @domName ShadowRoot.getElementsByClassName */
  NodeList getElementsByClassName(String className);

  /** @domName ShadowRoot.getElementsByTagName */
  NodeList getElementsByTagName(String tagName);

  /** @domName ShadowRoot.getElementsByTagNameNS */
  NodeList getElementsByTagNameNS(String namespaceURI, String localName);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SharedWorker
interface SharedWorker extends AbstractWorker default _SharedWorkerFactoryProvider {

  SharedWorker(String scriptURL, [String name]);

  /** @domName SharedWorker.port */
  final MessagePort port;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SharedWorkerContext
interface SharedWorkerContext extends WorkerContext {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SharedWorkerContextEvents get on();

  /** @domName SharedWorkerContext.name */
  final String name;
}

interface SharedWorkerContextEvents extends WorkerContextEvents {

  EventListenerList get connect();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SignalingCallback(String message, DeprecatedPeerConnection source);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSourceElement
interface SourceElement extends Element default _Elements {

  SourceElement();

  /** @domName HTMLSourceElement.media */
  String media;

  /** @domName HTMLSourceElement.src */
  String src;

  /** @domName HTMLSourceElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSpanElement
interface SpanElement extends Element default _Elements {

  SpanElement();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechGrammar
interface SpeechGrammar default _SpeechGrammarFactoryProvider {

  SpeechGrammar();

  /** @domName SpeechGrammar.src */
  String src;

  /** @domName SpeechGrammar.weight */
  num weight;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechGrammarList
interface SpeechGrammarList default _SpeechGrammarListFactoryProvider {

  SpeechGrammarList();

  /** @domName SpeechGrammarList.length */
  final int length;

  /** @domName SpeechGrammarList.addFromString */
  void addFromString(String string, [num weight]);

  /** @domName SpeechGrammarList.addFromUri */
  void addFromUri(String src, [num weight]);

  /** @domName SpeechGrammarList.item */
  SpeechGrammar item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputEvent
interface SpeechInputEvent extends Event {

  /** @domName SpeechInputEvent.results */
  final SpeechInputResultList results;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputResult
interface SpeechInputResult {

  /** @domName SpeechInputResult.confidence */
  final num confidence;

  /** @domName SpeechInputResult.utterance */
  final String utterance;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputResultList
interface SpeechInputResultList {

  /** @domName SpeechInputResultList.length */
  final int length;

  /** @domName SpeechInputResultList.item */
  SpeechInputResult item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognition
interface SpeechRecognition extends EventTarget default _SpeechRecognitionFactoryProvider {

  SpeechRecognition();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SpeechRecognitionEvents get on();

  /** @domName SpeechRecognition.continuous */
  bool continuous;

  /** @domName SpeechRecognition.grammars */
  SpeechGrammarList grammars;

  /** @domName SpeechRecognition.lang */
  String lang;

  /** @domName SpeechRecognition.abort */
  void abort();

  /** @domName SpeechRecognition.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SpeechRecognition.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName SpeechRecognition.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SpeechRecognition.start */
  void start();

  /** @domName SpeechRecognition.stop */
  void stop();
}

interface SpeechRecognitionEvents extends Events {

  EventListenerList get audioEnd();

  EventListenerList get audioStart();

  EventListenerList get end();

  EventListenerList get error();

  EventListenerList get noMatch();

  EventListenerList get result();

  EventListenerList get resultDeleted();

  EventListenerList get soundEnd();

  EventListenerList get soundStart();

  EventListenerList get speechEnd();

  EventListenerList get speechStart();

  EventListenerList get start();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionAlternative
interface SpeechRecognitionAlternative {

  /** @domName SpeechRecognitionAlternative.confidence */
  final num confidence;

  /** @domName SpeechRecognitionAlternative.transcript */
  final String transcript;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionError
interface SpeechRecognitionError {

  static final int ABORTED = 2;

  static final int AUDIO_CAPTURE = 3;

  static final int BAD_GRAMMAR = 7;

  static final int LANGUAGE_NOT_SUPPORTED = 8;

  static final int NETWORK = 4;

  static final int NOT_ALLOWED = 5;

  static final int NO_SPEECH = 1;

  static final int OTHER = 0;

  static final int SERVICE_NOT_ALLOWED = 6;

  /** @domName SpeechRecognitionError.code */
  final int code;

  /** @domName SpeechRecognitionError.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionEvent
interface SpeechRecognitionEvent extends Event {

  /** @domName SpeechRecognitionEvent.error */
  final SpeechRecognitionError error;

  /** @domName SpeechRecognitionEvent.result */
  final SpeechRecognitionResult result;

  /** @domName SpeechRecognitionEvent.resultHistory */
  final SpeechRecognitionResultList resultHistory;

  /** @domName SpeechRecognitionEvent.resultIndex */
  final int resultIndex;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionResult
interface SpeechRecognitionResult {

  /** @domName SpeechRecognitionResult.finalValue */
  final bool finalValue;

  /** @domName SpeechRecognitionResult.length */
  final int length;

  /** @domName SpeechRecognitionResult.item */
  SpeechRecognitionAlternative item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionResultList
interface SpeechRecognitionResultList {

  /** @domName SpeechRecognitionResultList.length */
  final int length;

  /** @domName SpeechRecognitionResultList.item */
  SpeechRecognitionResult item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName Storage
interface Storage extends Map<String, String> {

  /** @domName Storage.length */
  final int $dom_length;

  /** @domName Storage.clear */
  void $dom_clear();

  /** @domName Storage.getItem */
  String $dom_getItem(String key);

  /** @domName Storage.key */
  String $dom_key(int index);

  /** @domName Storage.removeItem */
  void $dom_removeItem(String key);

  /** @domName Storage.setItem */
  void $dom_setItem(String key, String data);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StorageEvent
interface StorageEvent extends Event {

  /** @domName StorageEvent.key */
  final String key;

  /** @domName StorageEvent.newValue */
  final String newValue;

  /** @domName StorageEvent.oldValue */
  final String oldValue;

  /** @domName StorageEvent.storageArea */
  final Storage storageArea;

  /** @domName StorageEvent.url */
  final String url;

  /** @domName StorageEvent.initStorageEvent */
  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StorageInfo
interface StorageInfo {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  /** @domName StorageInfo.queryUsageAndQuota */
  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]);

  /** @domName StorageInfo.requestQuota */
  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoErrorCallback(DOMException error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StringCallback(String data);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLStyleElement
interface StyleElement extends Element default _Elements {

  StyleElement();

  /** @domName HTMLStyleElement.disabled */
  bool disabled;

  /** @domName HTMLStyleElement.media */
  String media;

  /** @domName HTMLStyleElement.scoped */
  bool scoped;

  /** @domName HTMLStyleElement.sheet */
  final StyleSheet sheet;

  /** @domName HTMLStyleElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleMedia
interface StyleMedia {

  /** @domName StyleMedia.type */
  final String type;

  /** @domName StyleMedia.matchMedium */
  bool matchMedium(String mediaquery);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleSheet
interface StyleSheet {

  /** @domName StyleSheet.disabled */
  bool disabled;

  /** @domName StyleSheet.href */
  final String href;

  /** @domName StyleSheet.media */
  final MediaList media;

  /** @domName StyleSheet.ownerNode */
  final Node ownerNode;

  /** @domName StyleSheet.parentStyleSheet */
  final StyleSheet parentStyleSheet;

  /** @domName StyleSheet.title */
  final String title;

  /** @domName StyleSheet.type */
  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleSheetList
interface StyleSheetList extends List<StyleSheet> {

  /** @domName StyleSheetList.length */
  final int length;

  /** @domName StyleSheetList.item */
  StyleSheet item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableCaptionElement
interface TableCaptionElement extends Element default _Elements {

  TableCaptionElement();

  /** @domName HTMLTableCaptionElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableCellElement
interface TableCellElement extends Element default _Elements {

  TableCellElement();

  /** @domName HTMLTableCellElement.abbr */
  String abbr;

  /** @domName HTMLTableCellElement.align */
  String align;

  /** @domName HTMLTableCellElement.axis */
  String axis;

  /** @domName HTMLTableCellElement.bgColor */
  String bgColor;

  /** @domName HTMLTableCellElement.cellIndex */
  final int cellIndex;

  /** @domName HTMLTableCellElement.ch */
  String ch;

  /** @domName HTMLTableCellElement.chOff */
  String chOff;

  /** @domName HTMLTableCellElement.colSpan */
  int colSpan;

  /** @domName HTMLTableCellElement.headers */
  String headers;

  /** @domName HTMLTableCellElement.height */
  String height;

  /** @domName HTMLTableCellElement.noWrap */
  bool noWrap;

  /** @domName HTMLTableCellElement.rowSpan */
  int rowSpan;

  /** @domName HTMLTableCellElement.scope */
  String scope;

  /** @domName HTMLTableCellElement.vAlign */
  String vAlign;

  /** @domName HTMLTableCellElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableColElement
interface TableColElement extends Element default _Elements {

  TableColElement();

  /** @domName HTMLTableColElement.align */
  String align;

  /** @domName HTMLTableColElement.ch */
  String ch;

  /** @domName HTMLTableColElement.chOff */
  String chOff;

  /** @domName HTMLTableColElement.span */
  int span;

  /** @domName HTMLTableColElement.vAlign */
  String vAlign;

  /** @domName HTMLTableColElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableElement
interface TableElement extends Element default _Elements {

  TableElement();

  /** @domName HTMLTableElement.align */
  String align;

  /** @domName HTMLTableElement.bgColor */
  String bgColor;

  /** @domName HTMLTableElement.border */
  String border;

  /** @domName HTMLTableElement.caption */
  TableCaptionElement caption;

  /** @domName HTMLTableElement.cellPadding */
  String cellPadding;

  /** @domName HTMLTableElement.cellSpacing */
  String cellSpacing;

  /** @domName HTMLTableElement.frame */
  String frame;

  /** @domName HTMLTableElement.rows */
  final HTMLCollection rows;

  /** @domName HTMLTableElement.rules */
  String rules;

  /** @domName HTMLTableElement.summary */
  String summary;

  /** @domName HTMLTableElement.tBodies */
  final HTMLCollection tBodies;

  /** @domName HTMLTableElement.tFoot */
  TableSectionElement tFoot;

  /** @domName HTMLTableElement.tHead */
  TableSectionElement tHead;

  /** @domName HTMLTableElement.width */
  String width;

  /** @domName HTMLTableElement.createCaption */
  Element createCaption();

  /** @domName HTMLTableElement.createTBody */
  Element createTBody();

  /** @domName HTMLTableElement.createTFoot */
  Element createTFoot();

  /** @domName HTMLTableElement.createTHead */
  Element createTHead();

  /** @domName HTMLTableElement.deleteCaption */
  void deleteCaption();

  /** @domName HTMLTableElement.deleteRow */
  void deleteRow(int index);

  /** @domName HTMLTableElement.deleteTFoot */
  void deleteTFoot();

  /** @domName HTMLTableElement.deleteTHead */
  void deleteTHead();

  /** @domName HTMLTableElement.insertRow */
  Element insertRow(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableRowElement
interface TableRowElement extends Element default _Elements {

  TableRowElement();

  /** @domName HTMLTableRowElement.align */
  String align;

  /** @domName HTMLTableRowElement.bgColor */
  String bgColor;

  /** @domName HTMLTableRowElement.cells */
  final HTMLCollection cells;

  /** @domName HTMLTableRowElement.ch */
  String ch;

  /** @domName HTMLTableRowElement.chOff */
  String chOff;

  /** @domName HTMLTableRowElement.rowIndex */
  final int rowIndex;

  /** @domName HTMLTableRowElement.sectionRowIndex */
  final int sectionRowIndex;

  /** @domName HTMLTableRowElement.vAlign */
  String vAlign;

  /** @domName HTMLTableRowElement.deleteCell */
  void deleteCell(int index);

  /** @domName HTMLTableRowElement.insertCell */
  Element insertCell(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableSectionElement
interface TableSectionElement extends Element {

  /** @domName HTMLTableSectionElement.align */
  String align;

  /** @domName HTMLTableSectionElement.ch */
  String ch;

  /** @domName HTMLTableSectionElement.chOff */
  String chOff;

  /** @domName HTMLTableSectionElement.rows */
  final HTMLCollection rows;

  /** @domName HTMLTableSectionElement.vAlign */
  String vAlign;

  /** @domName HTMLTableSectionElement.deleteRow */
  void deleteRow(int index);

  /** @domName HTMLTableSectionElement.insertRow */
  Element insertRow(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Text
interface Text extends CharacterData default _TextFactoryProvider {

  Text(String data);

  /** @domName Text.wholeText */
  final String wholeText;

  /** @domName Text.replaceWholeText */
  Text replaceWholeText(String content);

  /** @domName Text.splitText */
  Text splitText(int offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTextAreaElement
interface TextAreaElement extends Element default _Elements {

  TextAreaElement();

  /** @domName HTMLTextAreaElement.autofocus */
  bool autofocus;

  /** @domName HTMLTextAreaElement.cols */
  int cols;

  /** @domName HTMLTextAreaElement.defaultValue */
  String defaultValue;

  /** @domName HTMLTextAreaElement.disabled */
  bool disabled;

  /** @domName HTMLTextAreaElement.form */
  final FormElement form;

  /** @domName HTMLTextAreaElement.labels */
  final NodeList labels;

  /** @domName HTMLTextAreaElement.maxLength */
  int maxLength;

  /** @domName HTMLTextAreaElement.name */
  String name;

  /** @domName HTMLTextAreaElement.placeholder */
  String placeholder;

  /** @domName HTMLTextAreaElement.readOnly */
  bool readOnly;

  /** @domName HTMLTextAreaElement.required */
  bool required;

  /** @domName HTMLTextAreaElement.rows */
  int rows;

  /** @domName HTMLTextAreaElement.selectionDirection */
  String selectionDirection;

  /** @domName HTMLTextAreaElement.selectionEnd */
  int selectionEnd;

  /** @domName HTMLTextAreaElement.selectionStart */
  int selectionStart;

  /** @domName HTMLTextAreaElement.textLength */
  final int textLength;

  /** @domName HTMLTextAreaElement.type */
  final String type;

  /** @domName HTMLTextAreaElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLTextAreaElement.validity */
  final ValidityState validity;

  /** @domName HTMLTextAreaElement.value */
  String value;

  /** @domName HTMLTextAreaElement.willValidate */
  final bool willValidate;

  /** @domName HTMLTextAreaElement.wrap */
  String wrap;

  /** @domName HTMLTextAreaElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLTextAreaElement.select */
  void select();

  /** @domName HTMLTextAreaElement.setCustomValidity */
  void setCustomValidity(String error);

  /** @domName HTMLTextAreaElement.setSelectionRange */
  void setSelectionRange(int start, int end, [String direction]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextEvent
interface TextEvent extends UIEvent {

  /** @domName TextEvent.data */
  final String data;

  /** @domName TextEvent.initTextEvent */
  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextMetrics
interface TextMetrics {

  /** @domName TextMetrics.width */
  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrack
interface TextTrack extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackEvents get on();

  static final int DISABLED = 0;

  static final int HIDDEN = 1;

  static final int SHOWING = 2;

  /** @domName TextTrack.activeCues */
  final TextTrackCueList activeCues;

  /** @domName TextTrack.cues */
  final TextTrackCueList cues;

  /** @domName TextTrack.kind */
  final String kind;

  /** @domName TextTrack.label */
  final String label;

  /** @domName TextTrack.language */
  final String language;

  /** @domName TextTrack.mode */
  int mode;

  /** @domName TextTrack.addCue */
  void addCue(TextTrackCue cue);

  /** @domName TextTrack.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrack.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrack.removeCue */
  void removeCue(TextTrackCue cue);

  /** @domName TextTrack.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface TextTrackEvents extends Events {

  EventListenerList get cueChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackCue
interface TextTrackCue extends EventTarget default _TextTrackCueFactoryProvider {

  TextTrackCue(String id, num startTime, num endTime, String text, [String settings, bool pauseOnExit]);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackCueEvents get on();

  /** @domName TextTrackCue.align */
  String align;

  /** @domName TextTrackCue.endTime */
  num endTime;

  /** @domName TextTrackCue.id */
  String id;

  /** @domName TextTrackCue.line */
  int line;

  /** @domName TextTrackCue.pauseOnExit */
  bool pauseOnExit;

  /** @domName TextTrackCue.position */
  int position;

  /** @domName TextTrackCue.size */
  int size;

  /** @domName TextTrackCue.snapToLines */
  bool snapToLines;

  /** @domName TextTrackCue.startTime */
  num startTime;

  /** @domName TextTrackCue.text */
  String text;

  /** @domName TextTrackCue.track */
  final TextTrack track;

  /** @domName TextTrackCue.vertical */
  String vertical;

  /** @domName TextTrackCue.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrackCue.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrackCue.getCueAsHTML */
  DocumentFragment getCueAsHTML();

  /** @domName TextTrackCue.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface TextTrackCueEvents extends Events {

  EventListenerList get enter();

  EventListenerList get exit();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackCueList
interface TextTrackCueList {

  /** @domName TextTrackCueList.length */
  final int length;

  /** @domName TextTrackCueList.getCueById */
  TextTrackCue getCueById(String id);

  /** @domName TextTrackCueList.item */
  TextTrackCue item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackList
interface TextTrackList extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackListEvents get on();

  /** @domName TextTrackList.length */
  final int length;

  /** @domName TextTrackList.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrackList.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrackList.item */
  TextTrack item(int index);

  /** @domName TextTrackList.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface TextTrackListEvents extends Events {

  EventListenerList get addTrack();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TimeRanges
interface TimeRanges {

  /** @domName TimeRanges.length */
  final int length;

  /** @domName TimeRanges.end */
  num end(int index);

  /** @domName TimeRanges.start */
  num start(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef void TimeoutHandler();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTitleElement
interface TitleElement extends Element default _Elements {

  TitleElement();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Touch
interface Touch {

  /** @domName Touch.clientX */
  final int clientX;

  /** @domName Touch.clientY */
  final int clientY;

  /** @domName Touch.identifier */
  final int identifier;

  /** @domName Touch.pageX */
  final int pageX;

  /** @domName Touch.pageY */
  final int pageY;

  /** @domName Touch.screenX */
  final int screenX;

  /** @domName Touch.screenY */
  final int screenY;

  /** @domName Touch.target */
  final EventTarget target;

  /** @domName Touch.webkitForce */
  final num webkitForce;

  /** @domName Touch.webkitRadiusX */
  final int webkitRadiusX;

  /** @domName Touch.webkitRadiusY */
  final int webkitRadiusY;

  /** @domName Touch.webkitRotationAngle */
  final num webkitRotationAngle;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TouchEvent
interface TouchEvent extends UIEvent {

  /** @domName TouchEvent.altKey */
  final bool altKey;

  /** @domName TouchEvent.changedTouches */
  final TouchList changedTouches;

  /** @domName TouchEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName TouchEvent.metaKey */
  final bool metaKey;

  /** @domName TouchEvent.shiftKey */
  final bool shiftKey;

  /** @domName TouchEvent.targetTouches */
  final TouchList targetTouches;

  /** @domName TouchEvent.touches */
  final TouchList touches;

  /** @domName TouchEvent.initTouchEvent */
  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TouchList
interface TouchList extends List<Touch> {

  /** @domName TouchList.length */
  final int length;

  /** @domName TouchList.item */
  Touch item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTrackElement
interface TrackElement extends Element default _Elements {

  TrackElement();

  static final int ERROR = 3;

  static final int LOADED = 2;

  static final int LOADING = 1;

  static final int NONE = 0;

  /** @domName HTMLTrackElement.defaultValue */
  bool defaultValue;

  /** @domName HTMLTrackElement.kind */
  String kind;

  /** @domName HTMLTrackElement.label */
  String label;

  /** @domName HTMLTrackElement.readyState */
  final int readyState;

  /** @domName HTMLTrackElement.src */
  String src;

  /** @domName HTMLTrackElement.srclang */
  String srclang;

  /** @domName HTMLTrackElement.track */
  final TextTrack track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TrackEvent
interface TrackEvent extends Event {

  /** @domName TrackEvent.track */
  final Object track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitTransitionEvent
interface TransitionEvent extends Event {

  /** @domName WebKitTransitionEvent.elapsedTime */
  final num elapsedTime;

  /** @domName WebKitTransitionEvent.propertyName */
  final String propertyName;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TreeWalker
interface TreeWalker {

  /** @domName TreeWalker.currentNode */
  Node currentNode;

  /** @domName TreeWalker.expandEntityReferences */
  final bool expandEntityReferences;

  /** @domName TreeWalker.filter */
  final NodeFilter filter;

  /** @domName TreeWalker.root */
  final Node root;

  /** @domName TreeWalker.whatToShow */
  final int whatToShow;

  /** @domName TreeWalker.firstChild */
  Node firstChild();

  /** @domName TreeWalker.lastChild */
  Node lastChild();

  /** @domName TreeWalker.nextNode */
  Node nextNode();

  /** @domName TreeWalker.nextSibling */
  Node nextSibling();

  /** @domName TreeWalker.parentNode */
  Node parentNode();

  /** @domName TreeWalker.previousNode */
  Node previousNode();

  /** @domName TreeWalker.previousSibling */
  Node previousSibling();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName UIEvent
interface UIEvent extends Event {

  /** @domName UIEvent.charCode */
  final int charCode;

  /** @domName UIEvent.detail */
  final int detail;

  /** @domName UIEvent.keyCode */
  final int keyCode;

  /** @domName UIEvent.layerX */
  final int layerX;

  /** @domName UIEvent.layerY */
  final int layerY;

  /** @domName UIEvent.pageX */
  final int pageX;

  /** @domName UIEvent.pageY */
  final int pageY;

  /** @domName UIEvent.view */
  final Window view;

  /** @domName UIEvent.which */
  final int which;

  /** @domName UIEvent.initUIEvent */
  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLUListElement
interface UListElement extends Element default _Elements {

  UListElement();

  /** @domName HTMLUListElement.compact */
  bool compact;

  /** @domName HTMLUListElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint16Array
interface Uint16Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint16Array(int length);

  Uint16Array.fromList(List<int> list);

  Uint16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 2;

  /** @domName Uint16Array.length */
  final int length;

  /** @domName Uint16Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint16Array.subarray */
  Uint16Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint32Array
interface Uint32Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint32Array(int length);

  Uint32Array.fromList(List<int> list);

  Uint32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 4;

  /** @domName Uint32Array.length */
  final int length;

  /** @domName Uint32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint32Array.subarray */
  Uint32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint8Array
interface Uint8Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint8Array(int length);

  Uint8Array.fromList(List<int> list);

  Uint8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 1;

  /** @domName Uint8Array.length */
  final int length;

  /** @domName Uint8Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint8Array.subarray */
  Uint8Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint8ClampedArray
interface Uint8ClampedArray extends Uint8Array default _TypedArrayFactoryProvider {

  Uint8ClampedArray(int length);

  Uint8ClampedArray.fromList(List<int> list);

  Uint8ClampedArray.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  /** @domName Uint8ClampedArray.length */
  final int length;

  /** @domName Uint8ClampedArray.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint8ClampedArray.subarray */
  Uint8ClampedArray subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLUnknownElement
interface UnknownElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ValidityState
interface ValidityState {

  /** @domName ValidityState.customError */
  final bool customError;

  /** @domName ValidityState.patternMismatch */
  final bool patternMismatch;

  /** @domName ValidityState.rangeOverflow */
  final bool rangeOverflow;

  /** @domName ValidityState.rangeUnderflow */
  final bool rangeUnderflow;

  /** @domName ValidityState.stepMismatch */
  final bool stepMismatch;

  /** @domName ValidityState.tooLong */
  final bool tooLong;

  /** @domName ValidityState.typeMismatch */
  final bool typeMismatch;

  /** @domName ValidityState.valid */
  final bool valid;

  /** @domName ValidityState.valueMissing */
  final bool valueMissing;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLVideoElement
interface VideoElement extends MediaElement default _Elements {

  VideoElement();

  /** @domName HTMLVideoElement.height */
  int height;

  /** @domName HTMLVideoElement.poster */
  String poster;

  /** @domName HTMLVideoElement.videoHeight */
  final int videoHeight;

  /** @domName HTMLVideoElement.videoWidth */
  final int videoWidth;

  /** @domName HTMLVideoElement.webkitDecodedFrameCount */
  final int webkitDecodedFrameCount;

  /** @domName HTMLVideoElement.webkitDisplayingFullscreen */
  final bool webkitDisplayingFullscreen;

  /** @domName HTMLVideoElement.webkitDroppedFrameCount */
  final int webkitDroppedFrameCount;

  /** @domName HTMLVideoElement.webkitSupportsFullscreen */
  final bool webkitSupportsFullscreen;

  /** @domName HTMLVideoElement.width */
  int width;

  /** @domName HTMLVideoElement.webkitEnterFullScreen */
  void webkitEnterFullScreen();

  /** @domName HTMLVideoElement.webkitEnterFullscreen */
  void webkitEnterFullscreen();

  /** @domName HTMLVideoElement.webkitExitFullScreen */
  void webkitExitFullScreen();

  /** @domName HTMLVideoElement.webkitExitFullscreen */
  void webkitExitFullscreen();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef void VoidCallback();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WaveShaperNode
interface WaveShaperNode extends AudioNode {

  /** @domName WaveShaperNode.curve */
  Float32Array curve;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WaveTable
interface WaveTable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLActiveInfo
interface WebGLActiveInfo {

  /** @domName WebGLActiveInfo.name */
  final String name;

  /** @domName WebGLActiveInfo.size */
  final int size;

  /** @domName WebGLActiveInfo.type */
  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLBuffer
interface WebGLBuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLCompressedTextureS3TC
interface WebGLCompressedTextureS3TC {

  static final int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;

  static final int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;

  static final int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  static final int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLContextAttributes
interface WebGLContextAttributes {

  /** @domName WebGLContextAttributes.alpha */
  bool alpha;

  /** @domName WebGLContextAttributes.antialias */
  bool antialias;

  /** @domName WebGLContextAttributes.depth */
  bool depth;

  /** @domName WebGLContextAttributes.premultipliedAlpha */
  bool premultipliedAlpha;

  /** @domName WebGLContextAttributes.preserveDrawingBuffer */
  bool preserveDrawingBuffer;

  /** @domName WebGLContextAttributes.stencil */
  bool stencil;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLContextEvent
interface WebGLContextEvent extends Event {

  /** @domName WebGLContextEvent.statusMessage */
  final String statusMessage;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDebugRendererInfo
interface WebGLDebugRendererInfo {

  static final int UNMASKED_RENDERER_WEBGL = 0x9246;

  static final int UNMASKED_VENDOR_WEBGL = 0x9245;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDebugShaders
interface WebGLDebugShaders {

  /** @domName WebGLDebugShaders.getTranslatedShaderSource */
  String getTranslatedShaderSource(WebGLShader shader);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLFramebuffer
interface WebGLFramebuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLLoseContext
interface WebGLLoseContext {

  /** @domName WebGLLoseContext.loseContext */
  void loseContext();

  /** @domName WebGLLoseContext.restoreContext */
  void restoreContext();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLProgram
interface WebGLProgram {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLRenderbuffer
interface WebGLRenderbuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLRenderingContext
interface WebGLRenderingContext extends CanvasRenderingContext {

  static final int ACTIVE_ATTRIBUTES = 0x8B89;

  static final int ACTIVE_TEXTURE = 0x84E0;

  static final int ACTIVE_UNIFORMS = 0x8B86;

  static final int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static final int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static final int ALPHA = 0x1906;

  static final int ALPHA_BITS = 0x0D55;

  static final int ALWAYS = 0x0207;

  static final int ARRAY_BUFFER = 0x8892;

  static final int ARRAY_BUFFER_BINDING = 0x8894;

  static final int ATTACHED_SHADERS = 0x8B85;

  static final int BACK = 0x0405;

  static final int BLEND = 0x0BE2;

  static final int BLEND_COLOR = 0x8005;

  static final int BLEND_DST_ALPHA = 0x80CA;

  static final int BLEND_DST_RGB = 0x80C8;

  static final int BLEND_EQUATION = 0x8009;

  static final int BLEND_EQUATION_ALPHA = 0x883D;

  static final int BLEND_EQUATION_RGB = 0x8009;

  static final int BLEND_SRC_ALPHA = 0x80CB;

  static final int BLEND_SRC_RGB = 0x80C9;

  static final int BLUE_BITS = 0x0D54;

  static final int BOOL = 0x8B56;

  static final int BOOL_VEC2 = 0x8B57;

  static final int BOOL_VEC3 = 0x8B58;

  static final int BOOL_VEC4 = 0x8B59;

  static final int BROWSER_DEFAULT_WEBGL = 0x9244;

  static final int BUFFER_SIZE = 0x8764;

  static final int BUFFER_USAGE = 0x8765;

  static final int BYTE = 0x1400;

  static final int CCW = 0x0901;

  static final int CLAMP_TO_EDGE = 0x812F;

  static final int COLOR_ATTACHMENT0 = 0x8CE0;

  static final int COLOR_BUFFER_BIT = 0x00004000;

  static final int COLOR_CLEAR_VALUE = 0x0C22;

  static final int COLOR_WRITEMASK = 0x0C23;

  static final int COMPILE_STATUS = 0x8B81;

  static final int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static final int CONSTANT_ALPHA = 0x8003;

  static final int CONSTANT_COLOR = 0x8001;

  static final int CONTEXT_LOST_WEBGL = 0x9242;

  static final int CULL_FACE = 0x0B44;

  static final int CULL_FACE_MODE = 0x0B45;

  static final int CURRENT_PROGRAM = 0x8B8D;

  static final int CURRENT_VERTEX_ATTRIB = 0x8626;

  static final int CW = 0x0900;

  static final int DECR = 0x1E03;

  static final int DECR_WRAP = 0x8508;

  static final int DELETE_STATUS = 0x8B80;

  static final int DEPTH_ATTACHMENT = 0x8D00;

  static final int DEPTH_BITS = 0x0D56;

  static final int DEPTH_BUFFER_BIT = 0x00000100;

  static final int DEPTH_CLEAR_VALUE = 0x0B73;

  static final int DEPTH_COMPONENT = 0x1902;

  static final int DEPTH_COMPONENT16 = 0x81A5;

  static final int DEPTH_FUNC = 0x0B74;

  static final int DEPTH_RANGE = 0x0B70;

  static final int DEPTH_STENCIL = 0x84F9;

  static final int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static final int DEPTH_TEST = 0x0B71;

  static final int DEPTH_WRITEMASK = 0x0B72;

  static final int DITHER = 0x0BD0;

  static final int DONT_CARE = 0x1100;

  static final int DST_ALPHA = 0x0304;

  static final int DST_COLOR = 0x0306;

  static final int DYNAMIC_DRAW = 0x88E8;

  static final int ELEMENT_ARRAY_BUFFER = 0x8893;

  static final int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static final int EQUAL = 0x0202;

  static final int FASTEST = 0x1101;

  static final int FLOAT = 0x1406;

  static final int FLOAT_MAT2 = 0x8B5A;

  static final int FLOAT_MAT3 = 0x8B5B;

  static final int FLOAT_MAT4 = 0x8B5C;

  static final int FLOAT_VEC2 = 0x8B50;

  static final int FLOAT_VEC3 = 0x8B51;

  static final int FLOAT_VEC4 = 0x8B52;

  static final int FRAGMENT_SHADER = 0x8B30;

  static final int FRAMEBUFFER = 0x8D40;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static final int FRAMEBUFFER_BINDING = 0x8CA6;

  static final int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static final int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static final int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static final int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static final int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static final int FRONT = 0x0404;

  static final int FRONT_AND_BACK = 0x0408;

  static final int FRONT_FACE = 0x0B46;

  static final int FUNC_ADD = 0x8006;

  static final int FUNC_REVERSE_SUBTRACT = 0x800B;

  static final int FUNC_SUBTRACT = 0x800A;

  static final int GENERATE_MIPMAP_HINT = 0x8192;

  static final int GEQUAL = 0x0206;

  static final int GREATER = 0x0204;

  static final int GREEN_BITS = 0x0D53;

  static final int HIGH_FLOAT = 0x8DF2;

  static final int HIGH_INT = 0x8DF5;

  static final int INCR = 0x1E02;

  static final int INCR_WRAP = 0x8507;

  static final int INT = 0x1404;

  static final int INT_VEC2 = 0x8B53;

  static final int INT_VEC3 = 0x8B54;

  static final int INT_VEC4 = 0x8B55;

  static final int INVALID_ENUM = 0x0500;

  static final int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static final int INVALID_OPERATION = 0x0502;

  static final int INVALID_VALUE = 0x0501;

  static final int INVERT = 0x150A;

  static final int KEEP = 0x1E00;

  static final int LEQUAL = 0x0203;

  static final int LESS = 0x0201;

  static final int LINEAR = 0x2601;

  static final int LINEAR_MIPMAP_LINEAR = 0x2703;

  static final int LINEAR_MIPMAP_NEAREST = 0x2701;

  static final int LINES = 0x0001;

  static final int LINE_LOOP = 0x0002;

  static final int LINE_STRIP = 0x0003;

  static final int LINE_WIDTH = 0x0B21;

  static final int LINK_STATUS = 0x8B82;

  static final int LOW_FLOAT = 0x8DF0;

  static final int LOW_INT = 0x8DF3;

  static final int LUMINANCE = 0x1909;

  static final int LUMINANCE_ALPHA = 0x190A;

  static final int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static final int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static final int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static final int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static final int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static final int MAX_TEXTURE_SIZE = 0x0D33;

  static final int MAX_VARYING_VECTORS = 0x8DFC;

  static final int MAX_VERTEX_ATTRIBS = 0x8869;

  static final int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static final int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static final int MAX_VIEWPORT_DIMS = 0x0D3A;

  static final int MEDIUM_FLOAT = 0x8DF1;

  static final int MEDIUM_INT = 0x8DF4;

  static final int MIRRORED_REPEAT = 0x8370;

  static final int NEAREST = 0x2600;

  static final int NEAREST_MIPMAP_LINEAR = 0x2702;

  static final int NEAREST_MIPMAP_NEAREST = 0x2700;

  static final int NEVER = 0x0200;

  static final int NICEST = 0x1102;

  static final int NONE = 0;

  static final int NOTEQUAL = 0x0205;

  static final int NO_ERROR = 0;

  static final int ONE = 1;

  static final int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static final int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static final int ONE_MINUS_DST_ALPHA = 0x0305;

  static final int ONE_MINUS_DST_COLOR = 0x0307;

  static final int ONE_MINUS_SRC_ALPHA = 0x0303;

  static final int ONE_MINUS_SRC_COLOR = 0x0301;

  static final int OUT_OF_MEMORY = 0x0505;

  static final int PACK_ALIGNMENT = 0x0D05;

  static final int POINTS = 0x0000;

  static final int POLYGON_OFFSET_FACTOR = 0x8038;

  static final int POLYGON_OFFSET_FILL = 0x8037;

  static final int POLYGON_OFFSET_UNITS = 0x2A00;

  static final int RED_BITS = 0x0D52;

  static final int RENDERBUFFER = 0x8D41;

  static final int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static final int RENDERBUFFER_BINDING = 0x8CA7;

  static final int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static final int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static final int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static final int RENDERBUFFER_HEIGHT = 0x8D43;

  static final int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static final int RENDERBUFFER_RED_SIZE = 0x8D50;

  static final int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static final int RENDERBUFFER_WIDTH = 0x8D42;

  static final int RENDERER = 0x1F01;

  static final int REPEAT = 0x2901;

  static final int REPLACE = 0x1E01;

  static final int RGB = 0x1907;

  static final int RGB565 = 0x8D62;

  static final int RGB5_A1 = 0x8057;

  static final int RGBA = 0x1908;

  static final int RGBA4 = 0x8056;

  static final int SAMPLER_2D = 0x8B5E;

  static final int SAMPLER_CUBE = 0x8B60;

  static final int SAMPLES = 0x80A9;

  static final int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static final int SAMPLE_BUFFERS = 0x80A8;

  static final int SAMPLE_COVERAGE = 0x80A0;

  static final int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static final int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static final int SCISSOR_BOX = 0x0C10;

  static final int SCISSOR_TEST = 0x0C11;

  static final int SHADER_TYPE = 0x8B4F;

  static final int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static final int SHORT = 0x1402;

  static final int SRC_ALPHA = 0x0302;

  static final int SRC_ALPHA_SATURATE = 0x0308;

  static final int SRC_COLOR = 0x0300;

  static final int STATIC_DRAW = 0x88E4;

  static final int STENCIL_ATTACHMENT = 0x8D20;

  static final int STENCIL_BACK_FAIL = 0x8801;

  static final int STENCIL_BACK_FUNC = 0x8800;

  static final int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static final int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static final int STENCIL_BACK_REF = 0x8CA3;

  static final int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static final int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static final int STENCIL_BITS = 0x0D57;

  static final int STENCIL_BUFFER_BIT = 0x00000400;

  static final int STENCIL_CLEAR_VALUE = 0x0B91;

  static final int STENCIL_FAIL = 0x0B94;

  static final int STENCIL_FUNC = 0x0B92;

  static final int STENCIL_INDEX = 0x1901;

  static final int STENCIL_INDEX8 = 0x8D48;

  static final int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static final int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static final int STENCIL_REF = 0x0B97;

  static final int STENCIL_TEST = 0x0B90;

  static final int STENCIL_VALUE_MASK = 0x0B93;

  static final int STENCIL_WRITEMASK = 0x0B98;

  static final int STREAM_DRAW = 0x88E0;

  static final int SUBPIXEL_BITS = 0x0D50;

  static final int TEXTURE = 0x1702;

  static final int TEXTURE0 = 0x84C0;

  static final int TEXTURE1 = 0x84C1;

  static final int TEXTURE10 = 0x84CA;

  static final int TEXTURE11 = 0x84CB;

  static final int TEXTURE12 = 0x84CC;

  static final int TEXTURE13 = 0x84CD;

  static final int TEXTURE14 = 0x84CE;

  static final int TEXTURE15 = 0x84CF;

  static final int TEXTURE16 = 0x84D0;

  static final int TEXTURE17 = 0x84D1;

  static final int TEXTURE18 = 0x84D2;

  static final int TEXTURE19 = 0x84D3;

  static final int TEXTURE2 = 0x84C2;

  static final int TEXTURE20 = 0x84D4;

  static final int TEXTURE21 = 0x84D5;

  static final int TEXTURE22 = 0x84D6;

  static final int TEXTURE23 = 0x84D7;

  static final int TEXTURE24 = 0x84D8;

  static final int TEXTURE25 = 0x84D9;

  static final int TEXTURE26 = 0x84DA;

  static final int TEXTURE27 = 0x84DB;

  static final int TEXTURE28 = 0x84DC;

  static final int TEXTURE29 = 0x84DD;

  static final int TEXTURE3 = 0x84C3;

  static final int TEXTURE30 = 0x84DE;

  static final int TEXTURE31 = 0x84DF;

  static final int TEXTURE4 = 0x84C4;

  static final int TEXTURE5 = 0x84C5;

  static final int TEXTURE6 = 0x84C6;

  static final int TEXTURE7 = 0x84C7;

  static final int TEXTURE8 = 0x84C8;

  static final int TEXTURE9 = 0x84C9;

  static final int TEXTURE_2D = 0x0DE1;

  static final int TEXTURE_BINDING_2D = 0x8069;

  static final int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static final int TEXTURE_CUBE_MAP = 0x8513;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static final int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static final int TEXTURE_MAG_FILTER = 0x2800;

  static final int TEXTURE_MIN_FILTER = 0x2801;

  static final int TEXTURE_WRAP_S = 0x2802;

  static final int TEXTURE_WRAP_T = 0x2803;

  static final int TRIANGLES = 0x0004;

  static final int TRIANGLE_FAN = 0x0006;

  static final int TRIANGLE_STRIP = 0x0005;

  static final int UNPACK_ALIGNMENT = 0x0CF5;

  static final int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static final int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static final int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static final int UNSIGNED_BYTE = 0x1401;

  static final int UNSIGNED_INT = 0x1405;

  static final int UNSIGNED_SHORT = 0x1403;

  static final int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static final int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static final int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static final int VALIDATE_STATUS = 0x8B83;

  static final int VENDOR = 0x1F00;

  static final int VERSION = 0x1F02;

  static final int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static final int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static final int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static final int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static final int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static final int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static final int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static final int VERTEX_SHADER = 0x8B31;

  static final int VIEWPORT = 0x0BA2;

  static final int ZERO = 0;

  /** @domName WebGLRenderingContext.drawingBufferHeight */
  final int drawingBufferHeight;

  /** @domName WebGLRenderingContext.drawingBufferWidth */
  final int drawingBufferWidth;

  /** @domName WebGLRenderingContext.activeTexture */
  void activeTexture(int texture);

  /** @domName WebGLRenderingContext.attachShader */
  void attachShader(WebGLProgram program, WebGLShader shader);

  /** @domName WebGLRenderingContext.bindAttribLocation */
  void bindAttribLocation(WebGLProgram program, int index, String name);

  /** @domName WebGLRenderingContext.bindBuffer */
  void bindBuffer(int target, WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.bindFramebuffer */
  void bindFramebuffer(int target, WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.bindRenderbuffer */
  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.bindTexture */
  void bindTexture(int target, WebGLTexture texture);

  /** @domName WebGLRenderingContext.blendColor */
  void blendColor(num red, num green, num blue, num alpha);

  /** @domName WebGLRenderingContext.blendEquation */
  void blendEquation(int mode);

  /** @domName WebGLRenderingContext.blendEquationSeparate */
  void blendEquationSeparate(int modeRGB, int modeAlpha);

  /** @domName WebGLRenderingContext.blendFunc */
  void blendFunc(int sfactor, int dfactor);

  /** @domName WebGLRenderingContext.blendFuncSeparate */
  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);

  /** @domName WebGLRenderingContext.bufferData */
  void bufferData(int target, data_OR_size, int usage);

  /** @domName WebGLRenderingContext.bufferSubData */
  void bufferSubData(int target, int offset, data);

  /** @domName WebGLRenderingContext.checkFramebufferStatus */
  int checkFramebufferStatus(int target);

  /** @domName WebGLRenderingContext.clear */
  void clear(int mask);

  /** @domName WebGLRenderingContext.clearColor */
  void clearColor(num red, num green, num blue, num alpha);

  /** @domName WebGLRenderingContext.clearDepth */
  void clearDepth(num depth);

  /** @domName WebGLRenderingContext.clearStencil */
  void clearStencil(int s);

  /** @domName WebGLRenderingContext.colorMask */
  void colorMask(bool red, bool green, bool blue, bool alpha);

  /** @domName WebGLRenderingContext.compileShader */
  void compileShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.compressedTexImage2D */
  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data);

  /** @domName WebGLRenderingContext.compressedTexSubImage2D */
  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data);

  /** @domName WebGLRenderingContext.copyTexImage2D */
  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border);

  /** @domName WebGLRenderingContext.copyTexSubImage2D */
  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);

  /** @domName WebGLRenderingContext.createBuffer */
  WebGLBuffer createBuffer();

  /** @domName WebGLRenderingContext.createFramebuffer */
  WebGLFramebuffer createFramebuffer();

  /** @domName WebGLRenderingContext.createProgram */
  WebGLProgram createProgram();

  /** @domName WebGLRenderingContext.createRenderbuffer */
  WebGLRenderbuffer createRenderbuffer();

  /** @domName WebGLRenderingContext.createShader */
  WebGLShader createShader(int type);

  /** @domName WebGLRenderingContext.createTexture */
  WebGLTexture createTexture();

  /** @domName WebGLRenderingContext.cullFace */
  void cullFace(int mode);

  /** @domName WebGLRenderingContext.deleteBuffer */
  void deleteBuffer(WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.deleteFramebuffer */
  void deleteFramebuffer(WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.deleteProgram */
  void deleteProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.deleteRenderbuffer */
  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.deleteShader */
  void deleteShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.deleteTexture */
  void deleteTexture(WebGLTexture texture);

  /** @domName WebGLRenderingContext.depthFunc */
  void depthFunc(int func);

  /** @domName WebGLRenderingContext.depthMask */
  void depthMask(bool flag);

  /** @domName WebGLRenderingContext.depthRange */
  void depthRange(num zNear, num zFar);

  /** @domName WebGLRenderingContext.detachShader */
  void detachShader(WebGLProgram program, WebGLShader shader);

  /** @domName WebGLRenderingContext.disable */
  void disable(int cap);

  /** @domName WebGLRenderingContext.disableVertexAttribArray */
  void disableVertexAttribArray(int index);

  /** @domName WebGLRenderingContext.drawArrays */
  void drawArrays(int mode, int first, int count);

  /** @domName WebGLRenderingContext.drawElements */
  void drawElements(int mode, int count, int type, int offset);

  /** @domName WebGLRenderingContext.enable */
  void enable(int cap);

  /** @domName WebGLRenderingContext.enableVertexAttribArray */
  void enableVertexAttribArray(int index);

  /** @domName WebGLRenderingContext.finish */
  void finish();

  /** @domName WebGLRenderingContext.flush */
  void flush();

  /** @domName WebGLRenderingContext.framebufferRenderbuffer */
  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.framebufferTexture2D */
  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level);

  /** @domName WebGLRenderingContext.frontFace */
  void frontFace(int mode);

  /** @domName WebGLRenderingContext.generateMipmap */
  void generateMipmap(int target);

  /** @domName WebGLRenderingContext.getActiveAttrib */
  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index);

  /** @domName WebGLRenderingContext.getActiveUniform */
  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index);

  /** @domName WebGLRenderingContext.getAttachedShaders */
  List getAttachedShaders(WebGLProgram program);

  /** @domName WebGLRenderingContext.getAttribLocation */
  int getAttribLocation(WebGLProgram program, String name);

  /** @domName WebGLRenderingContext.getBufferParameter */
  Object getBufferParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getContextAttributes */
  WebGLContextAttributes getContextAttributes();

  /** @domName WebGLRenderingContext.getError */
  int getError();

  /** @domName WebGLRenderingContext.getExtension */
  Object getExtension(String name);

  /** @domName WebGLRenderingContext.getFramebufferAttachmentParameter */
  Object getFramebufferAttachmentParameter(int target, int attachment, int pname);

  /** @domName WebGLRenderingContext.getParameter */
  Object getParameter(int pname);

  /** @domName WebGLRenderingContext.getProgramInfoLog */
  String getProgramInfoLog(WebGLProgram program);

  /** @domName WebGLRenderingContext.getProgramParameter */
  Object getProgramParameter(WebGLProgram program, int pname);

  /** @domName WebGLRenderingContext.getRenderbufferParameter */
  Object getRenderbufferParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getShaderInfoLog */
  String getShaderInfoLog(WebGLShader shader);

  /** @domName WebGLRenderingContext.getShaderParameter */
  Object getShaderParameter(WebGLShader shader, int pname);

  /** @domName WebGLRenderingContext.getShaderPrecisionFormat */
  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype);

  /** @domName WebGLRenderingContext.getShaderSource */
  String getShaderSource(WebGLShader shader);

  /** @domName WebGLRenderingContext.getTexParameter */
  Object getTexParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getUniform */
  Object getUniform(WebGLProgram program, WebGLUniformLocation location);

  /** @domName WebGLRenderingContext.getUniformLocation */
  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name);

  /** @domName WebGLRenderingContext.getVertexAttrib */
  Object getVertexAttrib(int index, int pname);

  /** @domName WebGLRenderingContext.getVertexAttribOffset */
  int getVertexAttribOffset(int index, int pname);

  /** @domName WebGLRenderingContext.hint */
  void hint(int target, int mode);

  /** @domName WebGLRenderingContext.isBuffer */
  bool isBuffer(WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.isContextLost */
  bool isContextLost();

  /** @domName WebGLRenderingContext.isEnabled */
  bool isEnabled(int cap);

  /** @domName WebGLRenderingContext.isFramebuffer */
  bool isFramebuffer(WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.isProgram */
  bool isProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.isRenderbuffer */
  bool isRenderbuffer(WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.isShader */
  bool isShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.isTexture */
  bool isTexture(WebGLTexture texture);

  /** @domName WebGLRenderingContext.lineWidth */
  void lineWidth(num width);

  /** @domName WebGLRenderingContext.linkProgram */
  void linkProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.pixelStorei */
  void pixelStorei(int pname, int param);

  /** @domName WebGLRenderingContext.polygonOffset */
  void polygonOffset(num factor, num units);

  /** @domName WebGLRenderingContext.readPixels */
  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels);

  /** @domName WebGLRenderingContext.releaseShaderCompiler */
  void releaseShaderCompiler();

  /** @domName WebGLRenderingContext.renderbufferStorage */
  void renderbufferStorage(int target, int internalformat, int width, int height);

  /** @domName WebGLRenderingContext.sampleCoverage */
  void sampleCoverage(num value, bool invert);

  /** @domName WebGLRenderingContext.scissor */
  void scissor(int x, int y, int width, int height);

  /** @domName WebGLRenderingContext.shaderSource */
  void shaderSource(WebGLShader shader, String string);

  /** @domName WebGLRenderingContext.stencilFunc */
  void stencilFunc(int func, int ref, int mask);

  /** @domName WebGLRenderingContext.stencilFuncSeparate */
  void stencilFuncSeparate(int face, int func, int ref, int mask);

  /** @domName WebGLRenderingContext.stencilMask */
  void stencilMask(int mask);

  /** @domName WebGLRenderingContext.stencilMaskSeparate */
  void stencilMaskSeparate(int face, int mask);

  /** @domName WebGLRenderingContext.stencilOp */
  void stencilOp(int fail, int zfail, int zpass);

  /** @domName WebGLRenderingContext.stencilOpSeparate */
  void stencilOpSeparate(int face, int fail, int zfail, int zpass);

  /** @domName WebGLRenderingContext.texImage2D */
  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, ArrayBufferView pixels]);

  /** @domName WebGLRenderingContext.texParameterf */
  void texParameterf(int target, int pname, num param);

  /** @domName WebGLRenderingContext.texParameteri */
  void texParameteri(int target, int pname, int param);

  /** @domName WebGLRenderingContext.texSubImage2D */
  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, ArrayBufferView pixels]);

  /** @domName WebGLRenderingContext.uniform1f */
  void uniform1f(WebGLUniformLocation location, num x);

  /** @domName WebGLRenderingContext.uniform1fv */
  void uniform1fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform1i */
  void uniform1i(WebGLUniformLocation location, int x);

  /** @domName WebGLRenderingContext.uniform1iv */
  void uniform1iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform2f */
  void uniform2f(WebGLUniformLocation location, num x, num y);

  /** @domName WebGLRenderingContext.uniform2fv */
  void uniform2fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform2i */
  void uniform2i(WebGLUniformLocation location, int x, int y);

  /** @domName WebGLRenderingContext.uniform2iv */
  void uniform2iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform3f */
  void uniform3f(WebGLUniformLocation location, num x, num y, num z);

  /** @domName WebGLRenderingContext.uniform3fv */
  void uniform3fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform3i */
  void uniform3i(WebGLUniformLocation location, int x, int y, int z);

  /** @domName WebGLRenderingContext.uniform3iv */
  void uniform3iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform4f */
  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w);

  /** @domName WebGLRenderingContext.uniform4fv */
  void uniform4fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform4i */
  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w);

  /** @domName WebGLRenderingContext.uniform4iv */
  void uniform4iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniformMatrix2fv */
  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.uniformMatrix3fv */
  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.uniformMatrix4fv */
  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.useProgram */
  void useProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.validateProgram */
  void validateProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.vertexAttrib1f */
  void vertexAttrib1f(int indx, num x);

  /** @domName WebGLRenderingContext.vertexAttrib1fv */
  void vertexAttrib1fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib2f */
  void vertexAttrib2f(int indx, num x, num y);

  /** @domName WebGLRenderingContext.vertexAttrib2fv */
  void vertexAttrib2fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib3f */
  void vertexAttrib3f(int indx, num x, num y, num z);

  /** @domName WebGLRenderingContext.vertexAttrib3fv */
  void vertexAttrib3fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib4f */
  void vertexAttrib4f(int indx, num x, num y, num z, num w);

  /** @domName WebGLRenderingContext.vertexAttrib4fv */
  void vertexAttrib4fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttribPointer */
  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset);

  /** @domName WebGLRenderingContext.viewport */
  void viewport(int x, int y, int width, int height);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLShader
interface WebGLShader {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLShaderPrecisionFormat
interface WebGLShaderPrecisionFormat {

  /** @domName WebGLShaderPrecisionFormat.precision */
  final int precision;

  /** @domName WebGLShaderPrecisionFormat.rangeMax */
  final int rangeMax;

  /** @domName WebGLShaderPrecisionFormat.rangeMin */
  final int rangeMin;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLTexture
interface WebGLTexture {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLUniformLocation
interface WebGLUniformLocation {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLVertexArrayObjectOES
interface WebGLVertexArrayObjectOES {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSFilterValue
interface WebKitCSSFilterValue extends CSSValueList {

  static final int CSS_FILTER_BLUR = 10;

  static final int CSS_FILTER_BRIGHTNESS = 8;

  static final int CSS_FILTER_CONTRAST = 9;

  static final int CSS_FILTER_CUSTOM = 12;

  static final int CSS_FILTER_DROP_SHADOW = 11;

  static final int CSS_FILTER_GRAYSCALE = 2;

  static final int CSS_FILTER_HUE_ROTATE = 5;

  static final int CSS_FILTER_INVERT = 6;

  static final int CSS_FILTER_OPACITY = 7;

  static final int CSS_FILTER_REFERENCE = 1;

  static final int CSS_FILTER_SATURATE = 4;

  static final int CSS_FILTER_SEPIA = 3;

  /** @domName WebKitCSSFilterValue.operationType */
  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSRegionRule
interface WebKitCSSRegionRule extends CSSRule {

  /** @domName WebKitCSSRegionRule.cssRules */
  final CSSRuleList cssRules;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitMutationObserver
interface WebKitMutationObserver {

  /** @domName WebKitMutationObserver.disconnect */
  void disconnect();

  /** @domName WebKitMutationObserver.takeRecords */
  List<MutationRecord> takeRecords();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitNamedFlow
interface WebKitNamedFlow {

  /** @domName WebKitNamedFlow.contentNodes */
  final NodeList contentNodes;

  /** @domName WebKitNamedFlow.overflow */
  final bool overflow;

  /** @domName WebKitNamedFlow.getRegionsByContentNode */
  NodeList getRegionsByContentNode(Node contentNode);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebSocket
interface WebSocket extends EventTarget default _WebSocketFactoryProvider {

  WebSocket(String url);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WebSocketEvents get on();

  static final int CLOSED = 3;

  static final int CLOSING = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  /** @domName WebSocket.URL */
  final String URL;

  /** @domName WebSocket.binaryType */
  String binaryType;

  /** @domName WebSocket.bufferedAmount */
  final int bufferedAmount;

  /** @domName WebSocket.extensions */
  final String extensions;

  /** @domName WebSocket.protocol */
  final String protocol;

  /** @domName WebSocket.readyState */
  final int readyState;

  /** @domName WebSocket.url */
  final String url;

  /** @domName WebSocket.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebSocket.close */
  void close([int code, String reason]);

  /** @domName WebSocket.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName WebSocket.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebSocket.send */
  bool send(String data);
}

interface WebSocketEvents extends Events {

  EventListenerList get close();

  EventListenerList get error();

  EventListenerList get message();

  EventListenerList get open();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WheelEvent
interface WheelEvent extends UIEvent {

  /** @domName WheelEvent.altKey */
  final bool altKey;

  /** @domName WheelEvent.clientX */
  final int clientX;

  /** @domName WheelEvent.clientY */
  final int clientY;

  /** @domName WheelEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName WheelEvent.metaKey */
  final bool metaKey;

  /** @domName WheelEvent.offsetX */
  final int offsetX;

  /** @domName WheelEvent.offsetY */
  final int offsetY;

  /** @domName WheelEvent.screenX */
  final int screenX;

  /** @domName WheelEvent.screenY */
  final int screenY;

  /** @domName WheelEvent.shiftKey */
  final bool shiftKey;

  /** @domName WheelEvent.webkitDirectionInvertedFromDevice */
  final bool webkitDirectionInvertedFromDevice;

  /** @domName WheelEvent.wheelDelta */
  final int wheelDelta;

  /** @domName WheelEvent.wheelDeltaX */
  final int wheelDeltaX;

  /** @domName WheelEvent.wheelDeltaY */
  final int wheelDeltaY;

  /** @domName WheelEvent.x */
  final int x;

  /** @domName WheelEvent.y */
  final int y;

  /** @domName WheelEvent.initWebKitWheelEvent */
  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMWindow
interface Window extends EventTarget {

  /**
   * Executes a [callback] after the next batch of browser layout measurements
   * has completed or would have completed if any browser layout measurements
   * had been scheduled.
   */
  void requestLayoutFrame(TimeoutHandler callback);


  /** @domName DOMWindow.webkitRequestAnimationFrame */
  int requestAnimationFrame(RequestAnimationFrameCallback callback);

  void cancelAnimationFrame(int id);


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WindowEvents get on();

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  /** @domName DOMWindow.applicationCache */
  final DOMApplicationCache applicationCache;

  /** @domName DOMWindow.clientInformation */
  final Navigator clientInformation;

  /** @domName DOMWindow.closed */
  final bool closed;

  /** @domName DOMWindow.console */
  final Console console;

  /** @domName DOMWindow.crypto */
  final Crypto crypto;

  /** @domName DOMWindow.defaultStatus */
  String defaultStatus;

  /** @domName DOMWindow.defaultstatus */
  String defaultstatus;

  /** @domName DOMWindow.devicePixelRatio */
  final num devicePixelRatio;

  /** @domName DOMWindow.document */
  final Document document;

  /** @domName DOMWindow.event */
  final Event event;

  /** @domName DOMWindow.frames */
  final Window frames;

  /** @domName DOMWindow.history */
  final History history;

  /** @domName DOMWindow.innerHeight */
  final int innerHeight;

  /** @domName DOMWindow.innerWidth */
  final int innerWidth;

  /** @domName DOMWindow.length */
  final int length;

  /** @domName DOMWindow.localStorage */
  final Storage localStorage;

  /** @domName DOMWindow.location */
  Location location;

  /** @domName DOMWindow.locationbar */
  final BarInfo locationbar;

  /** @domName DOMWindow.menubar */
  final BarInfo menubar;

  /** @domName DOMWindow.name */
  String name;

  /** @domName DOMWindow.navigator */
  final Navigator navigator;

  /** @domName DOMWindow.offscreenBuffering */
  final bool offscreenBuffering;

  /** @domName DOMWindow.opener */
  final Window opener;

  /** @domName DOMWindow.outerHeight */
  final int outerHeight;

  /** @domName DOMWindow.outerWidth */
  final int outerWidth;

  /** @domName DOMWindow.pageXOffset */
  final int pageXOffset;

  /** @domName DOMWindow.pageYOffset */
  final int pageYOffset;

  /** @domName DOMWindow.parent */
  final Window parent;

  /** @domName DOMWindow.performance */
  final Performance performance;

  /** @domName DOMWindow.personalbar */
  final BarInfo personalbar;

  /** @domName DOMWindow.screen */
  final Screen screen;

  /** @domName DOMWindow.screenLeft */
  final int screenLeft;

  /** @domName DOMWindow.screenTop */
  final int screenTop;

  /** @domName DOMWindow.screenX */
  final int screenX;

  /** @domName DOMWindow.screenY */
  final int screenY;

  /** @domName DOMWindow.scrollX */
  final int scrollX;

  /** @domName DOMWindow.scrollY */
  final int scrollY;

  /** @domName DOMWindow.scrollbars */
  final BarInfo scrollbars;

  /** @domName DOMWindow.self */
  final Window self;

  /** @domName DOMWindow.sessionStorage */
  final Storage sessionStorage;

  /** @domName DOMWindow.status */
  String status;

  /** @domName DOMWindow.statusbar */
  final BarInfo statusbar;

  /** @domName DOMWindow.styleMedia */
  final StyleMedia styleMedia;

  /** @domName DOMWindow.toolbar */
  final BarInfo toolbar;

  /** @domName DOMWindow.top */
  final Window top;

  /** @domName DOMWindow.webkitIndexedDB */
  final IDBFactory webkitIndexedDB;

  /** @domName DOMWindow.webkitNotifications */
  final NotificationCenter webkitNotifications;

  /** @domName DOMWindow.webkitStorageInfo */
  final StorageInfo webkitStorageInfo;

  /** @domName DOMWindow.window */
  final Window window;

  /** @domName DOMWindow.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMWindow.alert */
  void alert(String message);

  /** @domName DOMWindow.atob */
  String atob(String string);

  /** @domName DOMWindow.blur */
  void blur();

  /** @domName DOMWindow.btoa */
  String btoa(String string);

  /** @domName DOMWindow.captureEvents */
  void captureEvents();

  /** @domName DOMWindow.clearInterval */
  void clearInterval(int handle);

  /** @domName DOMWindow.clearTimeout */
  void clearTimeout(int handle);

  /** @domName DOMWindow.close */
  void close();

  /** @domName DOMWindow.confirm */
  bool confirm(String message);

  /** @domName DOMWindow.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName DOMWindow.find */
  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog);

  /** @domName DOMWindow.focus */
  void focus();

  /** @domName DOMWindow.getComputedStyle */
  CSSStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement);

  /** @domName DOMWindow.getMatchedCSSRules */
  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement);

  /** @domName DOMWindow.getSelection */
  DOMSelection getSelection();

  /** @domName DOMWindow.matchMedia */
  MediaQueryList matchMedia(String query);

  /** @domName DOMWindow.moveBy */
  void moveBy(num x, num y);

  /** @domName DOMWindow.moveTo */
  void moveTo(num x, num y);

  /** @domName DOMWindow.open */
  Window open(String url, String name, [String options]);

  /** @domName DOMWindow.openDatabase */
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName DOMWindow.postMessage */
  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]);

  /** @domName DOMWindow.print */
  void print();

  /** @domName DOMWindow.prompt */
  String prompt(String message, String defaultValue);

  /** @domName DOMWindow.releaseEvents */
  void releaseEvents();

  /** @domName DOMWindow.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMWindow.resizeBy */
  void resizeBy(num x, num y);

  /** @domName DOMWindow.resizeTo */
  void resizeTo(num width, num height);

  /** @domName DOMWindow.scroll */
  void scroll(int x, int y);

  /** @domName DOMWindow.scrollBy */
  void scrollBy(int x, int y);

  /** @domName DOMWindow.scrollTo */
  void scrollTo(int x, int y);

  /** @domName DOMWindow.setInterval */
  int setInterval(TimeoutHandler handler, int timeout);

  /** @domName DOMWindow.setTimeout */
  int setTimeout(TimeoutHandler handler, int timeout);

  /** @domName DOMWindow.showModalDialog */
  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]);

  /** @domName DOMWindow.stop */
  void stop();

  /** @domName DOMWindow.webkitCancelAnimationFrame */
  void webkitCancelAnimationFrame(int id);

  /** @domName DOMWindow.webkitCancelRequestAnimationFrame */
  void webkitCancelRequestAnimationFrame(int id);

  /** @domName DOMWindow.webkitConvertPointFromNodeToPage */
  Point webkitConvertPointFromNodeToPage(Node node, Point p);

  /** @domName DOMWindow.webkitConvertPointFromPageToNode */
  Point webkitConvertPointFromPageToNode(Node node, Point p);

  /** @domName DOMWindow.webkitPostMessage */
  void webkitPostMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List transferList]);

  /** @domName DOMWindow.webkitRequestAnimationFrame */
  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback);

  /** @domName DOMWindow.webkitRequestFileSystem */
  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName DOMWindow.webkitResolveLocalFileSystemURL */
  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback, ErrorCallback errorCallback]);

}

interface WindowEvents extends Events {

  EventListenerList get abort();

  EventListenerList get animationEnd();

  EventListenerList get animationIteration();

  EventListenerList get animationStart();

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get canPlay();

  EventListenerList get canPlayThrough();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contentLoaded();

  EventListenerList get contextMenu();

  EventListenerList get deviceMotion();

  EventListenerList get deviceOrientation();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get durationChange();

  EventListenerList get emptied();

  EventListenerList get ended();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get loadStart();

  EventListenerList get loadedData();

  EventListenerList get loadedMetadata();

  EventListenerList get message();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get pageHide();

  EventListenerList get pageShow();

  EventListenerList get pause();

  EventListenerList get play();

  EventListenerList get playing();

  EventListenerList get popState();

  EventListenerList get progress();

  EventListenerList get rateChange();

  EventListenerList get reset();

  EventListenerList get resize();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get seeked();

  EventListenerList get seeking();

  EventListenerList get select();

  EventListenerList get stalled();

  EventListenerList get storage();

  EventListenerList get submit();

  EventListenerList get suspend();

  EventListenerList get timeUpdate();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchMove();

  EventListenerList get touchStart();

  EventListenerList get transitionEnd();

  EventListenerList get unload();

  EventListenerList get volumeChange();

  EventListenerList get waiting();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Worker
interface Worker extends AbstractWorker default _WorkerFactoryProvider {

  Worker(String scriptUrl);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WorkerEvents get on();

  /** @domName Worker.postMessage */
  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts]);

  /** @domName Worker.terminate */
  void terminate();

  /** @domName Worker.webkitPostMessage */
  void webkitPostMessage(/*SerializedScriptValue*/ message, [List messagePorts]);
}

interface WorkerEvents extends AbstractWorkerEvents {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerContext
interface WorkerContext extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WorkerContextEvents get on();

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  /** @domName WorkerContext.location */
  final WorkerLocation location;

  /** @domName WorkerContext.navigator */
  final WorkerNavigator navigator;

  /** @domName WorkerContext.self */
  final WorkerContext self;

  /** @domName WorkerContext.webkitIndexedDB */
  final IDBFactory webkitIndexedDB;

  /** @domName WorkerContext.webkitNotifications */
  final NotificationCenter webkitNotifications;

  /** @domName WorkerContext.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WorkerContext.clearInterval */
  void clearInterval(int handle);

  /** @domName WorkerContext.clearTimeout */
  void clearTimeout(int handle);

  /** @domName WorkerContext.close */
  void close();

  /** @domName WorkerContext.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName WorkerContext.importScripts */
  void importScripts();

  /** @domName WorkerContext.openDatabase */
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName WorkerContext.openDatabaseSync */
  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName WorkerContext.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WorkerContext.setInterval */
  int setInterval(TimeoutHandler handler, int timeout);

  /** @domName WorkerContext.setTimeout */
  int setTimeout(TimeoutHandler handler, int timeout);

  /** @domName WorkerContext.webkitRequestFileSystem */
  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback, ErrorCallback errorCallback]);

  /** @domName WorkerContext.webkitRequestFileSystemSync */
  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size);

  /** @domName WorkerContext.webkitResolveLocalFileSystemSyncURL */
  EntrySync webkitResolveLocalFileSystemSyncURL(String url);

  /** @domName WorkerContext.webkitResolveLocalFileSystemURL */
  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback, ErrorCallback errorCallback]);
}

interface WorkerContextEvents extends Events {

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerLocation
interface WorkerLocation {

  /** @domName WorkerLocation.hash */
  final String hash;

  /** @domName WorkerLocation.host */
  final String host;

  /** @domName WorkerLocation.hostname */
  final String hostname;

  /** @domName WorkerLocation.href */
  final String href;

  /** @domName WorkerLocation.pathname */
  final String pathname;

  /** @domName WorkerLocation.port */
  final String port;

  /** @domName WorkerLocation.protocol */
  final String protocol;

  /** @domName WorkerLocation.search */
  final String search;

  /** @domName WorkerLocation.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerNavigator
interface WorkerNavigator {

  /** @domName WorkerNavigator.appName */
  final String appName;

  /** @domName WorkerNavigator.appVersion */
  final String appVersion;

  /** @domName WorkerNavigator.onLine */
  final bool onLine;

  /** @domName WorkerNavigator.platform */
  final String platform;

  /** @domName WorkerNavigator.userAgent */
  final String userAgent;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequest
interface XMLHttpRequest extends EventTarget default _XMLHttpRequestFactoryProvider {
  // TODO(rnystrom): This name should just be "get" which is valid in Dart, but
  // not correctly implemented yet. (b/4970173)
  XMLHttpRequest.get(String url, onSuccess(XMLHttpRequest request));

  XMLHttpRequest();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  XMLHttpRequestEvents get on();

  static final int DONE = 4;

  static final int HEADERS_RECEIVED = 2;

  static final int LOADING = 3;

  static final int OPENED = 1;

  static final int UNSENT = 0;

  /** @domName XMLHttpRequest.asBlob */
  bool asBlob;

  /** @domName XMLHttpRequest.readyState */
  final int readyState;

  /** @domName XMLHttpRequest.response */
  final Object response;

  /** @domName XMLHttpRequest.responseBlob */
  final Blob responseBlob;

  /** @domName XMLHttpRequest.responseText */
  final String responseText;

  /** @domName XMLHttpRequest.responseType */
  String responseType;

  /** @domName XMLHttpRequest.responseXML */
  final Document responseXML;

  /** @domName XMLHttpRequest.status */
  final int status;

  /** @domName XMLHttpRequest.statusText */
  final String statusText;

  /** @domName XMLHttpRequest.upload */
  final XMLHttpRequestUpload upload;

  /** @domName XMLHttpRequest.withCredentials */
  bool withCredentials;

  /** @domName XMLHttpRequest.abort */
  void abort();

  /** @domName XMLHttpRequest.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequest.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName XMLHttpRequest.getAllResponseHeaders */
  String getAllResponseHeaders();

  /** @domName XMLHttpRequest.getResponseHeader */
  String getResponseHeader(String header);

  /** @domName XMLHttpRequest.open */
  void open(String method, String url, [bool async, String user, String password]);

  /** @domName XMLHttpRequest.overrideMimeType */
  void overrideMimeType(String override);

  /** @domName XMLHttpRequest.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequest.send */
  void send([data]);

  /** @domName XMLHttpRequest.setRequestHeader */
  void setRequestHeader(String header, String value);
}

interface XMLHttpRequestEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();

  EventListenerList get readyStateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestException
interface XMLHttpRequestException {

  static final int ABORT_ERR = 102;

  static final int NETWORK_ERR = 101;

  /** @domName XMLHttpRequestException.code */
  final int code;

  /** @domName XMLHttpRequestException.message */
  final String message;

  /** @domName XMLHttpRequestException.name */
  final String name;

  /** @domName XMLHttpRequestException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestProgressEvent
interface XMLHttpRequestProgressEvent extends ProgressEvent {

  /** @domName XMLHttpRequestProgressEvent.position */
  final int position;

  /** @domName XMLHttpRequestProgressEvent.totalSize */
  final int totalSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestUpload
interface XMLHttpRequestUpload extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  XMLHttpRequestUploadEvents get on();

  /** @domName XMLHttpRequestUpload.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequestUpload.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName XMLHttpRequestUpload.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface XMLHttpRequestUploadEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLSerializer
interface XMLSerializer default _XMLSerializerFactoryProvider {

  XMLSerializer();

  /** @domName XMLSerializer.serializeToString */
  String serializeToString(Node node);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathEvaluator
interface XPathEvaluator default _XPathEvaluatorFactoryProvider {

  XPathEvaluator();

  /** @domName XPathEvaluator.createExpression */
  XPathExpression createExpression(String expression, XPathNSResolver resolver);

  /** @domName XPathEvaluator.createNSResolver */
  XPathNSResolver createNSResolver(Node nodeResolver);

  /** @domName XPathEvaluator.evaluate */
  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathException
interface XPathException {

  static final int INVALID_EXPRESSION_ERR = 51;

  static final int TYPE_ERR = 52;

  /** @domName XPathException.code */
  final int code;

  /** @domName XPathException.message */
  final String message;

  /** @domName XPathException.name */
  final String name;

  /** @domName XPathException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathExpression
interface XPathExpression {

  /** @domName XPathExpression.evaluate */
  XPathResult evaluate(Node contextNode, int type, XPathResult inResult);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathNSResolver
interface XPathNSResolver {

  /** @domName XPathNSResolver.lookupNamespaceURI */
  String lookupNamespaceURI(String prefix);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathResult
interface XPathResult {

  static final int ANY_TYPE = 0;

  static final int ANY_UNORDERED_NODE_TYPE = 8;

  static final int BOOLEAN_TYPE = 3;

  static final int FIRST_ORDERED_NODE_TYPE = 9;

  static final int NUMBER_TYPE = 1;

  static final int ORDERED_NODE_ITERATOR_TYPE = 5;

  static final int ORDERED_NODE_SNAPSHOT_TYPE = 7;

  static final int STRING_TYPE = 2;

  static final int UNORDERED_NODE_ITERATOR_TYPE = 4;

  static final int UNORDERED_NODE_SNAPSHOT_TYPE = 6;

  /** @domName XPathResult.booleanValue */
  final bool booleanValue;

  /** @domName XPathResult.invalidIteratorState */
  final bool invalidIteratorState;

  /** @domName XPathResult.numberValue */
  final num numberValue;

  /** @domName XPathResult.resultType */
  final int resultType;

  /** @domName XPathResult.singleNodeValue */
  final Node singleNodeValue;

  /** @domName XPathResult.snapshotLength */
  final int snapshotLength;

  /** @domName XPathResult.stringValue */
  final String stringValue;

  /** @domName XPathResult.iterateNext */
  Node iterateNext();

  /** @domName XPathResult.snapshotItem */
  Node snapshotItem(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XSLTProcessor
interface XSLTProcessor default _XSLTProcessorFactoryProvider {

  XSLTProcessor();

  /** @domName XSLTProcessor.clearParameters */
  void clearParameters();

  /** @domName XSLTProcessor.getParameter */
  String getParameter(String namespaceURI, String localName);

  /** @domName XSLTProcessor.importStylesheet */
  void importStylesheet(Node stylesheet);

  /** @domName XSLTProcessor.removeParameter */
  void removeParameter(String namespaceURI, String localName);

  /** @domName XSLTProcessor.reset */
  void reset();

  /** @domName XSLTProcessor.setParameter */
  void setParameter(String namespaceURI, String localName, String value);

  /** @domName XSLTProcessor.transformToDocument */
  Document transformToDocument(Node source);

  /** @domName XSLTProcessor.transformToFragment */
  DocumentFragment transformToFragment(Node source, Document docVal);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Elements {

  // helper code goes here

  factory AnchorElement([String href]) {
    _AnchorElementImpl _e = _document.$dom_createElement("a");
    if (href != null) _e.href = href;
    return _e;
  }

  factory AreaElement() {
    _AreaElementImpl _e = _document.$dom_createElement("area");
    return _e;
  }

  factory BRElement() {
    _BRElementImpl _e = _document.$dom_createElement("br");
    return _e;
  }

  factory BaseElement() {
    _BaseElementImpl _e = _document.$dom_createElement("base");
    return _e;
  }

  factory BodyElement() {
    _BodyElementImpl _e = _document.$dom_createElement("body");
    return _e;
  }

  factory ButtonElement() {
    _ButtonElementImpl _e = _document.$dom_createElement("button");
    return _e;
  }

  factory CanvasElement([int height, int width]) {
    _CanvasElementImpl _e = _document.$dom_createElement("canvas");
    if (height != null) _e.height = height;
    if (width != null) _e.width = width;
    return _e;
  }

  factory DListElement() {
    _DListElementImpl _e = _document.$dom_createElement("dl");
    return _e;
  }

  factory DetailsElement() {
    _DetailsElementImpl _e = _document.$dom_createElement("details");
    return _e;
  }

  factory DivElement() {
    _DivElementImpl _e = _document.$dom_createElement("div");
    return _e;
  }

  factory EmbedElement() {
    _EmbedElementImpl _e = _document.$dom_createElement("embed");
    return _e;
  }

  factory FieldSetElement() {
    _FieldSetElementImpl _e = _document.$dom_createElement("fieldset");
    return _e;
  }

  factory HRElement() {
    _HRElementImpl _e = _document.$dom_createElement("hr");
    return _e;
  }

  factory HeadElement() {
    _HeadElementImpl _e = _document.$dom_createElement("head");
    return _e;
  }

  factory HtmlElement() {
    _HtmlElementImpl _e = _document.$dom_createElement("html");
    return _e;
  }

  factory IFrameElement() {
    _IFrameElementImpl _e = _document.$dom_createElement("iframe");
    return _e;
  }

  factory ImageElement([String src, int height, int width]) {
    _ImageElementImpl _e = _document.$dom_createElement("img");
    if (src != null) _e.src = src;
    if (height != null) _e.height = height;
    if (width != null) _e.width = width;
    return _e;
  }

  factory InputElement([String type]) {
    _InputElementImpl _e = _document.$dom_createElement("input");
    if (type != null) _e.type = type;
    return _e;
  }

  factory KeygenElement() {
    _KeygenElementImpl _e = _document.$dom_createElement("keygen");
    return _e;
  }

  factory LIElement() {
    _LIElementImpl _e = _document.$dom_createElement("li");
    return _e;
  }

  factory LabelElement() {
    _LabelElementImpl _e = _document.$dom_createElement("label");
    return _e;
  }

  factory LegendElement() {
    _LegendElementImpl _e = _document.$dom_createElement("legend");
    return _e;
  }

  factory LinkElement() {
    _LinkElementImpl _e = _document.$dom_createElement("link");
    return _e;
  }

  factory MapElement() {
    _MapElementImpl _e = _document.$dom_createElement("map");
    return _e;
  }

  factory MenuElement() {
    _MenuElementImpl _e = _document.$dom_createElement("menu");
    return _e;
  }

  factory MeterElement() {
    _MeterElementImpl _e = _document.$dom_createElement("meter");
    return _e;
  }

  factory OListElement() {
    _OListElementImpl _e = _document.$dom_createElement("ol");
    return _e;
  }

  factory ObjectElement() {
    _ObjectElementImpl _e = _document.$dom_createElement("object");
    return _e;
  }

  factory OptGroupElement() {
    _OptGroupElementImpl _e = _document.$dom_createElement("optgroup");
    return _e;
  }

  factory OutputElement() {
    _OutputElementImpl _e = _document.$dom_createElement("output");
    return _e;
  }

  factory ParagraphElement() {
    _ParagraphElementImpl _e = _document.$dom_createElement("p");
    return _e;
  }

  factory ParamElement() {
    _ParamElementImpl _e = _document.$dom_createElement("param");
    return _e;
  }

  factory PreElement() {
    _PreElementImpl _e = _document.$dom_createElement("pre");
    return _e;
  }

  factory ProgressElement() {
    _ProgressElementImpl _e = _document.$dom_createElement("progress");
    return _e;
  }

  factory ScriptElement() {
    _ScriptElementImpl _e = _document.$dom_createElement("script");
    return _e;
  }

  factory SourceElement() {
    _SourceElementImpl _e = _document.$dom_createElement("source");
    return _e;
  }

  factory SpanElement() {
    _SpanElementImpl _e = _document.$dom_createElement("span");
    return _e;
  }

  factory StyleElement() {
    _StyleElementImpl _e = _document.$dom_createElement("style");
    return _e;
  }

  factory TableCaptionElement() {
    _TableCaptionElementImpl _e = _document.$dom_createElement("caption");
    return _e;
  }

  factory TableCellElement() {
    _TableCellElementImpl _e = _document.$dom_createElement("td");
    return _e;
  }

  factory TableColElement() {
    _TableColElementImpl _e = _document.$dom_createElement("col");
    return _e;
  }

  factory TableElement() {
    _TableElementImpl _e = _document.$dom_createElement("table");
    return _e;
  }

  factory TableRowElement() {
    _TableRowElementImpl _e = _document.$dom_createElement("tr");
    return _e;
  }

  factory TextAreaElement() {
    _TextAreaElementImpl _e = _document.$dom_createElement("textarea");
    return _e;
  }

  factory TitleElement() {
    _TitleElementImpl _e = _document.$dom_createElement("title");
    return _e;
  }

  factory TrackElement() {
    _TrackElementImpl _e = _document.$dom_createElement("track");
    return _e;
  }

  factory UListElement() {
    _UListElementImpl _e = _document.$dom_createElement("ul");
    return _e;
  }

  factory VideoElement() {
    _VideoElementImpl _e = _document.$dom_createElement("video");
    return _e;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void EventListener(Event event);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
interface KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static final int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static final int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static final int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static final int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static final int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static final int JOYSTICK = 5;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
interface KeyName {

  /** The Accept (Commit, OK) key */
  static final String ACCEPT = "Accept";

  /** The Add key */
  static final String ADD = "Add";

  /** The Again key */
  static final String AGAIN = "Again";

  /** The All Candidates key */
  static final String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static final String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static final String ALT = "Alt";

  /** The Alt-Graph key */
  static final String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static final String APPS = "Apps";

  /** The ATTN key */
  static final String ATTN = "Attn";

  /** The Browser Back key */
  static final String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static final String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static final String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static final String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static final String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static final String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static final String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static final String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static final String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static final String CLEAR = "Clear";

  /** The Code Input key */
  static final String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static final String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static final String CONTROL = "Control";

  /** The Crsel key */
  static final String CRSEL = "Crsel";

  /** The Convert key */
  static final String CONVERT = "Convert";

  /** The Copy key */
  static final String COPY = "Copy";

  /** The Cut key */
  static final String CUT = "Cut";

  /** The Decimal key */
  static final String DECIMAL = "Decimal";

  /** The Divide key */
  static final String DIVIDE = "Divide";

  /** The Down Arrow key */
  static final String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static final String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static final String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static final String EJECT = "Eject";

  /** The End key */
  static final String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static final String ENTER = "Enter";

  /** The Erase EOF key */
  static final String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static final String EXECUTE = "Execute";

  /** The Exsel key */
  static final String EXSEL = "Exsel";

  /** The Function switch key */
  static final String FN = "Fn";

  /** The F1 key */
  static final String F1 = "F1";

  /** The F2 key */
  static final String F2 = "F2";

  /** The F3 key */
  static final String F3 = "F3";

  /** The F4 key */
  static final String F4 = "F4";

  /** The F5 key */
  static final String F5 = "F5";

  /** The F6 key */
  static final String F6 = "F6";

  /** The F7 key */
  static final String F7 = "F7";

  /** The F8 key */
  static final String F8 = "F8";

  /** The F9 key */
  static final String F9 = "F9";

  /** The F10 key */
  static final String F10 = "F10";

  /** The F11 key */
  static final String F11 = "F11";

  /** The F12 key */
  static final String F12 = "F12";

  /** The F13 key */
  static final String F13 = "F13";

  /** The F14 key */
  static final String F14 = "F14";

  /** The F15 key */
  static final String F15 = "F15";

  /** The F16 key */
  static final String F16 = "F16";

  /** The F17 key */
  static final String F17 = "F17";

  /** The F18 key */
  static final String F18 = "F18";

  /** The F19 key */
  static final String F19 = "F19";

  /** The F20 key */
  static final String F20 = "F20";

  /** The F21 key */
  static final String F21 = "F21";

  /** The F22 key */
  static final String F22 = "F22";

  /** The F23 key */
  static final String F23 = "F23";

  /** The F24 key */
  static final String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static final String FINAL_MODE = "FinalMode";

  /** The Find key */
  static final String FIND = "Find";

  /** The Full-Width Characters key */
  static final String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static final String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static final String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static final String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static final String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static final String HIRAGANA = "Hiragana";

  /** The Home key */
  static final String HOME = "Home";

  /** The Insert (Ins) key */
  static final String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static final String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static final String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static final String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static final String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static final String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static final String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static final String KATAKANA = "Katakana";

  /** The Start Application One key */
  static final String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static final String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static final String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static final String LEFT = "Left";

  /** The Menu key */
  static final String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static final String META = "Meta";

  /** The Media Next Track key */
  static final String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static final String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static final String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static final String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static final String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static final String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static final String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static final String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static final String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static final String PAGE_UP = "PageUp";

  /** The Paste key */
  static final String PASTE = "Paste";

  /** The Pause key */
  static final String PAUSE = "Pause";

  /** The Play key */
  static final String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static final String POWER = "Power";

  /** The Previous Candidate function key */
  static final String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static final String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static final String PROCESS = "Process";

  /** The Props key */
  static final String PROPS = "Props";

  /** The Right Arrow key */
  static final String RIGHT = "Right";

  /** The Roman Characters function key */
  static final String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static final String SCROLL = "Scroll";

  /** The Select key */
  static final String SELECT = "Select";

  /** The Select Media key */
  static final String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static final String SEPARATOR = "Separator";

  /** The Shift key */
  static final String SHIFT = "Shift";

  /** The Soft1 key */
  static final String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static final String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static final String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static final String SOFT_4 = "Soft4";

  /** The Stop key */
  static final String STOP = "Stop";

  /** The Subtract key */
  static final String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static final String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static final String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static final String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static final String UP_RIGHT = "UpRight";

  /** The Undo key */
  static final String UNDO = "Undo";

  /** The Volume Down key */
  static final String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static final String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static final String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static final String WIN = "Win";

  /** The Zoom key */
  static final String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static final String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static final String TAB = "Tab";

  /** The Cancel key */
  static final String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static final String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static final String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static final String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static final String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static final String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static final String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static final String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static final String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static final String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static final String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static final String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static final String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static final String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static final String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static final String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static final String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static final String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static final String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static final String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static final String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Contains the set of standard values returned by HTMLDocument.getReadyState.
 */
interface ReadyState {
  /**
   * Indicates the document is still loading and parsing.
   */
  static final String LOADING = "loading";

  /**
   * Indicates the document is finished parsing but is still loading
   * subresources.
   */
  static final String INTERACTIVE = "interactive";

  /**
   * Indicates the document and all subresources have been loaded.
   */
  static final String COMPLETE = "complete";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class _Collections {
  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static List map(Iterable<Object> source,
                  List<Object> destination,
                  f(o)) {
    for (final e in source) {
      destination.add(f(e));
    }
    return destination;
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext();
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLHttpRequestUtils {

  // Helper for factory XMLHttpRequest.get
  static XMLHttpRequest get(String url,
                            onSuccess(XMLHttpRequest request)) {
    final request = new XMLHttpRequest();
    request.open('GET', url, true);

    // TODO(terry): Validate after client login added if necessary to forward
    //              cookies to server.
    request.withCredentials = true;

    // Status 0 is for local XHR request.
    request.on.readyStateChange.add((e) {
      if (request.readyState == XMLHttpRequest.DONE &&
          (request.status == 200 || request.status == 0)) {
        onSuccess(request);
      }
    });

    request.send();

    return request;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventFactoryProvider {
  factory Event(String type, [bool canBubble = true,
      bool cancelable = true]) {
    final _EventImpl e = _document.$dom_createEvent("Event");
    e.$dom_initEvent(type, canBubble, cancelable);
    return e;
  }
}

class _MouseEventFactoryProvider {
  factory MouseEvent(String type, Window view, int detail,
      int screenX, int screenY, int clientX, int clientY, int button,
      [bool canBubble = true, bool cancelable = true, bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false,
      EventTarget relatedTarget = null]) {
    final e = _document.$dom_createEvent("MouseEvent");
    e.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
        button, relatedTarget);
    return e;
  }
}

class _CSSStyleDeclarationFactoryProvider {
  factory CSSStyleDeclaration.css(String css) {
    final style = new Element.tag('div').style;
    style.cssText = css;
    return style;
  } 

  factory CSSStyleDeclaration() {
    return new CSSStyleDeclaration.css('');
  }
}

class _DocumentFragmentFactoryProvider {
  /** @domName Document.createDocumentFragment */
  factory DocumentFragment() => document.createDocumentFragment();

  factory DocumentFragment.html(String html) {
    final fragment = new DocumentFragment();
    fragment.innerHTML = html;
    return fragment;
  }

  // TODO(nweiz): enable this when XML is ported.
  // factory DocumentFragment.xml(String xml) {
  //   final fragment = new DocumentFragment();
  //   final e = new XMLElement.tag("xml");
  //   e.innerHTML = xml;
  //
  //   // Copy list first since we don't want liveness during iteration.
  //   final List nodes = new List.from(e.nodes);
  //   fragment.nodes.addAll(nodes);
  //   return fragment;
  // }

  factory DocumentFragment.svg(String svg) {
    final fragment = new DocumentFragment();
    final e = new SVGSVGElement();
    e.innerHTML = svg;

    // Copy list first since we don't want liveness during iteration.
    final List nodes = new List.from(e.nodes);
    fragment.nodes.addAll(nodes);
    return fragment;
  }
}

class _SVGElementFactoryProvider {
  factory SVGElement.tag(String tag) {
    final Element temp =
      _document.$dom_createElementNS("http://www.w3.org/2000/svg", tag);
    return temp;
  }

  factory SVGElement.svg(String svg) {
    Element parentTag;
    final match = _START_TAG_REGEXP.firstMatch(svg);
    if (match != null && match.group(1).toLowerCase() == 'svg') {
      parentTag = new Element.tag('div');
    } else {
      parentTag = new SVGSVGElement();
    }

    parentTag.innerHTML = svg;
    if (parentTag.elements.length == 1) return parentTag.nodes.removeLast();

    throw new IllegalArgumentException('SVG had ${parentTag.elements.length} ' +
        'top-level elements but 1 expected');
  }
}

class _SVGSVGElementFactoryProvider {
  factory SVGSVGElement() {
    final el = new SVGElement.tag("svg");
    // The SVG spec requires the version attribute to match the spec version
    el.attributes['version'] = "1.1";
    return el;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioContextFactoryProvider {
  factory AudioContext() => _wrap(_createAudioContext());
  static _createAudioContext() native "AudioContext_constructor_Callback";
}

class _IDBKeyRangeFactoryProvider {

  factory IDBKeyRange.only(/*IDBKey*/ value) =>
      _wrap(_IDBKeyRangeDOMImpl.only(_unwrap(value)));

  factory IDBKeyRange.lowerBound(/*IDBKey*/ bound, [bool open = false]) =>
      _wrap(_IDBKeyRangeDOMImpl.lowerBound(_unwrap(bound), open));

  factory IDBKeyRange.upperBound(/*IDBKey*/ bound, [bool open = false]) =>
      _wrap(_IDBKeyRangeDOMImpl.upperBound(_unwrap(bound), open));

  factory IDBKeyRange.bound(/*IDBKey*/ lower, /*IDBKey*/ upper,
                            [bool lowerOpen = false, bool upperOpen = false]) =>
      _wrap(_IDBKeyRangeDOMImpl.bound(_unwrap(lower), _unwrap(upper),
                                      lowerOpen, upperOpen));
}

class _TypedArrayFactoryProvider {
  factory Float32Array(int length) => _wrap(_F32(length));
  factory Float32Array.fromList(List<num> list) => _wrap(_F32(ensureNative(list)));
  factory Float32Array.fromBuffer(ArrayBuffer buffer,
                                  [int byteOffset = 0, int length]) =>
      _wrap(_F32(_unwrap(buffer), byteOffset, length));
  static _F32(_arg0, [_arg1, _arg2]) native "Float32Array_constructor_Callback";

  factory Float64Array(int length) => _wrap(_F64(length));
  factory Float64Array.fromList(List<num> list) => _wrap(_F64(ensureNative(list)));
  factory Float64Array.fromBuffer(ArrayBuffer buffer,
                                  [int byteOffset = 0, int length]) =>
      _wrap(_F64(_unwrap(buffer), byteOffset, length));
  static _F64(_arg0, [_arg1, _arg2]) native "Float64Array_constructor_Callback";

  factory Int8Array(int length) => _wrap(_I8(length));
  factory Int8Array.fromList(List<num> list) => _wrap(_I8(ensureNative(list)));
  factory Int8Array.fromBuffer(ArrayBuffer buffer,
                               [int byteOffset = 0, int length]) =>
      _wrap(_I8(_unwrap(buffer), byteOffset, length));
  static _I8(_arg0, [_arg1, _arg2]) native "Int8Array_constructor_Callback";

  factory Int16Array(int length) => _wrap(_I16(length));
  factory Int16Array.fromList(List<num> list) => _wrap(_I16(ensureNative(list)));
  factory Int16Array.fromBuffer(ArrayBuffer buffer,
                                [int byteOffset = 0, int length]) =>
      _wrap(_I16(_unwrap(buffer), byteOffset, length));
  static _I16(_arg0, [_arg1, _arg2]) native "Int16Array_constructor_Callback";

  factory Int32Array(int length) => _wrap(_I32(length));
  factory Int32Array.fromList(List<num> list) => _wrap(_I32(ensureNative(list)));
  factory Int32Array.fromBuffer(ArrayBuffer buffer,
                                [int byteOffset = 0, int length]) =>
      _wrap(_I32(_unwrap(buffer), byteOffset, length));
  static _I32(_arg0, [_arg1, _arg2]) native "Int32Array_constructor_Callback";

  factory Uint8Array(int length) => _wrap(_U8(length));
  factory Uint8Array.fromList(List<num> list) => _wrap(_U8(ensureNative(list)));
  factory Uint8Array.fromBuffer(ArrayBuffer buffer,
                                [int byteOffset = 0, int length]) =>
      _wrap(_U8(_unwrap(buffer), byteOffset, length));
  static _U8(_arg0, [_arg1, _arg2]) native "Uint8Array_constructor_Callback";

  factory Uint16Array(int length) => _wrap(_U16(length));
  factory Uint16Array.fromList(List<num> list) => _wrap(_U16(ensureNative(list)));
  factory Uint16Array.fromBuffer(ArrayBuffer buffer,
                                 [int byteOffset = 0, int length]) =>
      _wrap(_U16(_unwrap(buffer), byteOffset, length));
  static _U16(_arg0, [_arg1, _arg2]) native "Uint16Array_constructor_Callback";

  factory Uint32Array(int length) => _wrap(_U32(length));
  factory Uint32Array.fromList(List<num> list) => _wrap(_U32(ensureNative(list)));
  factory Uint32Array.fromBuffer(ArrayBuffer buffer,
                                 [int byteOffset = 0, int length]) =>
      _wrap(_U32(_unwrap(buffer), byteOffset, length));
  static _U32(_arg0, [_arg1, _arg2]) native "Uint32Array_constructor_Callback";

  factory Uint8ClampedArray(int length) => _wrap(_U8C(length));
  factory Uint8ClampedArray.fromList(List<num> list) => _wrap(_U8C(ensureNative(list)));
  factory Uint8ClampedArray.fromBuffer(ArrayBuffer buffer,
                                       [int byteOffset = 0, int length]) =>
      _wrap(_U8C(_unwrap(buffer), byteOffset, length));
  static _U8C(_arg0, [_arg1, _arg2]) native "Uint8ClampedArray_constructor_Callback";

  static ensureNative(List list) => list;  // TODO: make sure.
}

class _PointFactoryProvider {
  factory Point(num x, num y) => _wrap(_createWebKitPoint(x, y));
  static _createWebKitPoint(num x, num y) native "WebKitPoint_constructor_Callback";
}

class _WebSocketFactoryProvider {
  factory WebSocket(String url) => _wrap(_createWebSocket(url));
  static _createWebSocket(String url) native "WebSocket_constructor_Callback";
}

class _TextFactoryProvider {
  factory Text(String data) => _document.$dom_createTextNode(data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef Object ComputeValue();

class _MeasurementRequest<T> {
  final ComputeValue computeValue;
  final Completer<T> completer;
  Object value;
  bool exception = false;
  _MeasurementRequest(this.computeValue, this.completer);
}

final _MEASUREMENT_MESSAGE = "DART-MEASURE";
List<_MeasurementRequest> _pendingRequests;
List<TimeoutHandler> _pendingMeasurementFrameCallbacks;
bool _nextMeasurementFrameScheduled = false;
bool _firstMeasurementRequest = true;

void _maybeScheduleMeasurementFrame() {
  if (_nextMeasurementFrameScheduled) return;

  _nextMeasurementFrameScheduled = true;
  // postMessage gives us a way to receive a callback after the current
  // event listener has unwound but before the browser has repainted.
  if (_firstMeasurementRequest) {
    // Messages from other windows do not cause a security risk as
    // all we care about is that _onCompleteMeasurementRequests is called
    // after the current event loop is unwound and calling the function is
    // a noop when zero requests are pending.
    window.on.message.add((e) => _completeMeasurementFutures());
    _firstMeasurementRequest = false;
  }

  // TODO(jacobr): other mechanisms such as setImmediate and
  // requestAnimationFrame may work better of platforms that support them.
  // The key is we need a way to execute code immediately after the current
  // event listener queue unwinds.
  window.postMessage(_MEASUREMENT_MESSAGE, "*");
}

/**
 * Registers a [callback] which is called after the next batch of measurements
 * completes. Even if no measurements completed, the callback is triggered
 * when they would have completed to avoid confusing bugs if it happened that
 * no measurements were actually requested.
 */
void _addMeasurementFrameCallback(TimeoutHandler callback) {
  if (_pendingMeasurementFrameCallbacks === null) {
    _pendingMeasurementFrameCallbacks = <TimeoutHandler>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingMeasurementFrameCallbacks.add(callback);
}

/**
 * Returns a [Future] whose value will be the result of evaluating
 * [computeValue] during the next safe measurement interval.
 * The next safe measurement interval is after the current event loop has
 * unwound but before the browser has rendered the page.
 * It is important that the [computeValue] function only queries the html
 * layout and html in any way.
 */
Future _createMeasurementFuture(ComputeValue computeValue,
                                Completer completer) {
  if (_pendingRequests === null) {
    _pendingRequests = <_MeasurementRequest>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingRequests.add(new _MeasurementRequest(computeValue, completer));
  return completer.future;
}

/**
 * Complete all pending measurement futures evaluating them in a single batch
 * so that the the browser is guaranteed to avoid multiple layouts.
 */
void _completeMeasurementFutures() {
  if (_nextMeasurementFrameScheduled == false) {
    // Ignore spurious call to this function.
    return;
  }

  _nextMeasurementFrameScheduled = false;
  // We must compute all new values before fulfilling the futures as
  // the onComplete callbacks for the futures could modify the DOM making
  // subsequent measurement calculations expensive to compute.
  if (_pendingRequests !== null) {
    for (_MeasurementRequest request in _pendingRequests) {
      try {
        request.value = request.computeValue();
      } catch(var e) {
        request.value = e;
        request.exception = true;
      }
    }
  }

  final completedRequests = _pendingRequests;
  final readyMeasurementFrameCallbacks = _pendingMeasurementFrameCallbacks;
  _pendingRequests = null;
  _pendingMeasurementFrameCallbacks = null;
  if (completedRequests !== null) {
    for (_MeasurementRequest request in completedRequests) {
      if (request.exception) {
        request.completer.completeException(request.value);
      } else {
        request.completer.complete(request.value);
      }
    }
  }

  if (readyMeasurementFrameCallbacks !== null) {
    for (TimeoutHandler handler in readyMeasurementFrameCallbacks) {
      // TODO(jacobr): wrap each call to a handler in a try-catch block.
      handler();
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Utils for device detection.
 */
class _Device {
  /**
   * Gets the browser's user agent. Using this function allows tests to inject
   * the user agent.
   * Returns the user agent.
   */
  static String get userAgent() => window.navigator.userAgent;

  /**
   * Determines if the current device is running Firefox.
   */
  static bool get isFirefox() => userAgent.contains("Firefox", 0);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(rnystrom): add a way to supress public classes from DartDoc output.
// TODO(jacobr): we can remove this class now that we are using the $dom_
// convention for deprecated methods rather than truly private methods.
/**
 * This class is intended for testing purposes only.
 */
class Testing {
  static void addEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    final _EventTargetImpl targetImpl = target;
    targetImpl.$dom_addEventListener(type, listener, useCapture);
  }
  static void removeEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    final _EventTargetImpl targetImpl = target;
    targetImpl.$dom_removeEventListener(type, listener, useCapture);
  }

}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMTypeBase {
  final _ptr;

  _DOMTypeBase._wrap(this._ptr) {
  	// We should never be creating duplicate wrappers.
  	// TODO(jacobr): this boolean value is evaluated outside of the assert
  	// to work around a mysterious and flaky bug in tip of trunk versions of
  	// chrome.
  	bool hasExistingWrapper = _ptr.dartObjectLocalStorage === null;
  	assert(hasExistingWrapper);
	  _ptr.dartObjectLocalStorage = this;
  }
}

/** This function is provided for unittest purposes only. */
unwrapDomObject(_DOMTypeBase wrapper) {
  return wrapper._ptr;
}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Iterator for arrays with fixed size.
class _FixedSizeListIterator<T> extends _VariableSizeListIterator<T> {
  _FixedSizeListIterator(List<T> array)
      : super(array),
        _length = array.length;

  bool hasNext() => _length > _pos;

  final int _length;  // Cache array length for faster access.
}

// Iterator for arrays with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  _VariableSizeListIterator(List<T> array)
      : _array = array,
        _pos = 0;

  bool hasNext() => _array.length > _pos;

  T next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    return _array[_pos++];
  }

  final List<T> _array;
  int _pos;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Lists {

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns a sub list copy of this list, from [start] to
   * [:start + length:].
   * Returns an empty list if [length] is 0.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range.
   */
  static List getRange(List a, int start, int length, List accumulator) {
    if (length < 0) throw new IllegalArgumentException('length');
    if (start < 0) throw new IndexOutOfRangeException(start);
    int end = start + length;
    if (end > a.length) throw new IndexOutOfRangeException(end);
    for (int i = start; i < end; i++) {
      accumulator.add(a[i]);
    }
    return accumulator;
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMWrapperBase extends NativeFieldWrapperClass1 {
  var dartObjectLocalStorage;

  abstract String get typeName();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// This API is exploratory.
spawnDomIsolate(Window targetWindowWrapped, String entryPoint) {
  final targetWindow = _unwrap(targetWindowWrapped);
  if (targetWindow is! _DOMWindowDOMImpl && targetWindow is! _DOMWindowCrossFrameDOMImpl) {
    throw 'Bad window argument: $targetWindow';
  }
  final result = new Completer<SendPort>();
  final port = _Utils.spawnDomIsolateImpl(targetWindow, entryPoint);
  window.setTimeout(() { result.complete(port); }, 0);
  return result.future;
}

// layoutTestController implementation.
// FIXME: provide a separate lib for layoutTestController.

var _layoutTestController;

LayoutTestController get layoutTestController() {
  if (_layoutTestController === null)
    _layoutTestController = new LayoutTestController._(_NPObject.retrieve("layoutTestController"));
  return _layoutTestController;
}

class LayoutTestController {
  final _NPObject _npObject;

  LayoutTestController._(this._npObject);

  display() => _npObject.invoke('display');
  dumpAsText() => _npObject.invoke('dumpAsText');
  notifyDone() => _npObject.invoke('notifyDone');
  setCanOpenWindows() => _npObject.invoke('setCanOpenWindows');
  waitUntilDone() => _npObject.invoke('waitUntilDone');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Utils {
  static List convertToList(List list) {
    // FIXME: [possible optimization]: do not copy the array if Dart_IsArray is fine w/ it.
    final length = list.length;
    List result = new List(length);
    result.copyFrom(list, 0, 0, length);
    return result;
  }

  static List convertMapToList(Map map) {
    List result = [];
    map.forEach((k, v) => result.addAll([k, v]));
    return result;
  }

  static void populateMap(Map result, List list) {
    for (int i = 0; i < list.length; i += 2) {
      result[list[i]] = list[i + 1];
    }
  }

  static bool isMap(obj) => obj is Map;

  static Map createMap() => {};

  static makeNotImplementedException(String fileName, int lineNo) {
    return new UnsupportedOperationException('[info: $fileName:$lineNo]');
  }

  static window() native "Utils_window";
  static SendPort spawnDomIsolateImpl(Window window, String entryPoint) native "Utils_spawnDomIsolate";
}

Utils_print(String message) native "Utils_print";

class _NPObject extends _DOMWrapperBase {
  _NPObject();
  static _NPObject retrieve(String key) native "NPObject_retrieve";
  property(String propertyName) native "NPObject_property";
  invoke(String methodName, [ObjectArray args = null]) native "NPObject_invoke";
}

class _DOMWindowCrossFrameDOMImpl extends _DOMWrapperBase implements Window {
  _DOMWindowCrossFrameDOMImpl();

  // Fields.
  History get history() native "DOMWindow_history_cross_frame_Getter";
  Location get location() native "DOMWindow_location_cross_frame_Getter";
  bool get closed() native "DOMWindow_closed_Getter";
  int get length() native "DOMWindow_length_Getter";
  DOMWindow get opener() native "DOMWindow_opener_Getter";
  DOMWindow get parent() native "DOMWindow_parent_Getter";
  DOMWindow get top() native "DOMWindow_top_Getter";

  // Methods.
  void focus() native "DOMWindow_focus_Callback";
  void blur() native "DOMWindow_blur_Callback";
  void close() native "DOMWindow_close_Callback";
  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]) native "DOMWindow_postMessage_Callback";

  // Implementation support.
  String get typeName() => "DOMWindow";
}

class _HistoryCrossFrameDOMImpl extends _DOMWrapperBase implements History {
  _HistoryCrossFrameDOMImpl();

  // Methods.
  void back() native "History_back_Callback";
  void forward() native "History_forward_Callback";
  void go(int distance) native "History_go_Callback";

  // Implementation support.
  String get typeName() => "History";
}

class _LocationCrossFrameDOMImpl extends _DOMWrapperBase implements Location {
  _LocationCrossFrameDOMImpl();

  // Fields.
  void set href(String) native "Location_href_Setter";

  // Implementation support.
  String get typeName() => "Location";
}
